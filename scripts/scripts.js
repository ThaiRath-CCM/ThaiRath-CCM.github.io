(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([ 'module', 'angular' ], function (module, angular) {
            module.exports = factory(angular);
        });
    } else if (typeof module === 'object') {
        module.exports = factory(require('angular'));
    } else {
        if (!root.mp) {
            root.mp = {};
        }

        root.mp.datePicker = factory(root.angular);
    }
}(this, function (angular) {
    'use strict';

    return angular.module('mp.datePicker', []).directive('datePicker', [ '$window', '$locale', function ($window, $locale) {
        // Introduce custom elements for IE8
        $window.document.createElement('date-picker');

        var tmpl = ''
+ '<div class="angular-date-picker">'
+ '    <div class="_month">'
+ '        <button type="button" class="_previous" ng-click="changeMonthBy(-1)">&laquo;</button>'
+ '        <span title="{{ months[month].fullName }}">{{ months[month].shortName }}</span> {{ year }}'
+ '        <button type="button" class="_next" ng-click="changeMonthBy(1)">&raquo;</button>'
+ '    </div>'
+ '    <div class="_days" ng-click="pickDay($event)">'
+ '        <div class="_day-of-week" ng-repeat="dayOfWeek in daysOfWeek" title="{{ dayOfWeek.fullName }}">{{ dayOfWeek.firstLetter }}</div>'
+ '        <div class="_day -padding" ng-repeat="day in leadingDays" data-month-offset="-1">{{ day }}</div>'
+ '        <div class="_day" ng-repeat="day in days" ng-class="{ \'-selected\': (day === selectedDay), \'-today\': (day === today) }">{{ day }}</div>'
+ '        <div class="_day -padding" ng-repeat="day in trailingDays" data-month-offset="1">{{ day }}</div>'
+ '    </div>'
+ '</div>'
        ;

        return {
            restrict: 'AE',
            template: tmpl,
            replace: true,
            require: '?ngModel',
            scope: {
                onDateSelected: '&',
                formatDate: '=', // @todo breaking change: change to & to allow use of date filter directly
                parseDate: '=' // @todo change to &
            },

            link: function ($scope, $element, $attributes, ngModel) {
                var selectedDate = null,
                    days = [], // Slices of this are used for ngRepeat
                    months = [],
                    daysOfWeek = [],
                    firstDayOfWeek = typeof $locale.DATETIME_FORMATS.FIRSTDAYOFWEEK === 'number'
                        ? ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 1) % 7
                        : 0;

                for (var i = 1; i <= 31; i++) {
                    days.push(i);
                }

                for (var i = 0; i < 12; i++) {
                    months.push({
                        fullName: $locale.DATETIME_FORMATS.MONTH[i],
                        shortName: $locale.DATETIME_FORMATS.SHORTMONTH[i]
                    });
                }

                for (var i = 0; i < 7; i++) {
                    var day = $locale.DATETIME_FORMATS.DAY[(i + firstDayOfWeek) % 7];

                    daysOfWeek.push({
                        fullName: day,
                        firstLetter: day.substr(0, 1)
                    });
                }

                $scope.months = months;
                $scope.daysOfWeek = daysOfWeek;

                function setYearAndMonth(date) {
                    $scope.year = date.getFullYear();
                    $scope.month = date.getMonth();

                    var now = new Date();

                    $scope.today = now.getFullYear() === $scope.year && now.getMonth() === $scope.month
                        ? now.getDate()
                        : null;

                    $scope.selectedDay = selectedDate
                            && selectedDate.getFullYear() === $scope.year
                            && selectedDate.getMonth() === $scope.month
                        ? selectedDate.getDate()
                        : null;

                    var firstDayOfMonth = new Date($scope.year, $scope.month, 1),
                        lastDayOfMonth = new Date($scope.year, $scope.month + 1, 0),
                        lastDayOfPreviousMonth = new Date($scope.year, $scope.month, 0),
                        daysInMonth = lastDayOfMonth.getDate(),
                        daysInLastMonth = lastDayOfPreviousMonth.getDate(),
                        dayOfWeek = firstDayOfMonth.getDay(),
                        leadingDays = (dayOfWeek - firstDayOfWeek + 7) % 7 || 7; // Ensure there are always leading days to give context

                    $scope.leadingDays = days.slice(- leadingDays - (31 - daysInLastMonth), daysInLastMonth);
                    $scope.days = days.slice(0, daysInMonth);
                    // Ensure a total of 6 rows to maintain height consistency
                    $scope.trailingDays = days.slice(0, 6 * 7 - (leadingDays + daysInMonth));
                }

                // Default to current year and month
                setYearAndMonth(new Date());

                if (ngModel) {
                    ngModel.$render = function () {
                        selectedDate = ngModel.$viewValue
                            ? $scope.parseDate
                                ? $scope.parseDate(ngModel.$viewValue)
                                : new Date(ngModel.$viewValue)
                            : null;

                        if (selectedDate && !isNaN(selectedDate)) {
                            setYearAndMonth(selectedDate);
                        } else {
                            // Bad input, stay on current year and month, but reset selected date
                            $scope.selectedDay = null;
                        }
                    };
                }

                $scope.changeMonthBy = function (amount) {
                    var date = new Date($scope.year, $scope.month + amount, 1);
                    setYearAndMonth(date);
                };

                $scope.pickDay = function (evt) {
                    var target = angular.element(evt.target);

                    if (target.hasClass('_day')) {
                        var monthOffset = target.attr('data-month-offset');

                        if (monthOffset) {
                            $scope.changeMonthBy(parseInt(monthOffset, 10));
                        }

                        var day = parseInt(target.text(), 10);

                        $scope.selectedDay = day;
                        selectedDate = new Date($scope.year, $scope.month, day);

                        if (ngModel) {
                            ngModel.$setViewValue(
                                $scope.formatDate
                                    ? $scope.formatDate(selectedDate)
                                    : selectedDate.toLocaleDateString()
                            );
                        }

                        $scope.onDateSelected();
                    }
                };
            }
        };
    }])
    .name; // pass back as dependency name
}));

/**
 * angular-drag-and-drop-lists v2.1.0
 *
 * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc
 * Copyright (c) 2014-2017 Google Inc.
 * https://github.com/marceljuenemann/angular-drag-and-drop-lists
 *
 * License: MIT
 */
(function(dndLists) {

  // In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.
  // However, IE and Edge only support a limited number of mime types. The workarounds are described
  // in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design
  var MIME_TYPE = 'application/x-dnd';
  var EDGE_MIME_TYPE = 'application/json';
  var MSIE_MIME_TYPE = 'Text';

  // All valid HTML5 drop effects, in the order in which we prefer to use them.
  var ALL_EFFECTS = ['move', 'copy', 'link'];

  /**
   * Use the dnd-draggable attribute to make your element draggable
   *
   * Attributes:
   * - dnd-draggable      Required attribute. The value has to be an object that represents the data
   *                      of the element. In case of a drag and drop operation the object will be
   *                      serialized and unserialized on the receiving end.
   * - dnd-effect-allowed Use this attribute to limit the operations that can be performed. Valid
   *                      options are "move", "copy" and "link", as well as "all", "copyMove",
   *                      "copyLink" and "linkMove". The semantics of these operations are up to you
   *                      and have to be implemented using the callbacks described below. If you
   *                      allow multiple options, the user can choose between them by using the
   *                      modifier keys (OS specific). The cursor will be changed accordingly,
   *                      expect for IE and Edge, where this is not supported.
   * - dnd-type           Use this attribute if you have different kinds of items in your
   *                      application and you want to limit which items can be dropped into which
   *                      lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute
   *                      must be a lower case string. Upper case characters can be used, but will
   *                      be converted to lower case automatically.
   * - dnd-disable-if     You can use this attribute to dynamically disable the draggability of the
   *                      element. This is useful if you have certain list items that you don't want
   *                      to be draggable, or if you want to disable drag & drop completely without
   *                      having two different code branches (e.g. only allow for admins).
   *
   * Callbacks:
   * - dnd-dragstart      Callback that is invoked when the element was dragged. The original
   *                      dragstart event will be provided in the local event variable.
   * - dnd-moved          Callback that is invoked when the element was moved. Usually you will
   *                      remove your element from the original list in this callback, since the
   *                      directive is not doing that for you automatically. The original dragend
   *                      event will be provided in the local event variable.
   * - dnd-copied         Same as dnd-moved, just that it is called when the element was copied
   *                      instead of moved, so you probably want to implement a different logic.
   * - dnd-linked         Same as dnd-moved, just that it is called when the element was linked
   *                      instead of moved, so you probably want to implement a different logic.
   * - dnd-canceled       Callback that is invoked if the element was dragged, but the operation was
   *                      canceled and the element was not dropped. The original dragend event will
   *                      be provided in the local event variable.
   * - dnd-dragend        Callback that is invoked when the drag operation ended. Available local
   *                      variables are event and dropEffect.
   * - dnd-selected       Callback that is invoked when the element was clicked but not dragged.
   *                      The original click event will be provided in the local event variable.
   * - dnd-callback       Custom callback that is passed to dropzone callbacks and can be used to
   *                      communicate between source and target scopes. The dropzone can pass user
   *                      defined variables to this callback.
   *
   * CSS classes:
   * - dndDragging        This class will be added to the element while the element is being
   *                      dragged. It will affect both the element you see while dragging and the
   *                      source element that stays at it's position. Do not try to hide the source
   *                      element with this class, because that will abort the drag operation.
   * - dndDraggingSource  This class will be added to the element after the drag operation was
   *                      started, meaning it only affects the original element that is still at
   *                      it's source position, and not the "element" that the user is dragging with
   *                      his mouse pointer.
   */
  dndLists.directive('dndDraggable', ['$parse', '$timeout', function($parse, $timeout) {
    return function(scope, element, attr) {
      // Set the HTML5 draggable attribute on the element.
      element.attr("draggable", "true");

      // If the dnd-disable-if attribute is set, we have to watch that.
      if (attr.dndDisableIf) {
        scope.$watch(attr.dndDisableIf, function(disabled) {
          element.attr("draggable", !disabled);
        });
      }

      /**
       * When the drag operation is started we have to prepare the dataTransfer object,
       * which is the primary way we communicate with the target element
       */
      element.on('dragstart', function(event) {
        event = event.originalEvent || event;

        // Check whether the element is draggable, since dragstart might be triggered on a child.
        if (element.attr('draggable') == 'false') return true;

        // Initialize global state.
        dndState.isDragging = true;
        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();

        // Set the allowed drop effects. See below for special IE handling.
        dndState.dropEffect = "none";
        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];
        event.dataTransfer.effectAllowed = dndState.effectAllowed;

        // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:
        // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design
        var item = scope.$eval(attr.dndDraggable);
        var mimeType = MIME_TYPE + (dndState.itemType ? ('-' + dndState.itemType) : '');
        try {
          event.dataTransfer.setData(mimeType, angular.toJson(item));
        } catch (e) {
          // Setting a custom MIME type did not work, we are probably in IE or Edge.
          var data = angular.toJson({item: item, type: dndState.itemType});
          try {
            event.dataTransfer.setData(EDGE_MIME_TYPE, data);
          } catch (e) {
            // We are in Internet Explorer and can only use the Text MIME type. Also note that IE
            // does not allow changing the cursor in the dragover event, therefore we have to choose
            // the one we want to display now by setting effectAllowed.
            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);
            event.dataTransfer.effectAllowed = effectsAllowed[0];
            event.dataTransfer.setData(MSIE_MIME_TYPE, data);
          }
        }

        // Add CSS classes. See documentation above.
        element.addClass("dndDragging");
        $timeout(function() { element.addClass("dndDraggingSource"); }, 0);

        // Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).
        if (event._dndHandle && event.dataTransfer.setDragImage) {
          event.dataTransfer.setDragImage(element[0], 0, 0);
        }

        // Invoke dragstart callback and prepare extra callback for dropzone.
        $parse(attr.dndDragstart)(scope, {event: event});
        if (attr.dndCallback) {
          var callback = $parse(attr.dndCallback);
          dndState.callback = function(params) { return callback(scope, params || {}); };
        }

        event.stopPropagation();
      });

      /**
       * The dragend event is triggered when the element was dropped or when the drag
       * operation was aborted (e.g. hit escape button). Depending on the executed action
       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.
       */
      element.on('dragend', function(event) {
        event = event.originalEvent || event;

        // Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine
        // the used effect, but Chrome has not implemented that field correctly. On Windows
        // it always sets it to 'none', while Chrome on Linux sometimes sets it to something
        // else when it's supposed to send 'none' (drag operation aborted).
        scope.$apply(function() {
          var dropEffect = dndState.dropEffect;
          var cb = {copy: 'dndCopied', link: 'dndLinked', move: 'dndMoved', none: 'dndCanceled'};
          $parse(attr[cb[dropEffect]])(scope, {event: event});
          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});
        });

        // Clean up
        dndState.isDragging = false;
        dndState.callback = undefined;
        element.removeClass("dndDragging");
        element.removeClass("dndDraggingSource");
        event.stopPropagation();

        // In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.
        $timeout(function() { element.removeClass("dndDraggingSource"); }, 0);
      });

      /**
       * When the element is clicked we invoke the callback function
       * specified with the dnd-selected attribute.
       */
      element.on('click', function(event) {
        if (!attr.dndSelected) return;

        event = event.originalEvent || event;
        scope.$apply(function() {
          $parse(attr.dndSelected)(scope, {event: event});
        });

        // Prevent triggering dndSelected in parent elements.
        event.stopPropagation();
      });

      /**
       * Workaround to make element draggable in IE9
       */
      element.on('selectstart', function() {
        if (this.dragDrop) this.dragDrop();
      });
    };
  }]);

  /**
   * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single
   * li element as child with the ng-repeat directive. If you don't do that, we will not be able to
   * position the dropped element correctly. If you want your list to be sortable, also add the
   * dnd-draggable directive to your li element(s).
   *
   * Attributes:
   * - dnd-list             Required attribute. The value has to be the array in which the data of
   *                        the dropped element should be inserted. The value can be blank if used
   *                        with a custom dnd-drop handler that always returns true.
   * - dnd-allowed-types    Optional array of allowed item types. When used, only items that had a
   *                        matching dnd-type attribute will be dropable. Upper case characters will
   *                        automatically be converted to lower case.
   * - dnd-effect-allowed   Optional string expression that limits the drop effects that can be
   *                        performed in the list. See dnd-effect-allowed on dnd-draggable for more
   *                        details on allowed options. The default value is all.
   * - dnd-disable-if       Optional boolean expresssion. When it evaluates to true, no dropping
   *                        into the list is possible. Note that this also disables rearranging
   *                        items inside the list.
   * - dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning
   *                        algorithm will use the left and right halfs of the list items instead of
   *                        the upper and lower halfs.
   * - dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts
   *                        drops from sources outside of the current browser tab. This allows to
   *                        drag and drop accross different browser tabs. The only major browser
   *                        that does not support this is currently Microsoft Edge.
   *
   * Callbacks:
   * - dnd-dragover         Optional expression that is invoked when an element is dragged over the
   *                        list. If the expression is set, but does not return true, the element is
   *                        not allowed to be dropped. The following variables will be available:
   *                        - event: The original dragover event sent by the browser.
   *                        - index: The position in the list at which the element would be dropped.
   *                        - type: The dnd-type set on the dnd-draggable, or undefined if non was
   *                          set. Will be null for drops from external sources in IE and Edge,
   *                          since we don't know the type in those cases.
   *                        - dropEffect: One of move, copy or link, see dnd-effect-allowed.
   *                        - external: Whether the element was dragged from an external source.
   *                        - callback: If dnd-callback was set on the source element, this is a
   *                          function reference to the callback. The callback can be invoked with
   *                          custom variables like this: callback({var1: value1, var2: value2}).
   *                          The callback will be executed on the scope of the source element. If
   *                          dnd-external-sources was set and external is true, this callback will
   *                          not be available.
   * - dnd-drop             Optional expression that is invoked when an element is dropped on the
   *                        list. The same variables as for dnd-dragover will be available, with the
   *                        exception that type is always known and therefore never null. There
   *                        will also be an item variable, which is the transferred object. The
   *                        return value determines the further handling of the drop:
   *                        - falsy: The drop will be canceled and the element won't be inserted.
   *                        - true: Signalises that the drop is allowed, but the dnd-drop
   *                          callback already took care of inserting the element.
   *                        - otherwise: All other return values will be treated as the object to
   *                          insert into the array. In most cases you want to simply return the
   *                          item parameter, but there are no restrictions on what you can return.
   * - dnd-inserted         Optional expression that is invoked after a drop if the element was
   *                        actually inserted into the list. The same local variables as for
   *                        dnd-drop will be available. Note that for reorderings inside the same
   *                        list the old element will still be in the list due to the fact that
   *                        dnd-moved was not called yet.
   *
   * CSS classes:
   * - dndPlaceholder       When an element is dragged over the list, a new placeholder child
   *                        element will be added. This element is of type li and has the class
   *                        dndPlaceholder set. Alternatively, you can define your own placeholder
   *                        by creating a child element with dndPlaceholder class.
   * - dndDragover          Will be added to the list while an element is dragged over the list.
   */
  dndLists.directive('dndList', ['$parse', function($parse) {
    return function(scope, element, attr) {
      // While an element is dragged over the list, this placeholder element is inserted
      // at the location where the element would be inserted after dropping.
      var placeholder = getPlaceholderElement();
      placeholder.remove();

      var placeholderNode = placeholder[0];
      var listNode = element[0];
      var listSettings = {};

      /**
       * The dragenter event is fired when a dragged element or text selection enters a valid drop
       * target. According to the spec, we either need to have a dropzone attribute or listen on
       * dragenter events and call preventDefault(). It should be noted though that no browser seems
       * to enforce this behaviour.
       */
      element.on('dragenter', function (event) {
        event = event.originalEvent || event;

        // Calculate list properties, so that we don't have to repeat this on every dragover event.
        var types = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);
        listSettings = {
          allowedTypes: angular.isArray(types) && types.join('|').toLowerCase().split('|'),
          disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),
          externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),
          horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)
        };

        var mimeType = getMimeType(event.dataTransfer.types);
        if (!mimeType || !isDropAllowed(getItemType(mimeType))) return true;
        event.preventDefault();
      });

      /**
       * The dragover event is triggered "every few hundred milliseconds" while an element
       * is being dragged over our list, or over an child element.
       */
      element.on('dragover', function(event) {
        event = event.originalEvent || event;

        // Check whether the drop is allowed and determine mime type.
        var mimeType = getMimeType(event.dataTransfer.types);
        var itemType = getItemType(mimeType);
        if (!mimeType || !isDropAllowed(itemType)) return true;

        // Make sure the placeholder is shown, which is especially important if the list is empty.
        if (placeholderNode.parentNode != listNode) {
          element.append(placeholder);
        }

        if (event.target != listNode) {
          // Try to find the node direct directly below the list node.
          var listItemNode = event.target;
          while (listItemNode.parentNode != listNode && listItemNode.parentNode) {
            listItemNode = listItemNode.parentNode;
          }

          if (listItemNode.parentNode == listNode && listItemNode != placeholderNode) {
            // If the mouse pointer is in the upper half of the list item element,
            // we position the placeholder before the list item, otherwise after it.
            var rect = listItemNode.getBoundingClientRect();
            if (listSettings.horizontal) {
              var isFirstHalf = event.clientX < rect.left + rect.width / 2;
            } else {
              var isFirstHalf = event.clientY < rect.top + rect.height / 2;
            }
            listNode.insertBefore(placeholderNode,
                isFirstHalf ? listItemNode : listItemNode.nextSibling);
          }
        }

        // In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore
        // ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for
        // drops from external sources, as that throws an exception.
        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;
        var dropEffect = getDropEffect(event, ignoreDataTransfer);
        if (dropEffect == 'none') return stopDragover();

        // At this point we invoke the callback, which still can disallow the drop.
        // We can't do this earlier because we want to pass the index of the placeholder.
        if (attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType)) {
          return stopDragover();
        }

        // Set dropEffect to modify the cursor shown by the browser, unless we're in IE, where this
        // is not supported. This must be done after preventDefault in Firefox.
        event.preventDefault();
        if (!ignoreDataTransfer) {
          event.dataTransfer.dropEffect = dropEffect;
        }

        element.addClass("dndDragover");
        event.stopPropagation();
        return false;
      });

      /**
       * When the element is dropped, we use the position of the placeholder element as the
       * position where we insert the transferred data. This assumes that the list has exactly
       * one child element per array element.
       */
      element.on('drop', function(event) {
        event = event.originalEvent || event;

        // Check whether the drop is allowed and determine mime type.
        var mimeType = getMimeType(event.dataTransfer.types);
        var itemType = getItemType(mimeType);
        if (!mimeType || !isDropAllowed(itemType)) return true;

        // The default behavior in Firefox is to interpret the dropped element as URL and
        // forward to it. We want to prevent that even if our drop is aborted.
        event.preventDefault();

        // Unserialize the data that was serialized in dragstart.
        try {
          var data = JSON.parse(event.dataTransfer.getData(mimeType));
        } catch(e) {
          return stopDragover();
        }

        // Drops with invalid types from external sources might not have been filtered out yet.
        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) {
          itemType = data.type || undefined;
          data = data.item;
          if (!isDropAllowed(itemType)) return stopDragover();
        }

        // Special handling for internal IE drops, see dragover handler.
        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;
        var dropEffect = getDropEffect(event, ignoreDataTransfer);
        if (dropEffect == 'none') return stopDragover();

        // Invoke the callback, which can transform the transferredObject and even abort the drop.
        var index = getPlaceholderIndex();
        if (attr.dndDrop) {
          data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data);
          if (!data) return stopDragover();
        }

        // The drop is definitely going to happen now, store the dropEffect.
        dndState.dropEffect = dropEffect;
        if (!ignoreDataTransfer) {
          event.dataTransfer.dropEffect = dropEffect;
        }

        // Insert the object into the array, unless dnd-drop took care of that (returned true).
        if (data !== true) {
          scope.$apply(function() {
            scope.$eval(attr.dndList).splice(index, 0, data);
          });
        }
        invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data);

        // Clean up
        stopDragover();
        event.stopPropagation();
        return false;
      });

      /**
       * We have to remove the placeholder when the element is no longer dragged over our list. The
       * problem is that the dragleave event is not only fired when the element leaves our list,
       * but also when it leaves a child element. Therefore, we determine whether the mouse cursor
       * is still pointing to an element inside the list or not.
       */
      element.on('dragleave', function(event) {
        event = event.originalEvent || event;

        var newTarget = document.elementFromPoint(event.clientX, event.clientY);
        if (listNode.contains(newTarget) && !event._dndPhShown) {
          // Signalize to potential parent lists that a placeholder is already shown.
          event._dndPhShown = true;
        } else {
          stopDragover();
        }
      });

      /**
       * Given the types array from the DataTransfer object, returns the first valid mime type.
       * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.
       */
      function getMimeType(types) {
        if (!types) return MSIE_MIME_TYPE; // IE 9 workaround.
        for (var i = 0; i < types.length; i++) {
          if (types[i] == MSIE_MIME_TYPE || types[i] == EDGE_MIME_TYPE ||
              types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) {
            return types[i];
          }
        }
        return null;
      }

      /**
       * Determines the type of the item from the dndState, or from the mime type for items from
       * external sources. Returns undefined if no item type was set and null if the item type could
       * not be determined.
       */
      function getItemType(mimeType) {
        if (dndState.isDragging) return dndState.itemType || undefined;
        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) return null;
        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;
      }

      /**
       * Checks various conditions that must be fulfilled for a drop to be allowed, including the
       * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.
       */
      function isDropAllowed(itemType) {
        if (listSettings.disabled) return false;
        if (!listSettings.externalSources && !dndState.isDragging) return false;
        if (!listSettings.allowedTypes || itemType === null) return true;
        return itemType && listSettings.allowedTypes.indexOf(itemType) != -1;
      }

      /**
       * Determines which drop effect to use for the given event. In Internet Explorer we have to
       * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.
       * In those cases we rely on dndState to filter effects. Read the design doc for more details:
       * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design
       */
      function getDropEffect(event, ignoreDataTransfer) {
        var effects = ALL_EFFECTS;
        if (!ignoreDataTransfer) {
          effects = filterEffects(effects, event.dataTransfer.effectAllowed);
        }
        if (dndState.isDragging) {
          effects = filterEffects(effects, dndState.effectAllowed);
        }
        if (attr.dndEffectAllowed) {
          effects = filterEffects(effects, attr.dndEffectAllowed);
        }
        // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,
        // therefore the following modifier keys will only affect other operating systems.
        if (!effects.length) {
          return 'none';
        } else if (event.ctrlKey && effects.indexOf('copy') != -1) {
          return 'copy';
        } else if (event.altKey && effects.indexOf('link') != -1) {
          return 'link';
        } else {
          return effects[0];
        }
      }

      /**
       * Small helper function that cleans up if we aborted a drop.
       */
      function stopDragover() {
        placeholder.remove();
        element.removeClass("dndDragover");
        return true;
      }

      /**
       * Invokes a callback with some interesting parameters and returns the callbacks return value.
       */
      function invokeCallback(expression, event, dropEffect, itemType, index, item) {
        return $parse(expression)(scope, {
          callback: dndState.callback,
          dropEffect: dropEffect,
          event: event,
          external: !dndState.isDragging,
          index: index !== undefined ? index : getPlaceholderIndex(),
          item: item || undefined,
          type: itemType
        });
      }

      /**
       * We use the position of the placeholder node to determine at which position of the array the
       * object needs to be inserted
       */
      function getPlaceholderIndex() {
        return Array.prototype.indexOf.call(listNode.children, placeholderNode);
      }

      /**
       * Tries to find a child element that has the dndPlaceholder class set. If none was found, a
       * new li element is created.
       */
      function getPlaceholderElement() {
        var placeholder;
        angular.forEach(element.children(), function(childNode) {
          var child = angular.element(childNode);
          if (child.hasClass('dndPlaceholder')) {
            placeholder = child;
          }
        });
        return placeholder || angular.element("<li class='dndPlaceholder'></li>");
      }
    };
  }]);

  /**
   * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting
   * drag operations. This is especially useful if you want to use input elements inside of
   * dnd-draggable elements or create specific handle elements. Note: This directive does not work
   * in Internet Explorer 9.
   */
  dndLists.directive('dndNodrag', function() {
    return function(scope, element, attr) {
      // Set as draggable so that we can cancel the events explicitly
      element.attr("draggable", "true");

      /**
       * Since the element is draggable, the browser's default operation is to drag it on dragstart.
       * We will prevent that and also stop the event from bubbling up.
       */
      element.on('dragstart', function(event) {
        event = event.originalEvent || event;

        if (!event._dndHandle) {
          // If a child element already reacted to dragstart and set a dataTransfer object, we will
          // allow that. For example, this is the case for user selections inside of input elements.
          if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {
            event.preventDefault();
          }
          event.stopPropagation();
        }
      });

      /**
       * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element
       * would be removed.
       */
      element.on('dragend', function(event) {
        event = event.originalEvent || event;
        if (!event._dndHandle) {
          event.stopPropagation();
        }
      });
    };
  });

  /**
   * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that
   * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow
   * dnd-draggable elements to only be dragged via specific "handle" elements. Note that Internet
   * Explorer will show the handle element as drag image instead of the dnd-draggable element. You
   * can work around this by styling the handle element differently when it is being dragged. Use
   * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.
   */
  dndLists.directive('dndHandle', function() {
    return function(scope, element, attr) {
      element.attr("draggable", "true");

      element.on('dragstart dragend', function(event) {
        event = event.originalEvent || event;
        event._dndHandle = true;
      });
    };
  });

  /**
   * Filters an array of drop effects using a HTML5 effectAllowed string.
   */
  function filterEffects(effects, effectAllowed) {
    if (effectAllowed == 'all') return effects;
    return effects.filter(function(effect) {
      return effectAllowed.toLowerCase().indexOf(effect) != -1;
    });
  }

  /**
   * For some features we need to maintain global state. This is done here, with these fields:
   * - callback: A callback function set at dragstart that is passed to internal dropzone handlers.
   * - dropEffect: Set in dragstart to "none" and to the actual value in the drop handler. We don't
   *   rely on the dropEffect passed by the browser, since there are various bugs in Chrome and
   *   Safari, and Internet Explorer defaults to copy if effectAllowed is copyMove.
   * - effectAllowed: Set in dragstart based on dnd-effect-allowed. This is needed for IE because
   *   setting effectAllowed on dataTransfer might result in an undesired cursor.
   * - isDragging: True between dragstart and dragend. Falsy for drops from external sources.
   * - itemType: The item type of the dragged element set via dnd-type. This is needed because IE
   *   and Edge don't support custom mime types that we can use to transfer this information.
   */
  var dndState = {};

})(angular.module('dndLists', []));
/**
 * angular-growl - v0.4.0 - 2013-11-19
 * https://github.com/marcorinck/angular-growl
 * Copyright (c) 2013 Marco Rinck; Licensed MIT
 */
angular.module("angular-growl",[]),angular.module("angular-growl").directive("growl",["$rootScope",function(a){"use strict";return{restrict:"A",template:'<div class="growl">	<div class="growl-item alert" ng-repeat="message in messages" ng-class="computeClasses(message)">		<button type="button" class="close" ng-click="deleteMessage(message)">&times;</button>       <div ng-switch="message.enableHtml">           <div ng-switch-when="true" ng-bind-html="message.text"></div>           <div ng-switch-default ng-bind="message.text"></div>       </div>	</div></div>',replace:!1,scope:!0,controller:["$scope","$timeout","growl",function(b,c,d){function e(a){b.messages.push(a),a.ttl&&-1!==a.ttl&&c(function(){b.deleteMessage(a)},a.ttl)}var f=d.onlyUnique();b.messages=[],a.$on("growlMessage",function(a,c){var d;f?(angular.forEach(b.messages,function(a){c.text===a.text&&c.severity===a.severity&&(d=!0)}),d||e(c)):e(c)}),b.deleteMessage=function(a){var c=b.messages.indexOf(a);c>-1&&b.messages.splice(c,1)},b.computeClasses=function(a){return{"alert-success":"success"===a.severity,"alert-error":"error"===a.severity,"alert-danger":"error"===a.severity,"alert-info":"info"===a.severity,"alert-warning":"warn"===a.severity}}}]}}]),angular.module("angular-growl").provider("growl",function(){"use strict";var a=null,b=!1,c="messages",d="text",e="severity",f=!0;this.globalTimeToLive=function(b){a=b},this.globalEnableHtml=function(a){b=a},this.messagesKey=function(a){c=a},this.messageTextKey=function(a){d=a},this.messageSeverityKey=function(a){e=a},this.onlyUniqueMessages=function(a){f=a},this.serverMessagesInterceptor=["$q","growl",function(a,b){function d(a){a.data[c]&&a.data[c].length>0&&b.addServerMessages(a.data[c])}function e(a){return d(a),a}function f(b){return d(b),a.reject(b)}return function(a){return a.then(e,f)}}],this.$get=["$rootScope","$filter",function(c,g){function h(a){p&&(a.text=p(a.text)),c.$broadcast("growlMessage",a)}function i(c,d,e){var f,g=d||{};f={text:c,severity:e,ttl:g.ttl||a,enableHtml:g.enableHtml||b},h(f)}function j(a,b){i(a,b,"warn")}function k(a,b){i(a,b,"error")}function l(a,b){i(a,b,"info")}function m(a,b){i(a,b,"success")}function n(a){var b,c,f,g;for(g=a.length,b=0;g>b;b++)if(c=a[b],c[d]&&c[e]){switch(c[e]){case"warn":f="warn";break;case"success":f="success";break;case"info":f="info";break;case"error":f="error"}i(c[d],void 0,f)}}function o(){return f}var p;try{p=g("translate")}catch(q){}return{addWarnMessage:j,addErrorMessage:k,addInfoMessage:l,addSuccessMessage:m,addServerMessages:n,onlyUnique:o}}]});
/**
 * dirPagination - AngularJS module for paginating (almost) anything.
 *
 *
 * Credits
 * =======
 *
 * Daniel Tabuenca: https://groups.google.com/d/msg/angular/an9QpzqIYiM/r8v-3W1X5vcJ
 * for the idea on how to dynamically invoke the ng-repeat directive.
 *
 * I borrowed a couple of lines and a few attribute names from the AngularUI Bootstrap project:
 * https://github.com/angular-ui/bootstrap/blob/master/src/pagination/pagination.js
 *
 * Copyright 2014 Michael Bromley <michael@michaelbromley.co.uk>
 */

(function() {

    /**
     * Config
     */
    var moduleName = 'angularUtils.directives.dirPagination';
    var DEFAULT_ID = '__default';

    /**
     * Module
     */
    var module;
    try {
        module = angular.module(moduleName);
    } catch(err) {
        // named module does not exist, so create one
        module = angular.module(moduleName, []);
    }

    module
        .directive('dirPaginate', ['$compile', '$parse', 'paginationService', dirPaginateDirective])
        .directive('dirPaginateNoCompile', noCompileDirective)
        .directive('dirPaginationControls', ['paginationService', 'paginationTemplate', dirPaginationControlsDirective])
        .filter('itemsPerPage', ['paginationService', itemsPerPageFilter])
        .service('paginationService', paginationService)
        .provider('paginationTemplate', paginationTemplateProvider)
        .run(['$templateCache',dirPaginationControlsTemplateInstaller]);

    function dirPaginateDirective($compile, $parse, paginationService) {

        return  {
            terminal: true,
            multiElement: true,
            compile: dirPaginationCompileFn
        };

        function dirPaginationCompileFn(tElement, tAttrs){

            var expression = tAttrs.dirPaginate;
            // regex taken directly from https://github.com/angular/angular.js/blob/master/src/ng/directive/ngRepeat.js#L211
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

            var filterPattern = /\|\s*itemsPerPage\s*:[^|\)]*/;
            if (match[2].match(filterPattern) === null) {
                throw 'pagination directive: the \'itemsPerPage\' filter must be set.';
            }
            var itemsPerPageFilterRemoved = match[2].replace(filterPattern, '');
            var collectionGetter = $parse(itemsPerPageFilterRemoved);

            addNoCompileAttributes(tElement);

            // If any value is specified for paginationId, we register the un-evaluated expression at this stage for the benefit of any
            // dir-pagination-controls directives that may be looking for this ID.
            var rawId = tAttrs.paginationId || DEFAULT_ID;
            paginationService.registerInstance(rawId);

            return function dirPaginationLinkFn(scope, element, attrs){

                // Now that we have access to the `scope` we can interpolate any expression given in the paginationId attribute and
                // potentially register a new ID if it evaluates to a different value than the rawId.
                var paginationId = $parse(attrs.paginationId)(scope) || attrs.paginationId || DEFAULT_ID;
                paginationService.registerInstance(paginationId);

                var repeatExpression = getRepeatExpression(expression, paginationId);
                addNgRepeatToElement(element, attrs, repeatExpression);

                removeTemporaryAttributes(element);
                var compiled =  $compile(element);

                var currentPageGetter = makeCurrentPageGetterFn(scope, attrs, paginationId);
                paginationService.setCurrentPageParser(paginationId, currentPageGetter, scope);

                if (typeof attrs.totalItems !== 'undefined') {
                    paginationService.setAsyncModeTrue(paginationId);
                    scope.$watch(function() {
                        return $parse(attrs.totalItems)(scope);
                    }, function (result) {
                        if (0 <= result) {
                            paginationService.setCollectionLength(paginationId, result);
                        }
                    });
                } else {
                    scope.$watchCollection(function() {
                        return collectionGetter(scope);
                    }, function(collection) {
                        if (collection) {
                            paginationService.setCollectionLength(paginationId, collection.length);
                        }
                    });
                }

                // Delegate to the link function returned by the new compilation of the ng-repeat
                compiled(scope);
            };
        }

        /**
         * If a pagination id has been specified, we need to check that it is present as the second argument passed to
         * the itemsPerPage filter. If it is not there, we add it and return the modified expression.
         *
         * @param expression
         * @param paginationId
         * @returns {*}
         */
        function getRepeatExpression(expression, paginationId) {
            var repeatExpression,
                idDefinedInFilter = !!expression.match(/(\|\s*itemsPerPage\s*:[^|]*:[^|]*)/);

            if (paginationId !== DEFAULT_ID && !idDefinedInFilter) {
                repeatExpression = expression.replace(/(\|\s*itemsPerPage\s*:[^|]*)/, "$1 : '" + paginationId + "'");
            } else {
                repeatExpression = expression;
            }

            return repeatExpression;
        }

        /**
         * Adds the ng-repeat directive to the element. In the case of multi-element (-start, -end) it adds the
         * appropriate multi-element ng-repeat to the first and last element in the range.
         * @param element
         * @param attrs
         * @param repeatExpression
         */
        function addNgRepeatToElement(element, attrs, repeatExpression) {
            if (element[0].hasAttribute('dir-paginate-start') || element[0].hasAttribute('data-dir-paginate-start')) {
                // using multiElement mode (dir-paginate-start, dir-paginate-end)
                attrs.$set('ngRepeatStart', repeatExpression);
                element.eq(element.length - 1).attr('ng-repeat-end', true);
            } else {
                attrs.$set('ngRepeat', repeatExpression);
            }
        }

        /**
         * Adds the dir-paginate-no-compile directive to each element in the tElement range.
         * @param tElement
         */
        function addNoCompileAttributes(tElement) {
            angular.forEach(tElement, function(el) {
                if (el.nodeType === Node.ELEMENT_NODE) {
                    angular.element(el).attr('dir-paginate-no-compile', true);
                }
            });
        }

        /**
         * Removes the variations on dir-paginate (data-, -start, -end) and the dir-paginate-no-compile directives.
         * @param element
         */
        function removeTemporaryAttributes(element) {
            angular.forEach(element, function(el) {
                if (el.nodeType === Node.ELEMENT_NODE) {
                    angular.element(el).removeAttr('dir-paginate-no-compile');
                }
            });
            element.eq(0).removeAttr('dir-paginate-start').removeAttr('dir-paginate').removeAttr('data-dir-paginate-start').removeAttr('data-dir-paginate');
            element.eq(element.length - 1).removeAttr('dir-paginate-end').removeAttr('data-dir-paginate-end');
        }

        /**
         * Creates a getter function for the current-page attribute, using the expression provided or a default value if
         * no current-page expression was specified.
         *
         * @param scope
         * @param attrs
         * @param paginationId
         * @returns {*}
         */
        function makeCurrentPageGetterFn(scope, attrs, paginationId) {
            var currentPageGetter;
            if (attrs.currentPage) {
                currentPageGetter = $parse(attrs.currentPage);
            } else {
                // if the current-page attribute was not set, we'll make our own
                var defaultCurrentPage = paginationId + '__currentPage';
                scope[defaultCurrentPage] = 1;
                currentPageGetter = $parse(defaultCurrentPage);
            }
            return currentPageGetter;
        }
    }

    /**
     * This is a helper directive that allows correct compilation when in multi-element mode (ie dir-paginate-start, dir-paginate-end).
     * It is dynamically added to all elements in the dir-paginate compile function, and it prevents further compilation of
     * any inner directives. It is then removed in the link function, and all inner directives are then manually compiled.
     */
    function noCompileDirective() {
        return {
            priority: 5000,
            terminal: true
        };
    }

    function dirPaginationControlsTemplateInstaller($templateCache) {
        $templateCache.put('angularUtils.directives.dirPagination.template', '<ul class="pagination" ng-if="1 < pages.length || !autoHide"><li ng-if="boundaryLinks" ng-class="{ disabled : pagination.current == 1 }"><a href="" ng-click="setCurrent(1)">&laquo;</a></li><li ng-if="directionLinks" ng-class="{ disabled : pagination.current == 1 }"><a href="" ng-click="setCurrent(pagination.current - 1)">&lsaquo;</a></li><li ng-repeat="pageNumber in pages track by $index" ng-class="{ active : pagination.current == pageNumber, disabled : pageNumber == \'...\' || ( ! autoHide && pages.length === 1 ) }"><a href="" ng-click="setCurrent(pageNumber)">{{ pageNumber }}</a></li><li ng-if="directionLinks" ng-class="{ disabled : pagination.current == pagination.last }"><a href="" ng-click="setCurrent(pagination.current + 1)">&rsaquo;</a></li><li ng-if="boundaryLinks"  ng-class="{ disabled : pagination.current == pagination.last }"><a href="" ng-click="setCurrent(pagination.last)">&raquo;</a></li></ul>');
    }

    function dirPaginationControlsDirective(paginationService, paginationTemplate) {

        var numberRegex = /^\d+$/;

        return {
            restrict: 'AE',
            templateUrl: function(elem, attrs) {
                return attrs.templateUrl || paginationTemplate.getPath();
            },
            scope: {
                maxSize: '=?',
                onPageChange: '&?',
                paginationId: '=?',
                autoHide: '=?'
            },
            link: dirPaginationControlsLinkFn
        };

        function dirPaginationControlsLinkFn(scope, element, attrs) {

            // rawId is the un-interpolated value of the pagination-id attribute. This is only important when the corresponding dir-paginate directive has
            // not yet been linked (e.g. if it is inside an ng-if block), and in that case it prevents this controls directive from assuming that there is
            // no corresponding dir-paginate directive and wrongly throwing an exception.
            var rawId = attrs.paginationId ||  DEFAULT_ID;
            var paginationId = scope.paginationId || attrs.paginationId ||  DEFAULT_ID;

            if (!paginationService.isRegistered(paginationId) && !paginationService.isRegistered(rawId)) {
                var idMessage = (paginationId !== DEFAULT_ID) ? ' (id: ' + paginationId + ') ' : ' ';
                throw 'pagination directive: the pagination controls' + idMessage + 'cannot be used without the corresponding pagination directive.';
            }

            if (!scope.maxSize) { scope.maxSize = 9; }
            scope.autoHide = scope.autoHide === undefined ? true : scope.autoHide;
            scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : true;
            scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : false;

            var paginationRange = Math.max(scope.maxSize, 5);
            scope.pages = [];
            scope.pagination = {
                last: 1,
                current: 1
            };
            scope.range = {
                lower: 1,
                upper: 1,
                total: 1
            };

            scope.$watch(function() {
                return (paginationService.getCollectionLength(paginationId) + 1) * paginationService.getItemsPerPage(paginationId);
            }, function(length) {
                if (0 < length) {
                    generatePagination();
                }
            });

            scope.$watch(function() {
                return (paginationService.getItemsPerPage(paginationId));
            }, function(current, previous) {
                if (current != previous && typeof previous !== 'undefined') {
                    goToPage(scope.pagination.current);
                }
            });

            scope.$watch(function() {
                return paginationService.getCurrentPage(paginationId);
            }, function(currentPage, previousPage) {
                if (currentPage != previousPage) {
                    goToPage(currentPage);
                }
            });

            scope.setCurrent = function(num) {
                if (isValidPageNumber(num)) {
                    num = parseInt(num, 10);
                    paginationService.setCurrentPage(paginationId, num);
                }
            };

            function goToPage(num) {
                if (isValidPageNumber(num)) {
                    scope.pages = generatePagesArray(num, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);
                    scope.pagination.current = num;
                    updateRangeValues();

                    // if a callback has been set, then call it with the page number as an argument
                    if (scope.onPageChange) {
                        scope.onPageChange({ newPageNumber : num });
                    }
                }
            }

            function generatePagination() {
                var page = parseInt(paginationService.getCurrentPage(paginationId)) || 1;

                scope.pages = generatePagesArray(page, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);
                scope.pagination.current = page;
                scope.pagination.last = scope.pages[scope.pages.length - 1];
                if (scope.pagination.last < scope.pagination.current) {
                    scope.setCurrent(scope.pagination.last);
                } else {
                    updateRangeValues();
                }
            }

            /**
             * This function updates the values (lower, upper, total) of the `scope.range` object, which can be used in the pagination
             * template to display the current page range, e.g. "showing 21 - 40 of 144 results";
             */
            function updateRangeValues() {
                var currentPage = paginationService.getCurrentPage(paginationId),
                    itemsPerPage = paginationService.getItemsPerPage(paginationId),
                    totalItems = paginationService.getCollectionLength(paginationId);

                scope.range.lower = (currentPage - 1) * itemsPerPage + 1;
                scope.range.upper = Math.min(currentPage * itemsPerPage, totalItems);
                scope.range.total = totalItems;
            }

            function isValidPageNumber(num) {
                return (numberRegex.test(num) && (0 < num && num <= scope.pagination.last));
            }
        }

        /**
         * Generate an array of page numbers (or the '...' string) which is used in an ng-repeat to generate the
         * links used in pagination
         *
         * @param currentPage
         * @param rowsPerPage
         * @param paginationRange
         * @param collectionLength
         * @returns {Array}
         */
        function generatePagesArray(currentPage, collectionLength, rowsPerPage, paginationRange) {
            var pages = [];
            var totalPages = Math.ceil(collectionLength / rowsPerPage);
            var halfWay = Math.ceil(paginationRange / 2);
            var position;

            if (currentPage <= halfWay) {
                position = 'start';
            } else if (totalPages - halfWay < currentPage) {
                position = 'end';
            } else {
                position = 'middle';
            }

            var ellipsesNeeded = paginationRange < totalPages;
            var i = 1;
            while (i <= totalPages && i <= paginationRange) {
                var pageNumber = calculatePageNumber(i, currentPage, paginationRange, totalPages);

                var openingEllipsesNeeded = (i === 2 && (position === 'middle' || position === 'end'));
                var closingEllipsesNeeded = (i === paginationRange - 1 && (position === 'middle' || position === 'start'));
                if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {
                    pages.push('...');
                } else {
                    pages.push(pageNumber);
                }
                i ++;
            }
            return pages;
        }

        /**
         * Given the position in the sequence of pagination links [i], figure out what page number corresponds to that position.
         *
         * @param i
         * @param currentPage
         * @param paginationRange
         * @param totalPages
         * @returns {*}
         */
        function calculatePageNumber(i, currentPage, paginationRange, totalPages) {
            var halfWay = Math.ceil(paginationRange/2);
            if (i === paginationRange) {
                return totalPages;
            } else if (i === 1) {
                return i;
            } else if (paginationRange < totalPages) {
                if (totalPages - halfWay < currentPage) {
                    return totalPages - paginationRange + i;
                } else if (halfWay < currentPage) {
                    return currentPage - halfWay + i;
                } else {
                    return i;
                }
            } else {
                return i;
            }
        }
    }

    /**
     * This filter slices the collection into pages based on the current page number and number of items per page.
     * @param paginationService
     * @returns {Function}
     */
    function itemsPerPageFilter(paginationService) {

        return function(collection, itemsPerPage, paginationId) {
            if (typeof (paginationId) === 'undefined') {
                paginationId = DEFAULT_ID;
            }
            if (!paginationService.isRegistered(paginationId)) {
                throw 'pagination directive: the itemsPerPage id argument (id: ' + paginationId + ') does not match a registered pagination-id.';
            }
            var end;
            var start;
            if (collection instanceof Array) {
                itemsPerPage = parseInt(itemsPerPage) || 9999999999;
                if (paginationService.isAsyncMode(paginationId)) {
                    start = 0;
                } else {
                    start = (paginationService.getCurrentPage(paginationId) - 1) * itemsPerPage;
                }
                end = start + itemsPerPage;
                paginationService.setItemsPerPage(paginationId, itemsPerPage);

                return collection.slice(start, end);
            } else {
                return collection;
            }
        };
    }

    /**
     * This service allows the various parts of the module to communicate and stay in sync.
     */
    function paginationService() {

        var instances = {};
        var lastRegisteredInstance;

        this.registerInstance = function(instanceId) {
            if (typeof instances[instanceId] === 'undefined') {
                instances[instanceId] = {
                    asyncMode: false
                };
                lastRegisteredInstance = instanceId;
            }
        };

        this.isRegistered = function(instanceId) {
            return (typeof instances[instanceId] !== 'undefined');
        };

        this.getLastInstanceId = function() {
            return lastRegisteredInstance;
        };

        this.setCurrentPageParser = function(instanceId, val, scope) {
            instances[instanceId].currentPageParser = val;
            instances[instanceId].context = scope;
        };
        this.setCurrentPage = function(instanceId, val) {
            instances[instanceId].currentPageParser.assign(instances[instanceId].context, val);
        };
        this.getCurrentPage = function(instanceId) {
            var parser = instances[instanceId].currentPageParser;
            return parser ? parser(instances[instanceId].context) : 1;
        };

        this.setItemsPerPage = function(instanceId, val) {
            instances[instanceId].itemsPerPage = val;
        };
        this.getItemsPerPage = function(instanceId) {
            return instances[instanceId].itemsPerPage;
        };

        this.setCollectionLength = function(instanceId, val) {
            instances[instanceId].collectionLength = val;
        };
        this.getCollectionLength = function(instanceId) {
            return instances[instanceId].collectionLength;
        };

        this.setAsyncModeTrue = function(instanceId) {
            instances[instanceId].asyncMode = true;
        };

        this.isAsyncMode = function(instanceId) {
            return instances[instanceId].asyncMode;
        };
    }

    /**
     * This provider allows global configuration of the template path used by the dir-pagination-controls directive.
     */
    function paginationTemplateProvider() {

        var templatePath = 'angularUtils.directives.dirPagination.template';

        this.setPath = function(path) {
            templatePath = path;
        };

        this.$get = function() {
            return {
                getPath: function() {
                    return templatePath;
                }
            };
        };
    }
})();

/**
 * Duo Web SDK v2
 * Copyright 2019, Duo Security
 */

(function (root, factory) {
    /*eslint-disable */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    /*eslint-enable */
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        var Duo = factory();
        // If the Javascript was loaded via a script tag, attempt to autoload
        // the frame.
        Duo._onReady(Duo.init);

        // Attach Duo to the `window` object
        root.Duo = Duo;
  }
}(this, function() {
    var DUO_MESSAGE_FORMAT = /^(?:AUTH|ENROLL)+\|[A-Za-z0-9\+\/=]+\|[A-Za-z0-9\+\/=]+$/;
    var DUO_ERROR_FORMAT = /^ERR\|[\w\s\.\(\)]+$/;
    var DUO_OPEN_WINDOW_FORMAT = /^DUO_OPEN_WINDOW\|/;
    var VALID_OPEN_WINDOW_DOMAINS = [
        'duo.com',
        'duosecurity.com',
        'duomobile.s3-us-west-1.amazonaws.com'
    ];

    var postAction,
        postArgument,
        host,
        sigRequest,
        duoSig,
        appSig,
        iframe,
        submitCallback;

    // We use this function instead of setting initial values in the var
    // declarations to make sure the initial values and subsequent
    // re-initializations are always the same.
    initializeStatefulVariables();

    /**
     * Set local variables to whatever they should be before you call init().
     */
    function initializeStatefulVariables() {
        postAction = '';
        postArgument = 'sig_response';
        host = undefined;
        sigRequest = undefined;
        duoSig = undefined;
        appSig = undefined;
        iframe = undefined;
        submitCallback = undefined;
    }

    function throwError(message, givenUrl) {
        var url = (
            givenUrl ||
            'https://www.duosecurity.com/docs/duoweb#3.-show-the-iframe'
        );
        throw new Error(
            'Duo Web SDK error: ' + message +
            (url ? ('\n' + 'See ' + url + ' for more information') : '')
        );
    }

    function hyphenize(str) {
        return str.replace(/([a-z])([A-Z])/, '$1-$2').toLowerCase();
    }

    // cross-browser data attributes
    function getDataAttribute(element, name) {
        if ('dataset' in element) {
            return element.dataset[name];
        } else {
            return element.getAttribute('data-' + hyphenize(name));
        }
    }

    // cross-browser event binding/unbinding
    function on(context, event, fallbackEvent, callback) {
        if ('addEventListener' in window) {
            context.addEventListener(event, callback, false);
        } else {
            context.attachEvent(fallbackEvent, callback);
        }
    }

    function off(context, event, fallbackEvent, callback) {
        if ('removeEventListener' in window) {
            context.removeEventListener(event, callback, false);
        } else {
            context.detachEvent(fallbackEvent, callback);
        }
    }

    function onReady(callback) {
        on(document, 'DOMContentLoaded', 'onreadystatechange', callback);
    }

    function offReady(callback) {
        off(document, 'DOMContentLoaded', 'onreadystatechange', callback);
    }

    function onMessage(callback) {
        on(window, 'message', 'onmessage', callback);
    }

    function offMessage(callback) {
        off(window, 'message', 'onmessage', callback);
    }

    /**
     * Parse the sig_request parameter, throwing errors if the token contains
     * a server error or if the token is invalid.
     *
     * @param {String} sig Request token
     */
    function parseSigRequest(sig) {
        if (!sig) {
            // nothing to do
            return;
        }

        // see if the token contains an error, throwing it if it does
        if (sig.indexOf('ERR|') === 0) {
            throwError(sig.split('|')[1]);
        }

        // validate the token
        if (sig.indexOf(':') === -1 || sig.split(':').length !== 2) {
            throwError(
                'Duo was given a bad token.  This might indicate a configuration ' +
                'problem with one of Duo\'s client libraries.'
            );
        }

        var sigParts = sig.split(':');

        // hang on to the token, and the parsed duo and app sigs
        sigRequest = sig;
        duoSig = sigParts[0];
        appSig = sigParts[1];

        return {
            sigRequest: sig,
            duoSig: sigParts[0],
            appSig: sigParts[1]
        };
    }

    /**
     * Validate that a MessageEvent came from the Duo service, and that it
     * is a properly formatted payload.
     *
     * The Google Chrome sign-in page injects some JS into pages that also
     * make use of postMessage, so we need to do additional validation above
     * and beyond the origin.
     *
     * @param {MessageEvent} event Message received via postMessage
     */
    function isDuoMessage(event) {
        return Boolean(
            event.origin === ('https://' + host) &&
            typeof event.data === 'string' &&
            (
                event.data.match(DUO_MESSAGE_FORMAT) ||
                event.data.match(DUO_ERROR_FORMAT) ||
                event.data.match(DUO_OPEN_WINDOW_FORMAT)
            )
        );
    }

    /**
     * Validate the request token and prepare for the iframe to become ready.
     *
     * All options below can be passed into an options hash to `Duo.init`, or
     * specified on the iframe using `data-` attributes.
     *
     * Options specified using the options hash will take precedence over
     * `data-` attributes.
     *
     * Example using options hash:
     * ```javascript
     * Duo.init({
     *     iframe: "some_other_id",
     *     host: "api-main.duo.test",
     *     sig_request: "...",
     *     post_action: "/auth",
     *     post_argument: "resp"
     * });
     * ```
     *
     * Example using `data-` attributes:
     * ```html
     * <iframe id="duo_iframe"
     *         data-host="api-main.duo.test"
     *         data-sig-request="..."
     *         data-post-action="/auth"
     *         data-post-argument="resp"
     *         >
     * </iframe>
     * ```
     *
     * Some browsers (especially embedded browsers) don't like it when the Duo
     * Web SDK changes the `src` attribute on the iframe. To prevent this, there
     * is an alternative way to use the Duo Web SDK:
     *
     * Add a div (or any other container element) instead of an iframe to the
     * DOM with an id of "duo_iframe", or pass that element to the
     * `iframeContainer` parameter of `Duo.init`. An iframe will be created and
     * inserted into that container element, preventing `src` change related
     * bugs. WARNING: All other elements in the container will be deleted.
     *
     * The `iframeAttributes` parameter of `Duo.init` is available to set any
     * attributes on the inserted iframe if the Duo Web SDK is inserting the
     * iframe. For details, see the parameter documentation below.
     *
     * @param {Object} options
     * @param {String} options.host - Hostname for the Duo Prompt.
     * @param {String} options.sig_request - Request token.
     * @param {String|HTMLElement} [options.iframe] - The iframe, or id of an
     *     iframe that will be used for the Duo Prompt. If you don't provide
     *     this or the `iframeContainer` parameter the Duo Web SDK will default
     *     to using whatever element has an id of "duo_iframe".
     * @param {String|HTMLElement} [options.iframeContainer] - The element you
     *     want the Duo Prompt inserted into, or the id of that element.
     *     Anything inside this element will be deleted and replaced with an
     *     iframe hosting the Duo prompt. If you don't provide this or the
     *     `iframe` parameter the Duo Web SDK will default to using whatever
     *     element has an id of "duo_iframe".
     * @param {Object} [options.iframeAttributes] - Object with  names and
     *     values coresponding to attributes you want added to the  Duo Prompt
     *     iframe, like `title`, `width` and `allow`. WARNING: this parameter
     *     only works if you use the `iframeContainer` parameter or add an id
     *     of "duo_iframe" to an element that isn't an iframe. If you have
     *     added an iframe to the DOM yourself, you should set those attributes
     *     directly on the iframe.
     * @param {String} [options.post_action=''] - URL to POST back to after a
     *     successful auth.
     * @param {String} [options.post_argument='sig_response'] - Parameter name
     *     to use for response token.
     * @param {Function} [options.submit_callback] - If provided, the Duo Web
     *     SDK will not submit the form. Instead it will execute this callback
     *     function passing in a reference to the "duo_form" form object.
     *     `submit_callback`` can be used to prevent the webpage from reloading.
     */
    function init(options) {
        // If init() is called more than once we have to reset all the local
        // variables to ensure init() will work the same way every time. This
        // helps people making single page applications. SPAs may periodically
        // remove the iframe and add a new one that has to be initialized.
        initializeStatefulVariables();

        if (options) {
            if (options.host) {
                host = options.host;
            }

            if (options.sig_request) {
                parseSigRequest(options.sig_request);
            }

            if (options.post_action) {
                postAction = options.post_action;
            }

            if (options.post_argument) {
                postArgument = options.post_argument;
            }

            if (typeof options.submit_callback === 'function') {
                submitCallback = options.submit_callback;
            }
        }

        var promptElement = getPromptElement(options);
        if (promptElement) {
            // If we can get the element that will host the prompt, set it.
            ready(promptElement, options.iframeAttributes || {});
        } else {
            // If the element that will host the prompt isn't available yet, set
            // it up after the DOM finishes loading.
            asyncReady(options);
        }

        // always clean up after yourself!
        offReady(init);
    }

    /**
     * Given the options from init(), get the iframe or iframe container that
     * should be used for the Duo Prompt. Returns `null` if nothing was found.
     */
    function getPromptElement(options) {
        var result;

        if (options.iframe && options.iframeContainer) {
            throwError(
                'Passing both `iframe` and `iframeContainer` arguments at the' +
                ' same time is not allowed.'
            );
        } else if (options.iframe) {
            // If we are getting an iframe, try to get it and raise if the
            // element we find is NOT an iframe.
            result = getUserDefinedElement(options.iframe);
            validateIframe(result);
        } else if (options.iframeContainer) {
            result = getUserDefinedElement(options.iframeContainer);
            validateIframeContainer(result);
        } else {
            result = document.getElementById('duo_iframe');
        }

        return result;
    }

    /**
     * When given an HTMLElement, return it. When given a string, get an element
     * with that id, else return null.
     */
    function getUserDefinedElement(object) {
        if (object.tagName) {
            return object;
        } else if (typeof object == 'string') {
            return document.getElementById(object);
        }
        return null;
    }

    /**
     * Check if the given thing is an iframe.
     */
    function isIframe(element) {
        return (
            element &&
            element.tagName &&
            element.tagName.toLowerCase() === 'iframe'
        );
    }

    /**
     * Throw an error if we are given an element that is NOT an iframe.
     */
    function validateIframe(element) {
        if (element && !isIframe(element)) {
            throwError(
                '`iframe` only accepts an iframe element or the id of an' +
                ' iframe. To use a non-iframe element, use the' +
                ' `iframeContainer` argument.'
            );
        }
    }

    /**
     * Throw an error if we are given an element that IS an iframe instead of an
     * element that we can insert an iframe into.
     */
    function validateIframeContainer(element) {
        if (element && isIframe(element)) {
            throwError(
                '`iframeContainer` only accepts a non-iframe element or the' +
                ' id of a non-iframe. To use a non-iframe element, use the' +
                ' `iframeContainer` argument on Duo.init().'
            );
        }
    }

    /**
     * Generate the URL that goes to the Duo Prompt.
     */
    function generateIframeSrc() {
        return [
            'https://', host, '/frame/web/v1/auth?tx=', duoSig,
            '&parent=', encodeURIComponent(document.location.href),
            '&v=2.8'
        ].join('');
    }

    /**
     * This function is called when a message was received from another domain
     * using the `postMessage` API.  Check that the event came from the Duo
     * service domain, and that the message is a properly formatted payload,
     * then perform the post back to the primary service.
     *
     * @param event Event object (contains origin and data)
     */
    function onReceivedMessage(event) {
        if (isDuoMessage(event)) {
            if (event.data.match(DUO_OPEN_WINDOW_FORMAT)) {
                var url = event.data.substring("DUO_OPEN_WINDOW|".length);
                if (isValidUrlToOpen(url)) {
                    // Open the URL that comes after the DUO_WINDOW_OPEN token.
                    window.open(url, "_self");
                }
            }
            else {
                // the event came from duo, do the post back
                doPostBack(event.data);

                // always clean up after yourself!
                offMessage(onReceivedMessage);
            }
        }
    }

    /**
     * Validate that this passed in URL is one that we will actually allow to
     * be opened.
     * @param url String URL that the message poster wants to open
     * @returns {boolean} true if we allow this url to be opened in the window
     */
    function isValidUrlToOpen(url) {
        if (!url) {
            return false;
        }

        var parser = document.createElement('a');
        parser.href = url;

        if (parser.protocol === "duotrustedendpoints:") {
            return true;
        } else if (parser.protocol !== "https:") {
            return false;
        }

        for (var i = 0; i < VALID_OPEN_WINDOW_DOMAINS.length; i++) {
           if (parser.hostname.endsWith("." + VALID_OPEN_WINDOW_DOMAINS[i]) ||
                   parser.hostname === VALID_OPEN_WINDOW_DOMAINS[i]) {
               return true;
           }
        }
        return false;
    }

    /**
     * Register a callback to call ready() after the DOM has loaded.
     */
    function asyncReady(options) {
        var callback = function() {
            var promptElement = getPromptElement(options);
            if (!promptElement) {
                throwError(
                    'This page does not contain an iframe for Duo to use.' +
                    ' Add an element like' +
                    ' <iframe id="duo_iframe"></iframe> to this page.'
                );
            }

            ready(promptElement, options.iframeAttributes || {});

            // Always clean up after yourself.
            offReady(callback)
        };

        onReady(callback);
    }

    /**
     * Point the iframe at Duo, then wait for it to postMessage back to us.
     */
    function ready(promptElement, iframeAttributes) {
        if (!host) {
            host = getDataAttribute(promptElement, 'host');

            if (!host) {
                throwError(
                    'No API hostname is given for Duo to use.  Be sure to pass ' +
                    'a `host` parameter to Duo.init, or through the `data-host` ' +
                    'attribute on the iframe element.'
                );
            }
        }

        if (!duoSig || !appSig) {
            parseSigRequest(getDataAttribute(promptElement, 'sigRequest'));

            if (!duoSig || !appSig) {
                throwError(
                    'No valid signed request is given.  Be sure to give the ' +
                    '`sig_request` parameter to Duo.init, or use the ' +
                    '`data-sig-request` attribute on the iframe element.'
                );
            }
        }

        // if postAction/Argument are defaults, see if they are specified
        // as data attributes on the iframe
        if (postAction === '') {
            postAction = getDataAttribute(promptElement, 'postAction') || postAction;
        }

        if (postArgument === 'sig_response') {
            postArgument = getDataAttribute(promptElement, 'postArgument') || postArgument;
        }

        if (isIframe(promptElement)) {
            iframe = promptElement;
            iframe.src = generateIframeSrc();
        } else {
            // If given a container to put an iframe in, clean out any children
            // child elements in case `init()` was called more than once.
            while (promptElement.firstChild) {
                // We call `removeChild()` instead of doing `innerHTML = ""`
                // to make sure we unbind any events.
                promptElement.removeChild(promptElement.firstChild)
            }

            iframe = document.createElement('iframe');

            // Set the src and all other attributes on the new iframe.
            iframeAttributes['src'] = generateIframeSrc();
            for (var name in iframeAttributes) {
                iframe.setAttribute(name, iframeAttributes[name]);
            }

            promptElement.appendChild(iframe);
        }

        // listen for the 'message' event
        onMessage(onReceivedMessage);
    }

    /**
     * We received a postMessage from Duo.  POST back to the primary service
     * with the response token, and any additional user-supplied parameters
     * given in form#duo_form.
     */
    function doPostBack(response) {
        // create a hidden input to contain the response token
        var input = document.createElement('input');
        input.type = 'hidden';
        input.name = postArgument;
        input.value = response + ':' + appSig;

        // user may supply their own form with additional inputs
        var form = document.getElementById('duo_form');

        // if the form doesn't exist, create one
        if (!form) {
            form = document.createElement('form');

            // insert the new form after the iframe
            iframe.parentElement.insertBefore(form, iframe.nextSibling);
        }

        // make sure we are actually posting to the right place
        form.method = 'POST';
        form.action = postAction;

        // add the response token input to the form
        form.appendChild(input);

        // away we go!
        if (typeof submitCallback === "function") {
            submitCallback.call(null, form);
        } else {
            form.submit();
        }
    }

    return {
        init: init,
        _onReady: onReady,
        _parseSigRequest: parseSigRequest,
        _isDuoMessage: isDuoMessage,
        _doPostBack: doPostBack
    };
}));

/***************************************************************
 * Customized by Fritz Madden for Cloud Cover Music
 ***************************************************************/
angular.module('inputDropdown', []).directive('inputDropdown', [function() {
  var templateString =
  '<div class="input-dropdown">' +
    '<input ' +
           'name="{{inputName}}"' +
           'placeholder="{{inputPlaceholder}}"' +
           'type="{{inputValueType}}"' +
           'autocomplete="off"' +
           'ng-model="inputValue"' +
           'class="{{inputClassName}}"' +
           'ng-required="inputRequired"' +
           'ng-change="inputChange()"' +
           'ng-focus="inputFocus($event)"' +
           'ng-blur="inputBlur($event)"' +
           'input-dropdown-validator>' +
     '<ul ng-if="dropdownVisible">' +
      '<li ng-repeat="item in dropdownItems"' +
          'ng-mousedown="selectItem(item)"' +
          'ng-mouseenter="setHighlight($index, $event)"' +
          'ng-class="{\'active\': activeItemIndex === $index}"' +
          '>' +
        '<span ng-if="item.readableName">{{item.readableName}}</span>' +
        '<span ng-if="!item.readableName">{{item}}</span>' +
      '</li>' +
    '</ul>' +
  '</div>';

  return {
    restrict: 'E',
    scope: {
      defaultDropdownItems: '=',
      selectedItem: '=',
      allowCustomInput: '=',
      inputRequired: '=',
      inputValueType: '=?',
      tabSelects: '=?',
      inputName: '@',
      inputClassName: '@',
      inputPlaceholder: '@',
      filterListMethod: '&',
      itemSelectedMethod: '&',
      inputChangeMethod: '&',
    },
    template: templateString,
    controller: ['$scope', function($scope) {
      this.getSelectedItem = function() {
        return $scope.selectedItem;
      };
      this.isRequired = function() {
        return $scope.inputRequired;
      };
      this.customInputAllowed = function() {
        return $scope.allowCustomInput;
      };
      this.tabSelects = function() {
        return $scope.tabSelects;
      };
      this.getInputValidity = function(inputValue) {
        var selection = this.getSelectedItem();
        var isValid = false;

        if (!this.isRequired()) {
          // Input isn't required, so it's always valid
          isValid = true;
        }
        else if (this.customInputAllowed() && inputValue) {
          // Custom input is allowed so we just need to make sure the input field isn't empty
          isValid = true;
        }
        else if (selection) {
          // Input is required and custom input is not allowed, so only validate if an item is selected
          isValid = true;
        }

        return isValid;
      };
    }],
    link: function(scope, element, attrs) {
      var pressedDropdown = false;
      var inputScope = element.find('input').isolateScope();

      scope.activeItemIndex = 0;
      scope.dropdownVisible = false;
      scope.dropdownItems = scope.defaultDropdownItems || [];

      if (attrs.inputValueType)
        scope.inputValueType = attrs.inputValueType;
      else
        scope.inputValueType = 'text';

      scope.$watch('dropdownItems', function(newValue, oldValue) {
        if (!angular.equals(newValue, oldValue)) {
          // If new dropdownItems were retrieved, reset active item
          if (scope.allowCustomInput) {
            scope.setInputActive();
          }
          else {
            scope.setActive(0);
          }
        }
      });

      scope.$watch('selectedItem', function(newValue, oldValue) {
        if (!angular.equals(newValue, oldValue)) {
          if (newValue) {
            // Update value in input field to match readableName of selected item
            if (typeof newValue === 'string') {
              scope.inputValue = newValue;
            }
            else {
              scope.inputValue = newValue.readableName;
            }
          }
          else {
            // Uncomment to clear input field when editing it after making a selection
            // scope.inputValue = '';
          }
        }
      });

      scope.setInputActive = function() {
        scope.setActive(-1);

        //TODO: Add active/selected class to input field for styling
      };

      scope.setActive = function(itemIndex, event) {
        scope.activeItemIndex = itemIndex;
        if (!event) {
          if (itemIndex != -1) {
            var ulel = element.find('ul')[0];
            var liel = (ulel) ? $(ulel).find('li')[0] : null;
            if (ulel && (ulel.scrollTop > 0 || itemIndex > 3))
              ulel.scrollTop = (liel && $(liel).css('height')) ? (itemIndex-3)*$(liel).css('height') : (itemIndex-3)*25;
          }
        }
        else {
          event.preventDefault();
          console.log('ignoring scroll');
        }
      };

      scope.inputChange = function() {
        scope.selectedItem = null;
        showDropdown();
        if (scope.inputChangeMethod) {
          input = element.find('input');
          if (input)
            scope.inputChangeMethod({input: input.val()});
        }

        if (!scope.inputValue) {
          scope.dropdownItems = scope.defaultDropdownItems || [];
          return;
        }

        if (scope.filterListMethod) {
          var promise = scope.filterListMethod({userInput: scope.inputValue});
          if (promise) {
            promise.then(function(dropdownItems) {
              scope.dropdownItems = dropdownItems;
            });
          }
        }
      };

      scope.inputFocus = function(event) {
        if (!event) return;
        if (scope.allowCustomInput) {
          scope.setInputActive();
        }
        else {
          scope.setActive(0);
        }
        showDropdown();
      };

      scope.inputBlur = function(event) {
        if (pressedDropdown) {
          // Blur event is triggered before click event, which means a click on a dropdown item wont be triggered if we hide the dropdown list here.
          pressedDropdown = false;
          return;
        }
        hideDropdown();
      };

      scope.selectItem = function(item) {
        scope.selectedItem = item;
        hideDropdown();
        //scope.dropdownItems = [item];

        if (scope.itemSelectedMethod) {
          scope.itemSelectedMethod({item: item});
        }
      };

      var showDropdown = function () {
        scope.dropdownVisible = true;
      };
      var hideDropdown = function() {
        scope.dropdownVisible = false;
      };

      var selectPreviousItem = function() {
        var prevIndex = scope.activeItemIndex - 1;
        if (prevIndex >= 0) {
          scope.setActive(prevIndex);
        }
        else if (scope.allowCustomInput) {
          scope.setInputActive();
        }
      };

      var selectNextItem = function() {
        var nextIndex = scope.activeItemIndex + 1;
        if (nextIndex < scope.dropdownItems.length) {
          scope.setActive(nextIndex);
        }
      };

      var selectActiveItem = function()  {
        if (scope.activeItemIndex >= 0 && scope.activeItemIndex < scope.dropdownItems.length) {
          scope.selectItem(scope.dropdownItems[scope.activeItemIndex]);
        }
        else if (scope.allowCustomInput && scope.activeItemIndex === -1) {
          //TODO: Select user input. Do we need to call the controller here (ie scope.itemSelectedMethod()) or is it enough to just leave the input value in the field?
        }
      };

      element.bind("keydown keypress", function (event) {
        switch (event.which) {
          case 38: //up
            scope.$apply(selectPreviousItem);
            break;
          case 40: //down
            scope.$apply(selectNextItem);
            break;
          case 13: // return
            if (scope.dropdownVisible && scope.dropdownItems && scope.dropdownItems.length > 0 && scope.activeItemIndex !== -1) {
              // only preventDefault when there is a list so that we can submit form with return key after a selection is made
              event.preventDefault();
              scope.$apply(selectActiveItem);
            }
            break;
          case 9: // tab
            if (scope.dropdownVisible && scope.dropdownItems && scope.dropdownItems.length > 0 && scope.activeItemIndex !== -1 && scope.tabSelects) {
              scope.$apply(selectActiveItem);
            }
            break;
        }
      });

      if (scope.selectedItem && (typeof scope.selectedItem === 'string' || typeof scope.selectedItem === 'number')) {
        scope.inputValue = scope.selectedItem;
        if (scope.itemSelectedMethod) {
          scope.itemSelectedMethod({item: scope.selectedItem});
        }
      }

    }
  }
}]);

angular.module('inputDropdown').directive('inputDropdownValidator', function() {
  return {
    require: ['^inputDropdown', 'ngModel'],
    restrict: 'A',
    scope: {},
    link: function(scope, element, attrs, ctrls) {
      var inputDropdownCtrl = ctrls[0];
      var ngModelCtrl = ctrls[1];

      ngModelCtrl.$validators.itemSelectedValid = function (modelValue) {
        return inputDropdownCtrl.getInputValidity(modelValue);
      };
    }
  };
});

/*! lazysizes - v5.2.2 */

!function(e){var t=function(u,D,f){"use strict";var k,H;if(function(){var e;var t={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:true,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:true,ricTimeout:0,throttleDelay:125};H=u.lazySizesConfig||u.lazysizesConfig||{};for(e in t){if(!(e in H)){H[e]=t[e]}}}(),!D||!D.getElementsByClassName){return{init:function(){},cfg:H,noSupport:true}}var O=D.documentElement,a=u.HTMLPictureElement,P="addEventListener",$="getAttribute",q=u[P].bind(u),I=u.setTimeout,U=u.requestAnimationFrame||I,l=u.requestIdleCallback,j=/^picture$/i,r=["load","error","lazyincluded","_lazyloaded"],i={},G=Array.prototype.forEach,J=function(e,t){if(!i[t]){i[t]=new RegExp("(\\s|^)"+t+"(\\s|$)")}return i[t].test(e[$]("class")||"")&&i[t]},K=function(e,t){if(!J(e,t)){e.setAttribute("class",(e[$]("class")||"").trim()+" "+t)}},Q=function(e,t){var i;if(i=J(e,t)){e.setAttribute("class",(e[$]("class")||"").replace(i," "))}},V=function(t,i,e){var a=e?P:"removeEventListener";if(e){V(t,i)}r.forEach(function(e){t[a](e,i)})},X=function(e,t,i,a,r){var n=D.createEvent("Event");if(!i){i={}}i.instance=k;n.initEvent(t,!a,!r);n.detail=i;e.dispatchEvent(n);return n},Y=function(e,t){var i;if(!a&&(i=u.picturefill||H.pf)){if(t&&t.src&&!e[$]("srcset")){e.setAttribute("srcset",t.src)}i({reevaluate:true,elements:[e]})}else if(t&&t.src){e.src=t.src}},Z=function(e,t){return(getComputedStyle(e,null)||{})[t]},s=function(e,t,i){i=i||e.offsetWidth;while(i<H.minSize&&t&&!e._lazysizesWidth){i=t.offsetWidth;t=t.parentNode}return i},ee=function(){var i,a;var t=[];var r=[];var n=t;var s=function(){var e=n;n=t.length?r:t;i=true;a=false;while(e.length){e.shift()()}i=false};var e=function(e,t){if(i&&!t){e.apply(this,arguments)}else{n.push(e);if(!a){a=true;(D.hidden?I:U)(s)}}};e._lsFlush=s;return e}(),te=function(i,e){return e?function(){ee(i)}:function(){var e=this;var t=arguments;ee(function(){i.apply(e,t)})}},ie=function(e){var i;var a=0;var r=H.throttleDelay;var n=H.ricTimeout;var t=function(){i=false;a=f.now();e()};var s=l&&n>49?function(){l(t,{timeout:n});if(n!==H.ricTimeout){n=H.ricTimeout}}:te(function(){I(t)},true);return function(e){var t;if(e=e===true){n=33}if(i){return}i=true;t=r-(f.now()-a);if(t<0){t=0}if(e||t<9){s()}else{I(s,t)}}},ae=function(e){var t,i;var a=99;var r=function(){t=null;e()};var n=function(){var e=f.now()-i;if(e<a){I(n,a-e)}else{(l||r)(r)}};return function(){i=f.now();if(!t){t=I(n,a)}}},e=function(){var v,m,c,h,e;var y,z,g,p,C,b,A;var n=/^img$/i;var d=/^iframe$/i;var E="onscroll"in u&&!/(gle|ing)bot/.test(navigator.userAgent);var _=0;var w=0;var N=0;var M=-1;var x=function(e){N--;if(!e||N<0||!e.target){N=0}};var W=function(e){if(A==null){A=Z(D.body,"visibility")=="hidden"}return A||!(Z(e.parentNode,"visibility")=="hidden"&&Z(e,"visibility")=="hidden")};var S=function(e,t){var i;var a=e;var r=W(e);g-=t;b+=t;p-=t;C+=t;while(r&&(a=a.offsetParent)&&a!=D.body&&a!=O){r=(Z(a,"opacity")||1)>0;if(r&&Z(a,"overflow")!="visible"){i=a.getBoundingClientRect();r=C>i.left&&p<i.right&&b>i.top-1&&g<i.bottom+1}}return r};var t=function(){var e,t,i,a,r,n,s,l,o,u,f,c;var d=k.elements;if((h=H.loadMode)&&N<8&&(e=d.length)){t=0;M++;for(;t<e;t++){if(!d[t]||d[t]._lazyRace){continue}if(!E||k.prematureUnveil&&k.prematureUnveil(d[t])){R(d[t]);continue}if(!(l=d[t][$]("data-expand"))||!(n=l*1)){n=w}if(!u){u=!H.expand||H.expand<1?O.clientHeight>500&&O.clientWidth>500?500:370:H.expand;k._defEx=u;f=u*H.expFactor;c=H.hFac;A=null;if(w<f&&N<1&&M>2&&h>2&&!D.hidden){w=f;M=0}else if(h>1&&M>1&&N<6){w=u}else{w=_}}if(o!==n){y=innerWidth+n*c;z=innerHeight+n;s=n*-1;o=n}i=d[t].getBoundingClientRect();if((b=i.bottom)>=s&&(g=i.top)<=z&&(C=i.right)>=s*c&&(p=i.left)<=y&&(b||C||p||g)&&(H.loadHidden||W(d[t]))&&(m&&N<3&&!l&&(h<3||M<4)||S(d[t],n))){R(d[t]);r=true;if(N>9){break}}else if(!r&&m&&!a&&N<4&&M<4&&h>2&&(v[0]||H.preloadAfterLoad)&&(v[0]||!l&&(b||C||p||g||d[t][$](H.sizesAttr)!="auto"))){a=v[0]||d[t]}}if(a&&!r){R(a)}}};var i=ie(t);var B=function(e){var t=e.target;if(t._lazyCache){delete t._lazyCache;return}x(e);K(t,H.loadedClass);Q(t,H.loadingClass);V(t,L);X(t,"lazyloaded")};var a=te(B);var L=function(e){a({target:e.target})};var T=function(t,i){try{t.contentWindow.location.replace(i)}catch(e){t.src=i}};var F=function(e){var t;var i=e[$](H.srcsetAttr);if(t=H.customMedia[e[$]("data-media")||e[$]("media")]){e.setAttribute("media",t)}if(i){e.setAttribute("srcset",i)}};var s=te(function(t,e,i,a,r){var n,s,l,o,u,f;if(!(u=X(t,"lazybeforeunveil",e)).defaultPrevented){if(a){if(i){K(t,H.autosizesClass)}else{t.setAttribute("sizes",a)}}s=t[$](H.srcsetAttr);n=t[$](H.srcAttr);if(r){l=t.parentNode;o=l&&j.test(l.nodeName||"")}f=e.firesLoad||"src"in t&&(s||n||o);u={target:t};K(t,H.loadingClass);if(f){clearTimeout(c);c=I(x,2500);V(t,L,true)}if(o){G.call(l.getElementsByTagName("source"),F)}if(s){t.setAttribute("srcset",s)}else if(n&&!o){if(d.test(t.nodeName)){T(t,n)}else{t.src=n}}if(r&&(s||o)){Y(t,{src:n})}}if(t._lazyRace){delete t._lazyRace}Q(t,H.lazyClass);ee(function(){var e=t.complete&&t.naturalWidth>1;if(!f||e){if(e){K(t,"ls-is-cached")}B(u);t._lazyCache=true;I(function(){if("_lazyCache"in t){delete t._lazyCache}},9)}if(t.loading=="lazy"){N--}},true)});var R=function(e){if(e._lazyRace){return}var t;var i=n.test(e.nodeName);var a=i&&(e[$](H.sizesAttr)||e[$]("sizes"));var r=a=="auto";if((r||!m)&&i&&(e[$]("src")||e.srcset)&&!e.complete&&!J(e,H.errorClass)&&J(e,H.lazyClass)){return}t=X(e,"lazyunveilread").detail;if(r){re.updateElem(e,true,e.offsetWidth)}e._lazyRace=true;N++;s(e,t,r,a,i)};var r=ae(function(){H.loadMode=3;i()});var l=function(){if(H.loadMode==3){H.loadMode=2}r()};var o=function(){if(m){return}if(f.now()-e<999){I(o,999);return}m=true;H.loadMode=3;i();q("scroll",l,true)};return{_:function(){e=f.now();k.elements=D.getElementsByClassName(H.lazyClass);v=D.getElementsByClassName(H.lazyClass+" "+H.preloadClass);q("scroll",i,true);q("resize",i,true);q("pageshow",function(e){if(e.persisted){var t=D.querySelectorAll("."+H.loadingClass);if(t.length&&t.forEach){U(function(){t.forEach(function(e){if(e.complete){R(e)}})})}}});if(u.MutationObserver){new MutationObserver(i).observe(O,{childList:true,subtree:true,attributes:true})}else{O[P]("DOMNodeInserted",i,true);O[P]("DOMAttrModified",i,true);setInterval(i,999)}q("hashchange",i,true);["focus","mouseover","click","load","transitionend","animationend"].forEach(function(e){D[P](e,i,true)});if(/d$|^c/.test(D.readyState)){o()}else{q("load",o);D[P]("DOMContentLoaded",i);I(o,2e4)}if(k.elements.length){t();ee._lsFlush()}else{i()}},checkElems:i,unveil:R,_aLSL:l}}(),re=function(){var i;var n=te(function(e,t,i,a){var r,n,s;e._lazysizesWidth=a;a+="px";e.setAttribute("sizes",a);if(j.test(t.nodeName||"")){r=t.getElementsByTagName("source");for(n=0,s=r.length;n<s;n++){r[n].setAttribute("sizes",a)}}if(!i.detail.dataAttr){Y(e,i.detail)}});var a=function(e,t,i){var a;var r=e.parentNode;if(r){i=s(e,r,i);a=X(e,"lazybeforesizes",{width:i,dataAttr:!!t});if(!a.defaultPrevented){i=a.detail.width;if(i&&i!==e._lazysizesWidth){n(e,r,a,i)}}}};var e=function(){var e;var t=i.length;if(t){e=0;for(;e<t;e++){a(i[e])}}};var t=ae(e);return{_:function(){i=D.getElementsByClassName(H.autosizesClass);q("resize",t)},checkElems:t,updateElem:a}}(),t=function(){if(!t.i&&D.getElementsByClassName){t.i=true;re._();e._()}};return I(function(){H.init&&t()}),k={cfg:H,autoSizer:re,loader:e,init:t,uP:Y,aC:K,rC:Q,hC:J,fire:X,gW:s,rAF:ee}}(e,e.document,Date);e.lazySizes=t,"object"==typeof module&&module.exports&&(module.exports=t)}("undefined"!=typeof window?window:{});
/*! lazysizes - v5.2.2 */

!function(e,t){var a=function(){t(e.lazySizes),e.removeEventListener("lazyunveilread",a,!0)};t=t.bind(null,e,e.document),"object"==typeof module&&module.exports?t(require("lazysizes")):"function"==typeof define&&define.amd?define(["lazysizes"],t):e.lazySizes?a():e.addEventListener("lazyunveilread",a,!0)}(window,function(e,i,o){"use strict";var l,d,u={};function s(e,t,a){var n,r;u[e]||(n=i.createElement(t?"link":"script"),r=i.getElementsByTagName("script")[0],t?(n.rel="stylesheet",n.href=e):(n.onload=function(){n.onerror=null,n.onload=null,a()},n.onerror=n.onload,n.src=e),u[e]=!0,u[n.src||n.href]=!0,r.parentNode.insertBefore(n,r))}i.addEventListener&&(l=function(e,t){var a=i.createElement("img");a.onload=function(){a.onload=null,a.onerror=null,a=null,t()},a.onerror=a.onload,a.src=e,a&&a.complete&&a.onload&&a.onload()},addEventListener("lazybeforeunveil",function(e){var t,a,n;if(e.detail.instance==o&&!e.defaultPrevented){var r=e.target;if("none"==r.preload&&(r.preload=r.getAttribute("data-preload")||"auto"),null!=r.getAttribute("data-autoplay"))if(r.getAttribute("data-expand")&&!r.autoplay)try{r.play()}catch(e){}else requestAnimationFrame(function(){r.setAttribute("data-expand","-10"),o.aC(r,o.cfg.lazyClass)});(t=r.getAttribute("data-link"))&&s(t,!0),(t=r.getAttribute("data-script"))&&(e.detail.firesLoad=!0,s(t,null,function(){e.detail.firesLoad=!1,o.fire(r,"_lazyloaded",{},!0,!0)})),(t=r.getAttribute("data-require"))&&(o.cfg.requireJs?o.cfg.requireJs([t]):s(t)),(a=r.getAttribute("data-bg"))&&(e.detail.firesLoad=!0,l(a,function(){r.style.backgroundImage="url("+(d.test(a)?JSON.stringify(a):a)+")",e.detail.firesLoad=!1,o.fire(r,"_lazyloaded",{},!0,!0)})),(n=r.getAttribute("data-poster"))&&(e.detail.firesLoad=!0,l(n,function(){r.poster=n,e.detail.firesLoad=!1,o.fire(r,"_lazyloaded",{},!0,!0)}))}},!(d=/\(|\)|\s|'/)))});

/*! 12.2.13 */
!function(){function a(a,b){window.XMLHttpRequest.prototype[a]=b(window.XMLHttpRequest.prototype[a])}function b(a,b,c){try{Object.defineProperty(a,b,{get:c})}catch(d){}}if(window.FileAPI||(window.FileAPI={}),!window.XMLHttpRequest)throw"AJAX is not supported. XMLHttpRequest is not defined.";if(FileAPI.shouldLoad=!window.FormData||FileAPI.forceLoad,FileAPI.shouldLoad){var c=function(a){if(!a.__listeners){a.upload||(a.upload={}),a.__listeners=[];var b=a.upload.addEventListener;a.upload.addEventListener=function(c,d){a.__listeners[c]=d,b&&b.apply(this,arguments)}}};a("open",function(a){return function(b,d,e){c(this),this.__url=d;try{a.apply(this,[b,d,e])}catch(f){f.message.indexOf("Access is denied")>-1&&(this.__origError=f,a.apply(this,[b,"_fix_for_ie_crossdomain__",e]))}}}),a("getResponseHeader",function(a){return function(b){return this.__fileApiXHR&&this.__fileApiXHR.getResponseHeader?this.__fileApiXHR.getResponseHeader(b):null==a?null:a.apply(this,[b])}}),a("getAllResponseHeaders",function(a){return function(){return this.__fileApiXHR&&this.__fileApiXHR.getAllResponseHeaders?this.__fileApiXHR.getAllResponseHeaders():null==a?null:a.apply(this)}}),a("abort",function(a){return function(){return this.__fileApiXHR&&this.__fileApiXHR.abort?this.__fileApiXHR.abort():null==a?null:a.apply(this)}}),a("setRequestHeader",function(a){return function(b,d){if("__setXHR_"===b){c(this);var e=d(this);e instanceof Function&&e(this)}else this.__requestHeaders=this.__requestHeaders||{},this.__requestHeaders[b]=d,a.apply(this,arguments)}}),a("send",function(a){return function(){var c=this;if(arguments[0]&&arguments[0].__isFileAPIShim){var d=arguments[0],e={url:c.__url,jsonp:!1,cache:!0,complete:function(a,d){a&&angular.isString(a)&&-1!==a.indexOf("#2174")&&(a=null),c.__completed=!0,!a&&c.__listeners.load&&c.__listeners.load({type:"load",loaded:c.__loaded,total:c.__total,target:c,lengthComputable:!0}),!a&&c.__listeners.loadend&&c.__listeners.loadend({type:"loadend",loaded:c.__loaded,total:c.__total,target:c,lengthComputable:!0}),"abort"===a&&c.__listeners.abort&&c.__listeners.abort({type:"abort",loaded:c.__loaded,total:c.__total,target:c,lengthComputable:!0}),void 0!==d.status&&b(c,"status",function(){return 0===d.status&&a&&"abort"!==a?500:d.status}),void 0!==d.statusText&&b(c,"statusText",function(){return d.statusText}),b(c,"readyState",function(){return 4}),void 0!==d.response&&b(c,"response",function(){return d.response});var e=d.responseText||(a&&0===d.status&&"abort"!==a?a:void 0);b(c,"responseText",function(){return e}),b(c,"response",function(){return e}),a&&b(c,"err",function(){return a}),c.__fileApiXHR=d,c.onreadystatechange&&c.onreadystatechange(),c.onload&&c.onload()},progress:function(a){if(a.target=c,c.__listeners.progress&&c.__listeners.progress(a),c.__total=a.total,c.__loaded=a.loaded,a.total===a.loaded){var b=this;setTimeout(function(){c.__completed||(c.getAllResponseHeaders=function(){},b.complete(null,{status:204,statusText:"No Content"}))},FileAPI.noContentTimeout||1e4)}},headers:c.__requestHeaders};e.data={},e.files={};for(var f=0;f<d.data.length;f++){var g=d.data[f];null!=g.val&&null!=g.val.name&&null!=g.val.size&&null!=g.val.type?e.files[g.key]=g.val:e.data[g.key]=g.val}setTimeout(function(){if(!FileAPI.hasFlash)throw'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';c.__fileApiXHR=FileAPI.upload(e)},1)}else{if(this.__origError)throw this.__origError;a.apply(c,arguments)}}}),window.XMLHttpRequest.__isFileAPIShim=!0,window.FormData=FormData=function(){return{append:function(a,b,c){b.__isFileAPIBlobShim&&(b=b.data[0]),this.data.push({key:a,val:b,name:c})},data:[],__isFileAPIShim:!0}},window.Blob=Blob=function(a){return{data:a,__isFileAPIBlobShim:!0}}}}(),function(){function a(a){return"input"===a[0].tagName.toLowerCase()&&a.attr("type")&&"file"===a.attr("type").toLowerCase()}function b(){try{var a=new ActiveXObject("ShockwaveFlash.ShockwaveFlash");if(a)return!0}catch(b){if(void 0!==navigator.mimeTypes["application/x-shockwave-flash"])return!0}return!1}function c(a){var b=0,c=0;if(window.jQuery)return jQuery(a).offset();if(a.offsetParent)do b+=a.offsetLeft-a.scrollLeft,c+=a.offsetTop-a.scrollTop,a=a.offsetParent;while(a);return{left:b,top:c}}if(FileAPI.shouldLoad){if(FileAPI.hasFlash=b(),FileAPI.forceLoad&&(FileAPI.html5=!1),!FileAPI.upload){var d,e,f,g,h,i=document.createElement("script"),j=document.getElementsByTagName("script");if(window.FileAPI.jsUrl)d=window.FileAPI.jsUrl;else if(window.FileAPI.jsPath)e=window.FileAPI.jsPath;else for(f=0;f<j.length;f++)if(h=j[f].src,g=h.search(/\/ng\-file\-upload[\-a-zA-z0-9\.]*\.js/),g>-1){e=h.substring(0,g+1);break}null==FileAPI.staticPath&&(FileAPI.staticPath=e),i.setAttribute("src",d||e+"FileAPI.min.js"),document.getElementsByTagName("head")[0].appendChild(i)}FileAPI.ngfFixIE=function(d,e,f){if(!b())throw'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';var g=function(){var b=e.parent();d.attr("disabled")?b&&b.removeClass("js-fileapi-wrapper"):(e.attr("__ngf_flash_")||(e.unbind("change"),e.unbind("click"),e.bind("change",function(a){h.apply(this,[a]),f.apply(this,[a])}),e.attr("__ngf_flash_","true")),b.addClass("js-fileapi-wrapper"),a(d)||(b.css("position","absolute").css("top",c(d[0]).top+"px").css("left",c(d[0]).left+"px").css("width",d[0].offsetWidth+"px").css("height",d[0].offsetHeight+"px").css("filter","alpha(opacity=0)").css("display",d.css("display")).css("overflow","hidden").css("z-index","900000").css("visibility","visible"),e.css("width",d[0].offsetWidth+"px").css("height",d[0].offsetHeight+"px").css("position","absolute").css("top","0px").css("left","0px")))};d.bind("mouseenter",g);var h=function(a){for(var b=FileAPI.getFiles(a),c=0;c<b.length;c++)void 0===b[c].size&&(b[c].size=0),void 0===b[c].name&&(b[c].name="file"),void 0===b[c].type&&(b[c].type="undefined");a.target||(a.target={}),a.target.files=b,a.target.files!==b&&(a.__files_=b),(a.__files_||a.target.files).item=function(b){return(a.__files_||a.target.files)[b]||null}}},FileAPI.disableFileInput=function(a,b){b?a.removeClass("js-fileapi-wrapper"):a.addClass("js-fileapi-wrapper")}}}(),window.FileReader||(window.FileReader=function(){var a=this,b=!1;this.listeners={},this.addEventListener=function(b,c){a.listeners[b]=a.listeners[b]||[],a.listeners[b].push(c)},this.removeEventListener=function(b,c){a.listeners[b]&&a.listeners[b].splice(a.listeners[b].indexOf(c),1)},this.dispatchEvent=function(b){var c=a.listeners[b.type];if(c)for(var d=0;d<c.length;d++)c[d].call(a,b)},this.onabort=this.onerror=this.onload=this.onloadstart=this.onloadend=this.onprogress=null;var c=function(b,c){var d={type:b,target:a,loaded:c.loaded,total:c.total,error:c.error};return null!=c.result&&(d.target.result=c.result),d},d=function(d){b||(b=!0,a.onloadstart&&a.onloadstart(c("loadstart",d)));var e;"load"===d.type?(a.onloadend&&a.onloadend(c("loadend",d)),e=c("load",d),a.onload&&a.onload(e),a.dispatchEvent(e)):"progress"===d.type?(e=c("progress",d),a.onprogress&&a.onprogress(e),a.dispatchEvent(e)):(e=c("error",d),a.onerror&&a.onerror(e),a.dispatchEvent(e))};this.readAsDataURL=function(a){FileAPI.readAsDataURL(a,d)},this.readAsText=function(a){FileAPI.readAsText(a,d)}});
/*! 12.2.13 */
!window.XMLHttpRequest||window.FileAPI&&FileAPI.shouldLoad||(window.XMLHttpRequest.prototype.setRequestHeader=function(a){return function(b,c){if("__setXHR_"===b){var d=c(this);d instanceof Function&&d(this)}else a.apply(this,arguments)}}(window.XMLHttpRequest.prototype.setRequestHeader));var ngFileUpload=angular.module("ngFileUpload",[]);ngFileUpload.version="12.2.13",ngFileUpload.service("UploadBase",["$http","$q","$timeout",function(a,b,c){function d(d){function e(a){j.notify&&j.notify(a),k.progressFunc&&c(function(){k.progressFunc(a)})}function h(a){return null!=d._start&&g?{loaded:a.loaded+d._start,total:d._file&&d._file.size||a.total,type:a.type,config:d,lengthComputable:!0,target:a.target}:a}function i(){a(d).then(function(a){if(g&&d._chunkSize&&!d._finished&&d._file){var b=d._file&&d._file.size||0;e({loaded:Math.min(d._end,b),total:b,config:d,type:"progress"}),f.upload(d,!0)}else d._finished&&delete d._finished,j.resolve(a)},function(a){j.reject(a)},function(a){j.notify(a)})}d.method=d.method||"POST",d.headers=d.headers||{};var j=d._deferred=d._deferred||b.defer(),k=j.promise;return d.disableProgress||(d.headers.__setXHR_=function(){return function(a){a&&a.upload&&a.upload.addEventListener&&(d.__XHR=a,d.xhrFn&&d.xhrFn(a),a.upload.addEventListener("progress",function(a){a.config=d,e(h(a))},!1),a.upload.addEventListener("load",function(a){a.lengthComputable&&(a.config=d,e(h(a)))},!1))}}),g?d._chunkSize&&d._end&&!d._finished?(d._start=d._end,d._end+=d._chunkSize,i()):d.resumeSizeUrl?a.get(d.resumeSizeUrl).then(function(a){d._start=d.resumeSizeResponseReader?d.resumeSizeResponseReader(a.data):parseInt((null==a.data.size?a.data:a.data.size).toString()),d._chunkSize&&(d._end=d._start+d._chunkSize),i()},function(a){throw a}):d.resumeSize?d.resumeSize().then(function(a){d._start=a,d._chunkSize&&(d._end=d._start+d._chunkSize),i()},function(a){throw a}):(d._chunkSize&&(d._start=0,d._end=d._start+d._chunkSize),i()):i(),k.success=function(a){return k.then(function(b){a(b.data,b.status,b.headers,d)}),k},k.error=function(a){return k.then(null,function(b){a(b.data,b.status,b.headers,d)}),k},k.progress=function(a){return k.progressFunc=a,k.then(null,null,function(b){a(b)}),k},k.abort=k.pause=function(){return d.__XHR&&c(function(){d.__XHR.abort()}),k},k.xhr=function(a){return d.xhrFn=function(b){return function(){b&&b.apply(k,arguments),a.apply(k,arguments)}}(d.xhrFn),k},f.promisesCount++,k["finally"]&&k["finally"]instanceof Function&&k["finally"](function(){f.promisesCount--}),k}function e(a){var b={};for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}var f=this;f.promisesCount=0,this.isResumeSupported=function(){return window.Blob&&window.Blob.prototype.slice};var g=this.isResumeSupported();this.isUploadInProgress=function(){return f.promisesCount>0},this.rename=function(a,b){return a.ngfName=b,a},this.jsonBlob=function(a){null==a||angular.isString(a)||(a=JSON.stringify(a));var b=new window.Blob([a],{type:"application/json"});return b._ngfBlob=!0,b},this.json=function(a){return angular.toJson(a)},this.isFile=function(a){return null!=a&&(a instanceof window.Blob||a.flashId&&a.name&&a.size)},this.upload=function(a,b){function c(b,c){if(b._ngfBlob)return b;if(a._file=a._file||b,null!=a._start&&g){a._end&&a._end>=b.size&&(a._finished=!0,a._end=b.size);var d=b.slice(a._start,a._end||b.size);return d.name=b.name,d.ngfName=b.ngfName,a._chunkSize&&(c.append("_chunkSize",a._chunkSize),c.append("_currentChunkSize",a._end-a._start),c.append("_chunkNumber",Math.floor(a._start/a._chunkSize)),c.append("_totalSize",a._file.size)),d}return b}function h(b,d,e){if(void 0!==d)if(angular.isDate(d)&&(d=d.toISOString()),angular.isString(d))b.append(e,d);else if(f.isFile(d)){var g=c(d,b),i=e.split(",");i[1]&&(g.ngfName=i[1].replace(/^\s+|\s+$/g,""),e=i[0]),a._fileKey=a._fileKey||e,b.append(e,g,g.ngfName||g.name)}else if(angular.isObject(d)){if(d.$$ngfCircularDetection)throw"ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: "+e;d.$$ngfCircularDetection=!0;try{for(var j in d)if(d.hasOwnProperty(j)&&"$$ngfCircularDetection"!==j){var k=null==a.objectKey?"[i]":a.objectKey;d.length&&parseInt(j)>-1&&(k=null==a.arrayKey?k:a.arrayKey),h(b,d[j],e+k.replace(/[ik]/g,j))}}finally{delete d.$$ngfCircularDetection}}else b.append(e,d)}function i(){a._chunkSize=f.translateScalars(a.resumeChunkSize),a._chunkSize=a._chunkSize?parseInt(a._chunkSize.toString()):null,a.headers=a.headers||{},a.headers["Content-Type"]=void 0,a.transformRequest=a.transformRequest?angular.isArray(a.transformRequest)?a.transformRequest:[a.transformRequest]:[],a.transformRequest.push(function(b){var c,d=new window.FormData;b=b||a.fields||{},a.file&&(b.file=a.file);for(c in b)if(b.hasOwnProperty(c)){var e=b[c];a.formDataAppender?a.formDataAppender(d,c,e):h(d,e,c)}return d})}return b||(a=e(a)),a._isDigested||(a._isDigested=!0,i()),d(a)},this.http=function(b){return b=e(b),b.transformRequest=b.transformRequest||function(b){return window.ArrayBuffer&&b instanceof window.ArrayBuffer||b instanceof window.Blob?b:a.defaults.transformRequest[0].apply(this,arguments)},b._chunkSize=f.translateScalars(b.resumeChunkSize),b._chunkSize=b._chunkSize?parseInt(b._chunkSize.toString()):null,d(b)},this.translateScalars=function(a){if(angular.isString(a)){if(a.search(/kb/i)===a.length-2)return parseFloat(1024*a.substring(0,a.length-2));if(a.search(/mb/i)===a.length-2)return parseFloat(1048576*a.substring(0,a.length-2));if(a.search(/gb/i)===a.length-2)return parseFloat(1073741824*a.substring(0,a.length-2));if(a.search(/b/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/s/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/m/i)===a.length-1)return parseFloat(60*a.substring(0,a.length-1));if(a.search(/h/i)===a.length-1)return parseFloat(3600*a.substring(0,a.length-1))}return a},this.urlToBlob=function(c){var d=b.defer();return a({url:c,method:"get",responseType:"arraybuffer"}).then(function(a){var b=new Uint8Array(a.data),e=a.headers("content-type")||"image/WebP",f=new window.Blob([b],{type:e}),g=c.match(/.*\/(.+?)(\?.*)?$/);g.length>1&&(f.name=g[1]),d.resolve(f)},function(a){d.reject(a)}),d.promise},this.setDefaults=function(a){this.defaults=a||{}},this.defaults={},this.version=ngFileUpload.version}]),ngFileUpload.service("Upload",["$parse","$timeout","$compile","$q","UploadExif",function(a,b,c,d,e){function f(a,b,c){var e=[i.emptyPromise()];return angular.forEach(a,function(d,f){0===d.type.indexOf("image/jpeg")&&i.attrGetter("ngfFixOrientation",b,c,{$file:d})&&e.push(i.happyPromise(i.applyExifRotation(d),d).then(function(b){a.splice(f,1,b)}))}),d.all(e)}function g(a,b,c,e){var f=i.attrGetter("ngfResize",b,c);if(!f||!i.isResizeSupported()||!a.length)return i.emptyPromise();if(f instanceof Function){var g=d.defer();return f(a).then(function(d){h(d,a,b,c,e).then(function(a){g.resolve(a)},function(a){g.reject(a)})},function(a){g.reject(a)})}return h(f,a,b,c,e)}function h(a,b,c,e,f){function g(d,g){if(0===d.type.indexOf("image")){if(a.pattern&&!i.validatePattern(d,a.pattern))return;a.resizeIf=function(a,b){return i.attrGetter("ngfResizeIf",c,e,{$width:a,$height:b,$file:d})};var j=i.resize(d,a);h.push(j),j.then(function(a){b.splice(g,1,a)},function(a){d.$error="resize",(d.$errorMessages=d.$errorMessages||{}).resize=!0,d.$errorParam=(a?(a.message?a.message:a)+": ":"")+(d&&d.name),f.$ngfValidations.push({name:"resize",valid:!1}),i.applyModelValidation(f,b)})}}for(var h=[i.emptyPromise()],j=0;j<b.length;j++)g(b[j],j);return d.all(h)}var i=e;return i.getAttrWithDefaults=function(a,b){if(null!=a[b])return a[b];var c=i.defaults[b];return null==c?c:angular.isString(c)?c:JSON.stringify(c)},i.attrGetter=function(b,c,d,e){var f=this.getAttrWithDefaults(c,b);if(!d)return f;try{return e?a(f)(d,e):a(f)(d)}catch(g){if(b.search(/min|max|pattern/i))return f;throw g}},i.shouldUpdateOn=function(a,b,c){var d=i.attrGetter("ngfModelOptions",b,c);return d&&d.updateOn?d.updateOn.split(" ").indexOf(a)>-1:!0},i.emptyPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.resolve.apply(a,c)}),a.promise},i.rejectPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.reject.apply(a,c)}),a.promise},i.happyPromise=function(a,c){var e=d.defer();return a.then(function(a){e.resolve(a)},function(a){b(function(){throw a}),e.resolve(c)}),e.promise},i.updateModel=function(c,d,e,h,j,k,l){function m(f,g,j,l,m){d.$$ngfPrevValidFiles=f,d.$$ngfPrevInvalidFiles=g;var n=f&&f.length?f[0]:null,o=g&&g.length?g[0]:null;c&&(i.applyModelValidation(c,f),c.$setViewValue(m?n:f)),h&&a(h)(e,{$files:f,$file:n,$newFiles:j,$duplicateFiles:l,$invalidFiles:g,$invalidFile:o,$event:k});var p=i.attrGetter("ngfModelInvalid",d);p&&b(function(){a(p).assign(e,m?o:g)}),b(function(){})}function n(){function a(a,b){return a.name===b.name&&(a.$ngfOrigSize||a.size)===(b.$ngfOrigSize||b.size)&&a.type===b.type}function b(b){var c;for(c=0;c<r.length;c++)if(a(b,r[c]))return!0;for(c=0;c<s.length;c++)if(a(b,s[c]))return!0;return!1}if(j){q=[],t=[];for(var c=0;c<j.length;c++)b(j[c])?t.push(j[c]):q.push(j[c])}}function o(a){return angular.isArray(a)?a:[a]}function p(){function a(){b(function(){m(w?r.concat(v):v,w?s.concat(u):u,j,t,x)},z&&z.debounce?z.debounce.change||z.debounce:0)}var f=y?q:v;g(f,d,e,c).then(function(){y?i.validate(q,w?r.length:0,c,d,e).then(function(b){v=b.validsFiles,u=b.invalidsFiles,a()}):a()},function(){for(var b=0;b<f.length;b++){var c=f[b];if("resize"===c.$error){var d=v.indexOf(c);d>-1&&(v.splice(d,1),u.push(c)),a()}}})}var q,r,s,t=[],u=[],v=[];r=d.$$ngfPrevValidFiles||[],s=d.$$ngfPrevInvalidFiles||[],c&&c.$modelValue&&(r=o(c.$modelValue));var w=i.attrGetter("ngfKeep",d,e);q=(j||[]).slice(0),("distinct"===w||i.attrGetter("ngfKeepDistinct",d,e)===!0)&&n(d,e);var x=!w&&!i.attrGetter("ngfMultiple",d,e)&&!i.attrGetter("multiple",d);if(!w||q.length){i.attrGetter("ngfBeforeModelChange",d,e,{$files:j,$file:j&&j.length?j[0]:null,$newFiles:q,$duplicateFiles:t,$event:k});var y=i.attrGetter("ngfValidateAfterResize",d,e),z=i.attrGetter("ngfModelOptions",d,e);i.validate(q,w?r.length:0,c,d,e).then(function(a){l?m(q,[],j,t,x):(z&&z.allowInvalid||y?v=q:(v=a.validFiles,u=a.invalidFiles),i.attrGetter("ngfFixOrientation",d,e)&&i.isExifSupported()?f(v,d,e).then(function(){p()}):p())})}},i}]),ngFileUpload.directive("ngfSelect",["$parse","$timeout","$compile","Upload",function(a,b,c,d){function e(a){var b=a.match(/Android[^\d]*(\d+)\.(\d+)/);if(b&&b.length>2){var c=d.defaults.androidFixMinorVersion||4;return parseInt(b[1])<4||parseInt(b[1])===c&&parseInt(b[2])<c}return-1===a.indexOf("Chrome")&&/.*Windows.*Safari.*/.test(a)}function f(a,b,c,d,f,h,i,j){function k(){return"input"===b[0].tagName.toLowerCase()&&c.type&&"file"===c.type.toLowerCase()}function l(){return t("ngfChange")||t("ngfSelect")}function m(b){if(j.shouldUpdateOn("change",c,a)){var e=b.__files_||b.target&&b.target.files,f=[];if(!e)return;for(var g=0;g<e.length;g++)f.push(e[g]);j.updateModel(d,c,a,l(),f.length?f:null,b)}}function n(a,d){function e(b){a.attr("id","ngf-"+b),d.attr("id","ngf-label-"+b)}for(var f=0;f<b[0].attributes.length;f++){var g=b[0].attributes[f];"type"!==g.name&&"class"!==g.name&&"style"!==g.name&&("id"===g.name?(e(g.value),u.push(c.$observe("id",e))):a.attr(g.name,g.value||"required"!==g.name&&"multiple"!==g.name?g.value:g.name))}}function o(){if(k())return b;var a=angular.element('<input type="file">'),c=angular.element("<label>upload</label>");return c.css("visibility","hidden").css("position","absolute").css("overflow","hidden").css("width","0px").css("height","0px").css("border","none").css("margin","0px").css("padding","0px").attr("tabindex","-1"),n(a,c),g.push({el:b,ref:c}),document.body.appendChild(c.append(a)[0]),a}function p(c){if(b.attr("disabled"))return!1;if(!t("ngfSelectDisabled",a)){var d=q(c);if(null!=d)return d;r(c);try{k()||document.body.contains(x[0])||(g.push({el:b,ref:x.parent()}),document.body.appendChild(x.parent()[0]),x.bind("change",m))}catch(f){}return e(navigator.userAgent)?setTimeout(function(){x[0].click()},0):x[0].click(),!1}}function q(a){var b=a.changedTouches||a.originalEvent&&a.originalEvent.changedTouches;if(b){if("touchstart"===a.type)return w=b[0].clientX,v=b[0].clientY,!0;if("touchend"===a.type){var c=b[0].clientX,d=b[0].clientY;if(Math.abs(c-w)>20||Math.abs(d-v)>20)return a.stopPropagation(),a.preventDefault(),!1}return!0}}function r(b){j.shouldUpdateOn("click",c,a)&&x.val()&&(x.val(null),j.updateModel(d,c,a,l(),null,b,!0))}function s(a){if(x&&!x.attr("__ngf_ie10_Fix_")){if(!x[0].parentNode)return void(x=null);a.preventDefault(),a.stopPropagation(),x.unbind("click");var b=x.clone();return x.replaceWith(b),x=b,x.attr("__ngf_ie10_Fix_","true"),x.bind("change",m),x.bind("click",s),x[0].click(),!1}x.removeAttr("__ngf_ie10_Fix_")}var t=function(a,b){return j.attrGetter(a,c,b)};j.registerModelChangeValidator(d,c,a);var u=[];t("ngfMultiple")&&u.push(a.$watch(t("ngfMultiple"),function(){x.attr("multiple",t("ngfMultiple",a))})),t("ngfCapture")&&u.push(a.$watch(t("ngfCapture"),function(){x.attr("capture",t("ngfCapture",a))})),t("ngfAccept")&&u.push(a.$watch(t("ngfAccept"),function(){x.attr("accept",t("ngfAccept",a))})),u.push(c.$observe("accept",function(){x.attr("accept",t("accept"))}));var v=0,w=0,x=b;k()||(x=o()),x.bind("change",m),k()?b.bind("click",r):b.bind("click touchstart touchend",p),-1!==navigator.appVersion.indexOf("MSIE 10")&&x.bind("click",s),d&&d.$formatters.push(function(a){return(null==a||0===a.length)&&x.val()&&x.val(null),a}),a.$on("$destroy",function(){k()||x.parent().remove(),angular.forEach(u,function(a){a()})}),h(function(){for(var a=0;a<g.length;a++){var b=g[a];document.body.contains(b.el[0])||(g.splice(a,1),b.ref.remove())}}),window.FileAPI&&window.FileAPI.ngfFixIE&&window.FileAPI.ngfFixIE(b,x,m)}var g=[];return{restrict:"AEC",require:"?ngModel",link:function(e,g,h,i){f(e,g,h,i,a,b,c,d)}}}]),function(){function a(a){return"img"===a.tagName.toLowerCase()?"image":"audio"===a.tagName.toLowerCase()?"audio":"video"===a.tagName.toLowerCase()?"video":/./}function b(b,c,d,e,f,g,h,i){function j(a){var g=b.attrGetter("ngfNoObjectUrl",f,d);b.dataUrl(a,g)["finally"](function(){c(function(){var b=(g?a.$ngfDataUrl:a.$ngfBlobUrl)||a.$ngfDataUrl;i?e.css("background-image","url('"+(b||"")+"')"):e.attr("src",b),b?e.removeClass("ng-hide"):e.addClass("ng-hide")})})}c(function(){var c=d.$watch(f[g],function(c){var k=h;if("ngfThumbnail"===g&&(k||(k={width:e[0].naturalWidth||e[0].clientWidth,height:e[0].naturalHeight||e[0].clientHeight}),0===k.width&&window.getComputedStyle)){var l=getComputedStyle(e[0]);l.width&&l.width.indexOf("px")>-1&&l.height&&l.height.indexOf("px")>-1&&(k={width:parseInt(l.width.slice(0,-2)),height:parseInt(l.height.slice(0,-2))})}return angular.isString(c)?(e.removeClass("ng-hide"),i?e.css("background-image","url('"+c+"')"):e.attr("src",c)):void(!c||!c.type||0!==c.type.search(a(e[0]))||i&&0!==c.type.indexOf("image")?e.addClass("ng-hide"):k&&b.isResizeSupported()?(k.resizeIf=function(a,e){return b.attrGetter("ngfResizeIf",f,d,{$width:a,$height:e,$file:c})},b.resize(c,k).then(function(a){j(a)},function(a){throw a})):j(c))});d.$on("$destroy",function(){c()})})}ngFileUpload.service("UploadDataUrl",["UploadBase","$timeout","$q",function(a,b,c){var d=a;return d.base64DataUrl=function(a){if(angular.isArray(a)){var b=c.defer(),e=0;return angular.forEach(a,function(c){d.dataUrl(c,!0)["finally"](function(){if(e++,e===a.length){var c=[];angular.forEach(a,function(a){c.push(a.$ngfDataUrl)}),b.resolve(c,a)}})}),b.promise}return d.dataUrl(a,!0)},d.dataUrl=function(a,e){if(!a)return d.emptyPromise(a,a);if(e&&null!=a.$ngfDataUrl||!e&&null!=a.$ngfBlobUrl)return d.emptyPromise(e?a.$ngfDataUrl:a.$ngfBlobUrl,a);var f=e?a.$$ngfDataUrlPromise:a.$$ngfBlobUrlPromise;if(f)return f;var g=c.defer();return b(function(){if(window.FileReader&&a&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 8")||a.size<2e4)&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 9")||a.size<4e6)){var c=window.URL||window.webkitURL;if(c&&c.createObjectURL&&!e){var f;try{f=c.createObjectURL(a)}catch(h){return void b(function(){a.$ngfBlobUrl="",g.reject()})}b(function(){if(a.$ngfBlobUrl=f,f){g.resolve(f,a),d.blobUrls=d.blobUrls||[],d.blobUrlsTotalSize=d.blobUrlsTotalSize||0,d.blobUrls.push({url:f,size:a.size}),d.blobUrlsTotalSize+=a.size||0;for(var b=d.defaults.blobUrlsMaxMemory||268435456,e=d.defaults.blobUrlsMaxQueueSize||200;(d.blobUrlsTotalSize>b||d.blobUrls.length>e)&&d.blobUrls.length>1;){var h=d.blobUrls.splice(0,1)[0];c.revokeObjectURL(h.url),d.blobUrlsTotalSize-=h.size}}})}else{var i=new FileReader;i.onload=function(c){b(function(){a.$ngfDataUrl=c.target.result,g.resolve(c.target.result,a),b(function(){delete a.$ngfDataUrl},1e3)})},i.onerror=function(){b(function(){a.$ngfDataUrl="",g.reject()})},i.readAsDataURL(a)}}else b(function(){a[e?"$ngfDataUrl":"$ngfBlobUrl"]="",g.reject()})}),f=e?a.$$ngfDataUrlPromise=g.promise:a.$$ngfBlobUrlPromise=g.promise,f["finally"](function(){delete a[e?"$$ngfDataUrlPromise":"$$ngfBlobUrlPromise"]}),f},d}]),ngFileUpload.directive("ngfSrc",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfSrc",a.attrGetter("ngfResize",f,d),!1)}}}]),ngFileUpload.directive("ngfBackground",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfBackground",a.attrGetter("ngfResize",f,d),!0)}}}]),ngFileUpload.directive("ngfThumbnail",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){var g=a.attrGetter("ngfSize",f,d);b(a,c,d,e,f,"ngfThumbnail",g,a.attrGetter("ngfAsBackground",f,d))}}}]),ngFileUpload.config(["$compileProvider",function(a){a.imgSrcSanitizationWhitelist&&a.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/),a.aHrefSanitizationWhitelist&&a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/)}]),ngFileUpload.filter("ngfDataUrl",["UploadDataUrl","$sce",function(a,b){return function(c,d,e){if(angular.isString(c))return b.trustAsResourceUrl(c);var f=c&&((d?c.$ngfDataUrl:c.$ngfBlobUrl)||c.$ngfDataUrl);return c&&!f?(!c.$ngfDataUrlFilterInProgress&&angular.isObject(c)&&(c.$ngfDataUrlFilterInProgress=!0,a.dataUrl(c,d)),""):(c&&delete c.$ngfDataUrlFilterInProgress,(c&&f?e?b.trustAsResourceUrl(f):f:c)||"")}}])}(),ngFileUpload.service("UploadValidate",["UploadDataUrl","$q","$timeout",function(a,b,c){function d(a){var b="",c=[];if(a.length>2&&"/"===a[0]&&"/"===a[a.length-1])b=a.substring(1,a.length-1);else{var e=a.split(",");if(e.length>1)for(var f=0;f<e.length;f++){var g=d(e[f]);g.regexp?(b+="("+g.regexp+")",f<e.length-1&&(b+="|")):c=c.concat(g.excludes)}else 0===a.indexOf("!")?c.push("^((?!"+d(a.substring(1)).regexp+").)*$"):(0===a.indexOf(".")&&(a="*"+a),b="^"+a.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]","g"),"\\$&")+"$",b=b.replace(/\\\*/g,".*").replace(/\\\?/g,"."))}return{regexp:b,excludes:c}}function e(a,b){null==b||a.$dirty||(a.$setDirty?a.$setDirty():a.$dirty=!0)}var f=a;return f.validatePattern=function(a,b){if(!b)return!0;var c=d(b),e=!0;if(c.regexp&&c.regexp.length){var f=new RegExp(c.regexp,"i");e=null!=a.type&&f.test(a.type)||null!=a.name&&f.test(a.name)}for(var g=c.excludes.length;g--;){var h=new RegExp(c.excludes[g],"i");e=e&&(null==a.type||h.test(a.type))&&(null==a.name||h.test(a.name))}return e},f.ratioToFloat=function(a){var b=a.toString(),c=b.search(/[x:]/i);return b=c>-1?parseFloat(b.substring(0,c))/parseFloat(b.substring(c+1)):parseFloat(b)},f.registerModelChangeValidator=function(a,b,c){a&&a.$formatters.push(function(d){if(a.$dirty){var e=d;d&&!angular.isArray(d)&&(e=[d]),f.validate(e,0,a,b,c).then(function(){f.applyModelValidation(a,e)})}return d})},f.applyModelValidation=function(a,b){e(a,b),angular.forEach(a.$ngfValidations,function(b){a.$setValidity(b.name,b.valid)})},f.getValidationAttr=function(a,b,c,d,e){var g="ngf"+c[0].toUpperCase()+c.substr(1),h=f.attrGetter(g,a,b,{$file:e});if(null==h&&(h=f.attrGetter("ngfValidate",a,b,{$file:e}))){var i=(d||c).split(".");h=h[i[0]],i.length>1&&(h=h&&h[i[1]])}return h},f.validate=function(a,c,d,e,g){function h(b,c,h){if(a){for(var i=a.length,j=null;i--;){var n=a[i];if(n){var o=f.getValidationAttr(e,g,b,c,n);null!=o&&(h(n,o,i)||(-1===k.indexOf(b)?(n.$error=b,(n.$errorMessages=n.$errorMessages||{})[b]=!0,n.$errorParam=o,-1===m.indexOf(n)&&m.push(n),l||a.splice(i,1),j=!1):a.splice(i,1)))}}null!==j&&d.$ngfValidations.push({name:b,valid:j})}}function i(c,h,i,n,o){function p(b,d,e){function f(f){if(f())if(-1===k.indexOf(c)){if(d.$error=c,(d.$errorMessages=d.$errorMessages||{})[c]=!0,d.$errorParam=e,-1===m.indexOf(d)&&m.push(d),!l){var g=a.indexOf(d);g>-1&&a.splice(g,1)}b.resolve(!1)}else{var h=a.indexOf(d);h>-1&&a.splice(h,1),b.resolve(!0)}else b.resolve(!0)}null!=e?n(d,e).then(function(a){f(function(){return!o(a,e)})},function(){f(function(){return j("ngfValidateForce",{$file:d})})}):b.resolve(!0)}var q=[f.emptyPromise(!0)];a&&(a=void 0===a.length?[a]:a,angular.forEach(a,function(a){var d=b.defer();return q.push(d.promise),!i||null!=a.type&&0===a.type.search(i)?void("dimensions"===c&&null!=f.attrGetter("ngfDimensions",e)?f.imageDimensions(a).then(function(b){p(d,a,j("ngfDimensions",{$file:a,$width:b.width,$height:b.height}))},function(){d.resolve(!1)}):"duration"===c&&null!=f.attrGetter("ngfDuration",e)?f.mediaDuration(a).then(function(b){p(d,a,j("ngfDuration",{$file:a,$duration:b}))},function(){d.resolve(!1)}):p(d,a,f.getValidationAttr(e,g,c,h,a))):void d.resolve(!0)}));var r=b.defer();return b.all(q).then(function(a){for(var b=!0,e=0;e<a.length;e++)if(!a[e]){b=!1;break}d.$ngfValidations.push({name:c,valid:b}),r.resolve(b)}),r.promise}d=d||{},d.$ngfValidations=d.$ngfValidations||[],angular.forEach(d.$ngfValidations,function(a){a.valid=!0});var j=function(a,b){return f.attrGetter(a,e,g,b)},k=(f.attrGetter("ngfIgnoreInvalid",e,g)||"").split(" "),l=f.attrGetter("ngfRunAllValidations",e,g);if(null==a||0===a.length)return f.emptyPromise({validFiles:a,invalidFiles:[]});a=void 0===a.length?[a]:a.slice(0);var m=[];h("pattern",null,f.validatePattern),h("minSize","size.min",function(a,b){return a.size+.1>=f.translateScalars(b)}),h("maxSize","size.max",function(a,b){return a.size-.1<=f.translateScalars(b)});var n=0;if(h("maxTotalSize",null,function(b,c){return n+=b.size,n>f.translateScalars(c)?(a.splice(0,a.length),!1):!0}),h("validateFn",null,function(a,b){return b===!0||null===b||""===b}),!a.length)return f.emptyPromise({validFiles:[],invalidFiles:m});var o=b.defer(),p=[];return p.push(i("maxHeight","height.max",/image/,this.imageDimensions,function(a,b){return a.height<=b})),p.push(i("minHeight","height.min",/image/,this.imageDimensions,function(a,b){return a.height>=b})),p.push(i("maxWidth","width.max",/image/,this.imageDimensions,function(a,b){return a.width<=b})),p.push(i("minWidth","width.min",/image/,this.imageDimensions,function(a,b){return a.width>=b})),p.push(i("dimensions",null,/image/,function(a,b){return f.emptyPromise(b)},function(a){return a})),p.push(i("ratio",null,/image/,this.imageDimensions,function(a,b){for(var c=b.toString().split(","),d=!1,e=0;e<c.length;e++)Math.abs(a.width/a.height-f.ratioToFloat(c[e]))<.01&&(d=!0);return d})),p.push(i("maxRatio","ratio.max",/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)<1e-4})),p.push(i("minRatio","ratio.min",/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)>-1e-4})),p.push(i("maxDuration","duration.max",/audio|video/,this.mediaDuration,function(a,b){return a<=f.translateScalars(b)})),p.push(i("minDuration","duration.min",/audio|video/,this.mediaDuration,function(a,b){return a>=f.translateScalars(b)})),p.push(i("duration",null,/audio|video/,function(a,b){return f.emptyPromise(b)},function(a){return a})),p.push(i("validateAsyncFn",null,null,function(a,b){return b},function(a){return a===!0||null===a||""===a})),b.all(p).then(function(){if(l)for(var b=0;b<a.length;b++){var d=a[b];d.$error&&a.splice(b--,1)}l=!1,h("maxFiles",null,function(a,b,d){return b>c+d}),o.resolve({validFiles:a,invalidFiles:m})}),o.promise},f.imageDimensions=function(a){if(a.$ngfWidth&&a.$ngfHeight){var d=b.defer();return c(function(){d.resolve({width:a.$ngfWidth,height:a.$ngfHeight})}),d.promise}if(a.$ngfDimensionPromise)return a.$ngfDimensionPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("image")?void e.reject("not image"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].naturalWidth||h[0].clientWidth,c=h[0].naturalHeight||h[0].clientHeight;h.remove(),a.$ngfWidth=b,a.$ngfHeight=c,e.resolve({width:b,height:c})}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].clientWidth?d():i++>10?f():g())},1e3)}var h=angular.element("<img>").attr("src",b).css("visibility","hidden").css("position","fixed").css("max-width","none !important").css("max-height","none !important");h.on("load",d),h.on("error",f);var i=0;g(),angular.element(document.getElementsByTagName("body")[0]).append(h)},function(){e.reject("load error")})}),a.$ngfDimensionPromise=e.promise,a.$ngfDimensionPromise["finally"](function(){delete a.$ngfDimensionPromise}),a.$ngfDimensionPromise},f.mediaDuration=function(a){if(a.$ngfDuration){var d=b.defer();return c(function(){d.resolve(a.$ngfDuration)}),d.promise}if(a.$ngfDurationPromise)return a.$ngfDurationPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("audio")&&0!==a.type.indexOf("video")?void e.reject("not media"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].duration;a.$ngfDuration=b,h.remove(),e.resolve(b)}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].duration?d():i>10?f():g())},1e3)}var h=angular.element(0===a.type.indexOf("audio")?"<audio>":"<video>").attr("src",b).css("visibility","none").css("position","fixed");h.on("loadedmetadata",d),h.on("error",f);var i=0;g(),angular.element(document.body).append(h)},function(){e.reject("load error")})}),a.$ngfDurationPromise=e.promise,a.$ngfDurationPromise["finally"](function(){delete a.$ngfDurationPromise}),a.$ngfDurationPromise},f}]),ngFileUpload.service("UploadResize",["UploadValidate","$q",function(a,b){var c=a,d=function(a,b,c,d,e){var f=e?Math.max(c/a,d/b):Math.min(c/a,d/b);return{width:a*f,height:b*f,marginX:a*f-c,marginY:b*f-d}},e=function(a,e,f,g,h,i,j,k){var l=b.defer(),m=document.createElement("canvas"),n=document.createElement("img");return n.setAttribute("style","visibility:hidden;position:fixed;z-index:-100000"),document.body.appendChild(n),n.onload=function(){var a=n.width,b=n.height;if(n.parentNode.removeChild(n),null!=k&&k(a,b)===!1)return void l.reject("resizeIf");try{if(i){var o=c.ratioToFloat(i),p=a/b;o>p?(e=a,f=e/o):(f=b,e=f*o)}e||(e=a),f||(f=b);var q=d(a,b,e,f,j);m.width=Math.min(q.width,e),m.height=Math.min(q.height,f);var r=m.getContext("2d");r.drawImage(n,Math.min(0,-q.marginX/2),Math.min(0,-q.marginY/2),q.width,q.height),l.resolve(m.toDataURL(h||"image/WebP",g||.934))}catch(s){l.reject(s)}},n.onerror=function(){n.parentNode.removeChild(n),l.reject()},n.src=a,l.promise};return c.dataUrltoBlob=function(a,b,c){for(var d=a.split(","),e=d[0].match(/:(.*?);/)[1],f=atob(d[1]),g=f.length,h=new Uint8Array(g);g--;)h[g]=f.charCodeAt(g);var i=new window.Blob([h],{type:e});return i.name=b,i.$ngfOrigSize=c,i},c.isResizeSupported=function(){var a=document.createElement("canvas");return window.atob&&a.getContext&&a.getContext("2d")&&window.Blob},c.isResizeSupported()&&Object.defineProperty(window.Blob.prototype,"name",{get:function(){return this.$ngfName},set:function(a){this.$ngfName=a},configurable:!0}),c.resize=function(a,d){if(0!==a.type.indexOf("image"))return c.emptyPromise(a);var f=b.defer();return c.dataUrl(a,!0).then(function(b){e(b,d.width,d.height,d.quality,d.type||a.type,d.ratio,d.centerCrop,d.resizeIf).then(function(e){if("image/jpeg"===a.type&&d.restoreExif!==!1)try{e=c.restoreExif(b,e)}catch(g){setTimeout(function(){throw g},1)}try{var h=c.dataUrltoBlob(e,a.name,a.size);f.resolve(h)}catch(g){f.reject(g)}},function(b){"resizeIf"===b&&f.resolve(a),f.reject(b)})},function(a){f.reject(a)}),f.promise},c}]),function(){function a(a,c,d,e,f,g,h,i,j,k){function l(){return c.attr("disabled")||s("ngfDropDisabled",a)}function m(b,c,d){if(b){var e;try{e=b&&b.getData&&b.getData("text/html")}catch(f){}q(b.items,b.files,s("ngfAllowDir",a)!==!1,s("multiple")||s("ngfMultiple",a)).then(function(a){a.length?n(a,c):o(d,e).then(function(a){n(a,c)})})}}function n(b,c){i.updateModel(e,d,a,s("ngfChange")||s("ngfDrop"),b,c)}function o(b,c){if(!i.shouldUpdateOn(b,d,a)||"string"!=typeof c)return i.rejectPromise([]);var e=[];c.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi,function(a,b,c){e.push(c)});var f=[],g=[];if(e.length){angular.forEach(e,function(a){f.push(i.urlToBlob(a).then(function(a){g.push(a)}))});var h=k.defer();return k.all(f).then(function(){h.resolve(g)},function(a){h.reject(a)}),h.promise}return i.emptyPromise()}function p(a,b,c,d){var e=s("ngfDragOverClass",a,{$event:c}),f="dragover";if(angular.isString(e))f=e;else if(e&&(e.delay&&(w=e.delay),e.accept||e.reject)){var g=c.dataTransfer.items;if(null!=g&&g.length)for(var h=e.pattern||s("ngfPattern",a,{$event:c}),j=g.length;j--;){if(!i.validatePattern(g[j],h)){f=e.reject;break}f=e.accept}else f=e.accept}d(f)}function q(b,c,e,f){function g(a,b){var c=k.defer();if(null!=a)if(a.isDirectory){var d=[i.emptyPromise()];if(m){var e={type:"directory"};e.name=e.path=(b||"")+a.name,n.push(e)}var f=a.createReader(),h=[],p=function(){f.readEntries(function(e){try{e.length?(h=h.concat(Array.prototype.slice.call(e||[],0)),p()):(angular.forEach(h.slice(0),function(c){n.length<=j&&l>=o&&d.push(g(c,(b?b:"")+a.name+"/"))}),k.all(d).then(function(){c.resolve()},function(a){c.reject(a)}))}catch(f){c.reject(f)}},function(a){c.reject(a)})};p()}else a.file(function(a){try{a.path=(b?b:"")+a.name,m&&(a=i.rename(a,a.path)),n.push(a),o+=a.size,c.resolve()}catch(d){c.reject(d)}},function(a){c.reject(a)});return c.promise}var j=i.getValidationAttr(d,a,"maxFiles");null==j&&(j=Number.MAX_VALUE);var l=i.getValidationAttr(d,a,"maxTotalSize");null==l&&(l=Number.MAX_VALUE);var m=s("ngfIncludeDir",a),n=[],o=0,p=[i.emptyPromise()];if(b&&b.length>0&&"file:"!==h.location.protocol)for(var q=0;q<b.length;q++){if(b[q].webkitGetAsEntry&&b[q].webkitGetAsEntry()&&b[q].webkitGetAsEntry().isDirectory){var r=b[q].webkitGetAsEntry();if(r.isDirectory&&!e)continue;null!=r&&p.push(g(r))}else{var t=b[q].getAsFile();null!=t&&(n.push(t),o+=t.size)}if(n.length>j||o>l||!f&&n.length>0)break}else if(null!=c)for(var u=0;u<c.length;u++){var v=c.item(u);if((v.type||v.size>0)&&(n.push(v),o+=v.size),n.length>j||o>l||!f&&n.length>0)break}var w=k.defer();return k.all(p).then(function(){if(f||m||!n.length)w.resolve(n);else{for(var a=0;n[a]&&"directory"===n[a].type;)a++;w.resolve([n[a]])}},function(a){w.reject(a)}),w.promise}var r=b(),s=function(a,b,c){return i.attrGetter(a,d,b,c)};if(s("dropAvailable")&&g(function(){a[s("dropAvailable")]?a[s("dropAvailable")].value=r:a[s("dropAvailable")]=r}),!r)return void(s("ngfHideOnDropNotAvailable",a)===!0&&c.css("display","none"));null==s("ngfSelect")&&i.registerModelChangeValidator(e,d,a);var t,u=null,v=f(s("ngfStopPropagation")),w=1;c[0].addEventListener("dragover",function(b){if(!l()&&i.shouldUpdateOn("drop",d,a)){if(b.preventDefault(),v(a)&&b.stopPropagation(),navigator.userAgent.indexOf("Chrome")>-1){var e=b.dataTransfer.effectAllowed;b.dataTransfer.dropEffect="move"===e||"linkMove"===e?"move":"copy"}g.cancel(u),t||(t="C",p(a,d,b,function(d){t=d,c.addClass(t),s("ngfDrag",a,{$isDragging:!0,$class:t,$event:b})}))}},!1),c[0].addEventListener("dragenter",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),v(a)&&b.stopPropagation())},!1),c[0].addEventListener("dragleave",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),
v(a)&&b.stopPropagation(),u=g(function(){t&&c.removeClass(t),t=null,s("ngfDrag",a,{$isDragging:!1,$event:b})},w||100))},!1),c[0].addEventListener("drop",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),v(a)&&b.stopPropagation(),t&&c.removeClass(t),t=null,m(b.dataTransfer,b,"dropUrl"))},!1),c[0].addEventListener("paste",function(b){navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&s("ngfEnableFirefoxPaste",a)&&b.preventDefault(),!l()&&i.shouldUpdateOn("paste",d,a)&&m(b.clipboardData||b.originalEvent.clipboardData,b,"pasteUrl")},!1),navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&s("ngfEnableFirefoxPaste",a)&&(c.attr("contenteditable",!0),c.on("keypress",function(a){a.metaKey||a.ctrlKey||a.preventDefault()}))}function b(){var a=document.createElement("div");return"draggable"in a&&"ondrop"in a&&!/Edge\/12./i.test(navigator.userAgent)}ngFileUpload.directive("ngfDrop",["$parse","$timeout","$window","Upload","$http","$q",function(b,c,d,e,f,g){return{restrict:"AEC",require:"?ngModel",link:function(h,i,j,k){a(h,i,j,k,b,c,d,e,f,g)}}}]),ngFileUpload.directive("ngfNoFileDrop",function(){return function(a,c){b()&&c.css("display","none")}}),ngFileUpload.directive("ngfDropAvailable",["$parse","$timeout","Upload",function(a,c,d){return function(e,f,g){if(b()){var h=a(d.attrGetter("ngfDropAvailable",g));c(function(){h(e),h.assign&&h.assign(e,!0)})}}}])}(),ngFileUpload.service("UploadExif",["UploadResize","$q",function(a,b){function c(a,b,c,d){switch(b){case 2:return a.transform(-1,0,0,1,c,0);case 3:return a.transform(-1,0,0,-1,c,d);case 4:return a.transform(1,0,0,-1,0,d);case 5:return a.transform(0,1,1,0,0,0);case 6:return a.transform(0,1,-1,0,d,0);case 7:return a.transform(0,-1,-1,0,d,c);case 8:return a.transform(0,-1,1,0,0,c)}}function d(a){for(var b="",c=new Uint8Array(a),d=c.byteLength,e=0;d>e;e++)b+=String.fromCharCode(c[e]);return window.btoa(b)}var e=a;return e.isExifSupported=function(){return window.FileReader&&(new FileReader).readAsArrayBuffer&&e.isResizeSupported()},e.readOrientation=function(a){var c=b.defer(),d=new FileReader,e=a.slice?a.slice(0,65536):a;return d.readAsArrayBuffer(e),d.onerror=function(a){return c.reject(a)},d.onload=function(a){var b={orientation:1},d=new DataView(this.result);if(65496!==d.getUint16(0,!1))return c.resolve(b);for(var e=d.byteLength,f=2;e>f;){var g=d.getUint16(f,!1);if(f+=2,65505===g){if(1165519206!==d.getUint32(f+=2,!1))return c.resolve(b);var h=18761===d.getUint16(f+=6,!1);f+=d.getUint32(f+4,h);var i=d.getUint16(f,h);f+=2;for(var j=0;i>j;j++)if(274===d.getUint16(f+12*j,h)){var k=d.getUint16(f+12*j+8,h);return k>=2&&8>=k&&(d.setUint16(f+12*j+8,1,h),b.fixedArrayBuffer=a.target.result),b.orientation=k,c.resolve(b)}}else{if(65280!==(65280&g))break;f+=d.getUint16(f,!1)}}return c.resolve(b)},c.promise},e.applyExifRotation=function(a){if(0!==a.type.indexOf("image/jpeg"))return e.emptyPromise(a);var f=b.defer();return e.readOrientation(a).then(function(b){return b.orientation<2||b.orientation>8?f.resolve(a):void e.dataUrl(a,!0).then(function(g){var h=document.createElement("canvas"),i=document.createElement("img");i.onload=function(){try{h.width=b.orientation>4?i.height:i.width,h.height=b.orientation>4?i.width:i.height;var g=h.getContext("2d");c(g,b.orientation,i.width,i.height),g.drawImage(i,0,0);var j=h.toDataURL(a.type||"image/WebP",.934);j=e.restoreExif(d(b.fixedArrayBuffer),j);var k=e.dataUrltoBlob(j,a.name);f.resolve(k)}catch(l){return f.reject(l)}},i.onerror=function(){f.reject()},i.src=g},function(a){f.reject(a)})},function(a){f.reject(a)}),f.promise},e.restoreExif=function(a,b){var c={};return c.KEY_STR="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",c.encode64=function(a){var b,c,d,e,f,g="",h="",i="",j=0;do b=a[j++],c=a[j++],h=a[j++],d=b>>2,e=(3&b)<<4|c>>4,f=(15&c)<<2|h>>6,i=63&h,isNaN(c)?f=i=64:isNaN(h)&&(i=64),g=g+this.KEY_STR.charAt(d)+this.KEY_STR.charAt(e)+this.KEY_STR.charAt(f)+this.KEY_STR.charAt(i),b=c=h="",d=e=f=i="";while(j<a.length);return g},c.restore=function(a,b){a.match("data:image/jpeg;base64,")&&(a=a.replace("data:image/jpeg;base64,",""));var c=this.decode64(a),d=this.slice2Segments(c),e=this.exifManipulation(b,d);return"data:image/jpeg;base64,"+this.encode64(e)},c.exifManipulation=function(a,b){var c=this.getExifArray(b),d=this.insertExif(a,c);return new Uint8Array(d)},c.getExifArray=function(a){for(var b,c=0;c<a.length;c++)if(b=a[c],255===b[0]&225===b[1])return b;return[]},c.insertExif=function(a,b){var c=a.replace("data:image/jpeg;base64,",""),d=this.decode64(c),e=d.indexOf(255,3),f=d.slice(0,e),g=d.slice(e),h=f;return h=h.concat(b),h=h.concat(g)},c.slice2Segments=function(a){for(var b=0,c=[];;){if(255===a[b]&218===a[b+1])break;if(255===a[b]&216===a[b+1])b+=2;else{var d=256*a[b+2]+a[b+3],e=b+d+2,f=a.slice(b,e);c.push(f),b=e}if(b>a.length)break}return c},c.decode64=function(a){var b,c,d,e,f,g="",h="",i=0,j=[],k=/[^A-Za-z0-9\+\/\=]/g;k.exec(a)&&console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."),a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");do d=this.KEY_STR.indexOf(a.charAt(i++)),e=this.KEY_STR.indexOf(a.charAt(i++)),f=this.KEY_STR.indexOf(a.charAt(i++)),h=this.KEY_STR.indexOf(a.charAt(i++)),b=d<<2|e>>4,c=(15&e)<<4|f>>2,g=(3&f)<<6|h,j.push(b),64!==f&&j.push(c),64!==h&&j.push(g),b=c=g="",d=e=f=h="";while(i<a.length);return j},c.restore(a,b)},e}]);
/**
 * @lordfriend/nya-bootstrap-select v2.4.0
 * Copyright 2014 Nyasoft
 * Licensed under MIT license
 */
(function(){
  'use strict';


var uid = 0;

function nextUid() {
  return ++uid;
}

/**
 * Checks if `obj` is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
  return obj && obj.window === obj;
}

/**
 * @ngdoc function
 * @name angular.isString
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value){return typeof value === 'string';}

/**
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
 *                   String ...)
 */
function isArrayLike(obj) {
  if (obj == null || isWindow(obj)) {
    return false;
  }

  var length = obj.length;

  if (obj.nodeType === 1 && length) {
    return true;
  }

  return isString(obj) || Array.isArray(obj) || length === 0 ||
    typeof length === 'number' && length > 0 && (length - 1) in obj;
}

/**
 * Creates a new object without a prototype. This object is useful for lookup without having to
 * guard against prototypically inherited properties via hasOwnProperty.
 *
 * Related micro-benchmarks:
 * - http://jsperf.com/object-create2
 * - http://jsperf.com/proto-map-lookup/2
 * - http://jsperf.com/for-in-vs-object-keys2
 *
 * @returns {Object}
 */
function createMap() {
  return Object.create(null);
}

/**
 * Computes a hash of an 'obj'.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in 'type:hashKey' format.
 */
function hashKey(obj, nextUidFn) {
  var objType = typeof obj,
    key;

  if (objType == 'function' || (objType == 'object' && obj !== null)) {
    if (typeof (key = obj.$$hashKey) == 'function') {
      // must invoke on object to keep the right this
      key = obj.$$hashKey();
    } else if (key === undefined) {
      key = obj.$$hashKey = (nextUidFn || nextUid)();
    }
  } else {
    key = obj;
  }

  return objType + ':' + key;
}

//TODO: use with caution. if an property of element in array doesn't exist in group, the resultArray may lose some element.
function sortByGroup(array ,group, property) {
  var unknownGroup = [],
    i, j,
    resultArray = [];
  for(i = 0; i < group.length; i++) {
    for(j = 0; j < array.length;j ++) {
      if(!array[j][property]) {
        unknownGroup.push(array[j]);
      } else if(array[j][property] === group[i]) {
        resultArray.push(array[j]);
      }
    }
  }

  resultArray = resultArray.concat(unknownGroup);

  return resultArray;
}

/**
 * Return the DOM siblings between the first and last node in the given array.
 * @param {Array} array like object
 * @returns {jqLite} jqLite collection containing the nodes
 */
function getBlockNodes(nodes) {
  // TODO(perf): just check if all items in `nodes` are siblings and if they are return the original
  //             collection, otherwise update the original collection.
  var node = nodes[0];
  var endNode = nodes[nodes.length - 1];
  var blockNodes = [node];

  do {
    node = node.nextSibling;
    if (!node) break;
    blockNodes.push(node);
  } while (node !== endNode);

  return angular.element(blockNodes);
}

var getBlockStart = function(block) {
  return block.clone[0];
};

var getBlockEnd = function(block) {
  return block.clone[block.clone.length - 1];
};

var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength, group) {
  // TODO(perf): generate setters to shave off ~40ms or 1-1.5%
  scope[valueIdentifier] = value;
  if (keyIdentifier) scope[keyIdentifier] = key;
  scope.$index = index;
  scope.$first = (index === 0);
  scope.$last = (index === (arrayLength - 1));
  scope.$middle = !(scope.$first || scope.$last);
  // jshint bitwise: false
  scope.$odd = !(scope.$even = (index&1) === 0);
  // jshint bitwise: true

  if(group) {
    scope.$group = group;
  }
};

var setElementIsolateScope = function(element, scope) {
  element.data('isolateScope', scope);
};

var contains = function(array, element) {
  var length = array.length,
    i;
  if(length === 0) {
    return false;
  }
  for(i = 0;i < length; i++) {
    if(deepEquals(element, array[i])) {
      return true;
    }
  }
  return false;
};

var indexOf = function(array, element) {
  var length = array.length,
    i;
  if(length === 0) {
    return -1;
  }
  for(i = 0; i < length; i++) {
    if(deepEquals(element, array[i])) {
      return i;
    }
  }
  return -1;
};

/**
 * filter the event target for the nya-bs-option element.
 * Use this method with event delegate. (attach a event handler on an parent element and listen the special children elements)
 * @param target event.target node
 * @param parent {object} the parent, where the event handler attached.
 * @param selector {string}|{object} a class or DOM element
 * @return the filtered target or null if no element satisfied the selector.
 */
var filterTarget = function(target, parent, selector) {
  var elem = target,
    className, type = typeof selector;

  if(target == parent) {
    return null;
  } else {
    do {
      if(type === 'string') {
        className = ' ' + elem.className + ' ';
        if(elem.nodeType === 1 && className.replace(/[\t\r\n\f]/g, ' ').indexOf(selector) >= 0) {
          return elem;
        }
      } else {
        if(elem == selector) {
          return elem;
        }
      }

    } while((elem = elem.parentNode) && elem != parent && elem.nodeType !== 9);

    return null;
  }

};

var getClassList = function(element) {
  var classList,
    className = element.className.replace(/[\t\r\n\f]/g, ' ').trim();
  classList = className.split(' ');
  for(var i = 0; i < classList.length; i++) {
    if(/\s+/.test(classList[i])) {
      classList.splice(i, 1);
      i--;
    }
  }
  return classList;

};

// work with node element
var hasClass = function(element, className) {
  var classList = getClassList(element);
  return classList.indexOf(className) !== -1;
};

// query children by class(one or more)
var queryChildren = function(element, classList) {
  var children = element.children(),
    length = children.length,
    child,
    valid,
    classes;
  if(length > 0) {
    for(var i = 0; i < length; i++) {
      child = children.eq(i);
      valid = true;
      classes = getClassList(child[0]);
      if(classes.length > 0) {
        for(var j = 0; j < classList.length; j++) {
          if(classes.indexOf(classList[j]) === -1) {
            valid = false;
            break;
          }
        }
      }
      if(valid) {
        return child;
      }
    }
  }
  return [];
};

/**
 * Current support only drill down one level.
 * case insensitive
 * @param element
 * @param keyword
 */
var hasKeyword = function(element, keyword) {
  var childElements,
    index, length;
  if(element.text().toLowerCase().indexOf(keyword.toLowerCase()) !== -1) {
    return true;
  } else {
    childElements = element.children();
    length = childElements.length;
    for(index = 0; index < length; index++) {
      if(childElements.eq(index).text().toLowerCase().indexOf(keyword.toLowerCase()) !== -1) {
        return true;
      }
    }
    return false;
  }
};

function sibling( cur, dir ) {
  while ( (cur = cur[dir]) && cur.nodeType !== 1) {}
  return cur;
}


// map global property to local variable.
var jqLite = angular.element;

var deepEquals = angular.equals;

var deepCopy = angular.copy;

var extend = angular.extend;

var nyaBsSelect = angular.module('nya.bootstrap.select', []);

/**
 * A service for configuration. the configuration is shared globally.
 * Testing ci build --jpmckearin
 */
nyaBsSelect.provider('nyaBsConfig', function() {

  var locale = null;

  // default localized text. cannot be modified.
  var defaultText = {
    'en-us': {
      defaultNoneSelection: 'Nothing selected',
      noSearchResult: 'NO SEARCH RESULT',
      numberItemSelected: '%d items selected',
      selectAll: 'Select All',
      deselectAll: 'Deselect All'
    }
  };

  // localized text which actually being used.
  var interfaceText = deepCopy(defaultText);

  /**
   * Merge with default localized text.
   * @param localeId a string formatted as languageId-countryId
   * @param obj localized text object.
   */
  this.setLocalizedText = function(localeId, obj) {
    if(!localeId) {
      throw new Error('localeId must be a string formatted as languageId-countryId');
    }
    if(!interfaceText[localeId]) {
      interfaceText[localeId] = {};
    }
    interfaceText[localeId] = extend(interfaceText[localeId], obj);
  };

  /**
   * Force to use a special locale id. if localeId is null. reset to user-agent locale.
   * @param localeId a string formatted as languageId-countryId
   */
  this.useLocale = function(localeId) {
    locale = localeId;
  };

  /**
   * get the localized text according current locale or forced locale
   * @returns localizedText
   */
  this.$get = ['$locale', function($locale){
    var localizedText;
    if(locale) {
      localizedText = interfaceText[locale];
    } else {
      localizedText = interfaceText[$locale.id];
    }
    if(!localizedText) {
      localizedText = defaultText['en-us'];
    }
    return localizedText;
  }];

});


nyaBsSelect.controller('nyaBsSelectCtrl', function(){

  var self = this;

  // keyIdentifier and valueIdentifier are set by nyaBsOption directive
  // used by nyaBsSelect directive to retrieve key and value from each nyaBsOption's child scope.
  self.keyIdentifier = null;
  self.valueIdentifier = null;

  self.isMultiple = false;

  // Should be override by nyaBsSelect directive and called by nyaBsOption directive when collection is changed.
  self.onCollectionChange = function(){};

  // for debug
  self.setId = function(id) {
    self.id = id || 'id#' + Math.floor(Math.random() * 10000);
  };

});
nyaBsSelect.directive('nyaBsSelect', ['$parse', '$document', '$timeout', '$compile', 'nyaBsConfig', function ($parse, $document, $timeout, $compile, nyaBsConfig) {

  var DEFAULT_NONE_SELECTION = 'Nothing selected';

  var DROPDOWN_TOGGLE = '<button class="btn btn-default dropdown-toggle" type="button">' +
    '<span class="pull-left filter-option"></span>' +
    '<span class="pull-left special-title"></span>' +
    '&nbsp;' +
    '<span class="caret"></span>' +
    '</button>';

  var DROPDOWN_CONTAINER = '<div class="dropdown-menu open"></div>';

  var SEARCH_BOX = '<div class="bs-searchbox">' +
    '<input type="text" class="form-control">' +
    '</div>';

  var DROPDOWN_MENU = '<ul class="dropdown-menu inner"></ul>';

  var NO_SEARCH_RESULT = '<li class="no-search-result"><span>NO SEARCH RESULT</span></li>';

  var ACTIONS_BOX = '<div class="bs-actionsbox">' +
    '<div class="btn-group btn-group-sm btn-block">' +
    '<button type="button" class="actions-btn bs-select-all btn btn-default">SELECT ALL</button>' +
    '<button type="button" class="actions-btn bs-deselect-all btn btn-default">DESELECT ALL</button>' +
    '</div>' +
    '</div>';

  return {
    restrict: 'ECA',
    require: ['ngModel', 'nyaBsSelect'],
    controller: 'nyaBsSelectCtrl',
    compile: function nyaBsSelectCompile (tElement, tAttrs){
      

      tElement.addClass('btn-group');


      /**
       * get the default text when nothing is selected. can be template
       * @param scope, if provided, will try to compile template with given scope, will not attempt to compile the pure text.
       * @returns {*}
       */
      var getDefaultNoneSelectionContent = function(scope) {
        // text node or jqLite element.
        var content;

        if(tAttrs.titleTpl) {
          // use title-tpl attribute value.
          content = jqLite(tAttrs.titleTpl);
        } else if(tAttrs.title) {
          // use title attribute value.
          content = document.createTextNode(tAttrs.title);
        } else if(localizedText.defaultNoneSelectionTpl){
          // use localized text template.
          content = jqLite(localizedText.defaultNoneSelectionTpl);
        } else if(localizedText.defaultNoneSelection) {
          // use localized text.
          content = document.createTextNode(localizedText.defaultNoneSelection);
        } else {
          // use default.
          content = document.createTextNode(DEFAULT_NONE_SELECTION);
        }

        if(scope && (tAttrs.titleTpl || localizedText.defaultNoneSelectionTpl)) {
          
          return $compile(content)(scope);
        }

        return content;
      };

      var options = tElement.children(),
        dropdownToggle = jqLite(DROPDOWN_TOGGLE),
        dropdownContainer = jqLite(DROPDOWN_CONTAINER),
        dropdownMenu = jqLite(DROPDOWN_MENU),
        searchBox,
        noSearchResult,
        actionsBox,
        classList,
        length,
        index,
        liElement,
        localizedText = nyaBsConfig,
        isMultiple = typeof tAttrs.multiple !== 'undefined',
        nyaBsOptionValue;

      classList = getClassList(tElement[0]);
      classList.forEach(function(className) {
        if(/btn-(?:primary|info|success|warning|danger|inverse)/.test(className)) {
          tElement.removeClass(className);
          dropdownToggle.removeClass('btn-default');
          dropdownToggle.addClass(className);
        }

        if(/btn-(?:lg|sm|xs)/.test(className)) {
          tElement.removeClass(className);
          dropdownToggle.addClass(className);
        }

        // if(className === 'form-control') {
        //   dropdownToggle.addClass(className);
        // }
      });

      dropdownMenu.append(options);

      // add tabindex to children anchor elements if not present.
      // tabindex attribute will give an anchor element ability to be get focused.
      length = options.length;
      for(index = 0; index < length; index++) {
        liElement = options.eq(index);
        if(liElement.hasClass('nya-bs-option') || liElement.attr('nya-bs-option')) {
          liElement.find('a').attr('tabindex', '0');
          // In order to be compatible with old version, we should copy value of value attribute into data-value attribute.
          // For the reason we use data-value instead, see http://nya.io/AngularJS/Beware-Of-Using-value-Attribute-On-list-element/
          nyaBsOptionValue = liElement.attr('value');
          if(angular.isString(nyaBsOptionValue) && nyaBsOptionValue !== '') {
            liElement.attr('data-value', nyaBsOptionValue);
            liElement.removeAttr('value');
          }
        }
      }

      if(typeof tAttrs.liveSearch !== 'undefined') {
        searchBox = jqLite(SEARCH_BOX);

        if(tAttrs.noSearchTitle) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('NO SEARCH RESULT', tAttrs.noSearchTitle);
        } else if (tAttrs.noSearchTitleTpl) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('NO SEARCH RESULT', tAttrs.noSearchTitleTpl);
        }else {
          // set localized text
          if(localizedText.noSearchResultTpl) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('NO SEARCH RESULT', localizedText.noSearchResultTpl);
          } else if(localizedText.noSearchResult) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('NO SEARCH RESULT', localizedText.noSearchResult);
          }
        }

        noSearchResult = jqLite(NO_SEARCH_RESULT);
        dropdownContainer.append(searchBox);
        dropdownMenu.append(noSearchResult);
      }

      if (typeof tAttrs.actionsBox !== 'undefined' && isMultiple) {
        // set localizedText
        if (localizedText.selectAllTpl) {
          ACTIONS_BOX = ACTIONS_BOX.replace('SELECT ALL', localizedText.selectAllTpl);
        } else if (localizedText.selectAll) {
          ACTIONS_BOX = ACTIONS_BOX.replace('SELECT ALL', localizedText.selectAll);
        }

        if (localizedText.deselectAllTpl) {
          ACTIONS_BOX = ACTIONS_BOX.replace('DESELECT ALL', localizedText.deselectAllTpl);
        } else if (localizedText.selectAll) {
          ACTIONS_BOX = ACTIONS_BOX.replace('DESELECT ALL', localizedText.deselectAll);
        }

        actionsBox = jqLite(ACTIONS_BOX);
        dropdownContainer.append(actionsBox);
      }

      // set default none selection text
      jqLite(dropdownToggle[0].querySelector('.special-title')).append(getDefaultNoneSelectionContent());

      dropdownContainer.append(dropdownMenu);

      tElement.append(dropdownToggle);
      tElement.append(dropdownContainer);

      return function nyaBsSelectLink ($scope, $element, $attrs, ctrls) {
        
        var ngCtrl = ctrls[0],
          nyaBsSelectCtrl = ctrls[1],
          liHeight,
          isDisabled = false,
          previousTabIndex,
          valueExpFn,
          valueExpGetter = $parse(nyaBsSelectCtrl.valueExp),
          isMultiple = typeof $attrs.multiple !== 'undefined';

        // find element from current $element root. because the compiled element may be detached from DOM tree by ng-if or ng-switch.
        var dropdownToggle = jqLite($element[0].querySelector('.dropdown-toggle')),
          dropdownContainer = dropdownToggle.next(),
          dropdownMenu = jqLite(dropdownContainer[0].querySelector('.dropdown-menu.inner')),
          searchBox = jqLite(dropdownContainer[0].querySelector('.bs-searchbox')),
          noSearchResult = jqLite(dropdownMenu[0].querySelector('.no-search-result')),
          actionsBox = jqLite(dropdownContainer[0].querySelector('.bs-actionsbox'));

        if(nyaBsSelectCtrl.valueExp) {
          valueExpFn = function(scope, locals) {
            return valueExpGetter(scope, locals);
          };
        }

        // for debug
        nyaBsSelectCtrl.setId($element.attr('id'));

        if (isMultiple) {
          nyaBsSelectCtrl.isMultiple = true;

          // required validator
          ngCtrl.$isEmpty = function(value) {
            return !value || value.length === 0;
          };
        }
        function disabledHandling(disabled){
          if(disabled) {
            dropdownToggle.addClass('disabled');
            dropdownToggle.attr('disabled', 'disabled');
            previousTabIndex = dropdownToggle.attr('tabindex');
            dropdownToggle.attr('tabindex', '-1');
            isDisabled = true;
          } else {
            dropdownToggle.removeClass('disabled');
            dropdownToggle.removeAttr('disabled');
            if(previousTabIndex) {
              dropdownToggle.attr('tabindex', previousTabIndex);
            } else {
              dropdownToggle.removeAttr('tabindex');
            }
            isDisabled = false;
          }
        }
        if(typeof $attrs.disabled !== 'undefined') {
          $scope.$watch($attrs.disabled, function(disabled){
            disabledHandling(disabled);
          });
        }else if(typeof $attrs.ngDisabled !== 'undefined'){
          $scope.$watch($attrs.ngDisabled, function(disabled){
            disabledHandling(disabled);
          });
        }

        /**
         * Do some check on modelValue. remove no existing value
         * @param values
         * @param deepWatched
         */
        nyaBsSelectCtrl.onCollectionChange = function (values, deepWatched) {
          var valuesForSelect = [],
            index,
            modelValueChanged = false,
            // Due to ngModelController compare reference with the old modelValue, we must set an new array instead of modifying the old one.
            // See: https://github.com/angular/angular.js/issues/1751
            modelValue = deepCopy(ngCtrl.$modelValue);

          if(!modelValue) {
            return;
          }

          /**
           * Behavior change, since 2.1.0, we don't want to reset model to null or empty array when options' collection is not prepared.
           */
          if(Array.isArray(values) && values.length > 0) {
            if(valueExpFn) {
              for(index = 0; index < values.length; index++) {
                valuesForSelect.push(valueExpFn($scope, values[index]));
              }
            } else {
              for(index = 0; index < values.length; index++) {
                if(nyaBsSelectCtrl.valueIdentifier) {
                  valuesForSelect.push(values[index][nyaBsSelectCtrl.valueIdentifier]);
                } else if(nyaBsSelectCtrl.keyIdentifier) {
                  valuesForSelect.push(values[index][nyaBsSelectCtrl.keyIdentifier]);
                }
              }

            }

            if(isMultiple) {
              for(index = 0; index < modelValue.length; index++) {
                if(!contains(valuesForSelect, modelValue[index])) {
                  modelValueChanged = true;
                  modelValue.splice(index, 1);
                  index--;
                }
              }

              if(modelValueChanged) {
                // modelValue changed.

                ngCtrl.$setViewValue(modelValue);

                updateButtonContent();
              }

            } else {
              if(!contains(valuesForSelect, modelValue)) {
                modelValue = valuesForSelect[0];

                ngCtrl.$setViewValue(modelValue);

                updateButtonContent();
              }
            }

          }

          /**
           * if we set deep-watch="true" on nyaBsOption directive,
           * we need to refresh dropdown button content whenever a change happened in collection.
           */
          if(deepWatched) {
            
            updateButtonContent();
          }

        };

        // view --> model

        dropdownMenu.on('click', function menuEventHandler (event) {
          if(isDisabled) {
            return;
          }
          
          if(jqLite(event.target).hasClass('dropdown-header')) {
            return;
          }
          var nyaBsOptionNode = filterTarget(event.target, dropdownMenu[0], 'nya-bs-option'),
            nyaBsOption;

          if(nyaBsOptionNode !== null) {
            nyaBsOption = jqLite(nyaBsOptionNode);
            if(nyaBsOption.hasClass('disabled')) {
              return;
            }
            selectOption(nyaBsOption);
          }
        });

        // if click the outside of dropdown menu, close the dropdown menu
        var outClick = function(event) {
          if(filterTarget(event.target, $element.parent()[0], $element[0]) === null) {
            if($element.hasClass('open')) {
              $element.triggerHandler('blur');
            }
            $element.removeClass('open');
          }
        };
        $document.on('click', outClick);

        

        dropdownToggle.on('blur', function() {
          if(!$element.hasClass('open')) {
            $element.triggerHandler('blur');
          }
        });
        dropdownToggle.on('click', function() {
          var nyaBsOptionNode;
          $element.toggleClass('open');
          if($element.hasClass('open') && typeof liHeight === 'undefined') {
            calcMenuSize();
          }
          if($attrs.liveSearch === 'true' && $element.hasClass('open')) {
            searchBox.children().eq(0)[0].focus();
            nyaBsOptionNode = findFocus(true);
            if(nyaBsOptionNode) {
              dropdownMenu.children().removeClass('active');
              jqLite(nyaBsOptionNode).addClass('active');
            }
          } else if($element.hasClass('open')) {
            nyaBsOptionNode = findFocus(true);
            if(nyaBsOptionNode) {
              setFocus(nyaBsOptionNode);
            }
          }
        });

        // actions box
        if ($attrs.actionsBox === 'true' && isMultiple) {
          actionsBox.find('button').eq(0).on('click', function () {
            setAllOptions(true);
          });
          actionsBox.find('button').eq(1).on('click', function () {
            setAllOptions(false);
          });
        } else {
          // if using inside ng-repeat or other transclude directive
          if (actionsBox) {
            actionsBox.addClass('hidden');
          }
        }


        // live search
        if($attrs.liveSearch === 'true') {
          searchBox.children().on('input', function(){

            var searchKeyword = searchBox.children().val(),
              found = 0,
              options = dropdownMenu.children(),
              length = options.length,
              index,
              option,
              nyaBsOptionNode;

            if(searchKeyword) {
              for(index = 0; index < length; index++) {
                option = options.eq(index);
                if(option.hasClass('nya-bs-option')) {
                  if(!hasKeyword(option.find('a'), searchKeyword)) {
                    option.addClass('not-match');
                  } else {
                    option.removeClass('not-match');
                    found++;
                  }
                }
              }

              if(found === 0) {
                noSearchResult.addClass('show');
              } else {
                noSearchResult.removeClass('show');
              }
            } else {
              for(index = 0; index < length; index++) {
                option = options.eq(index);
                if(option.hasClass('nya-bs-option')) {
                  option.removeClass('not-match');
                }
              }
              noSearchResult.removeClass('show');
            }

            nyaBsOptionNode = findFocus(true);

            if(nyaBsOptionNode) {
              options.removeClass('active');
              jqLite(nyaBsOptionNode).addClass('active');
            }

          });
        } else {
          // if using inside ng-repeat or other transclude directive
          if (searchBox) {
            searchBox.addClass('hidden');
          }
        }


        // model --> view

        ngCtrl.$render = function() {
          var modelValue = ngCtrl.$modelValue,
            index,
            bsOptionElements = dropdownMenu.children(),
            length = bsOptionElements.length,
            value;
          if(typeof modelValue === 'undefined' || modelValue === null) {
            // if modelValue is undefined. uncheck all option
            for(index = 0; index < length; index++) {
              if(bsOptionElements.eq(index).hasClass('nya-bs-option')) {
                bsOptionElements.eq(index).removeClass('selected');
              }
            }
          } else {
            for(index = 0; index < length; index++) {
              if(bsOptionElements.eq(index).hasClass('nya-bs-option')) {

                value = getOptionValue(bsOptionElements.eq(index));
                if(isMultiple) {
                  if(contains(modelValue, value)) {
                    bsOptionElements.eq(index).addClass('selected');
                  } else {
                    bsOptionElements.eq(index).removeClass('selected');
                  }
                } else {
                  if(deepEquals(modelValue, value)) {
                    bsOptionElements.eq(index).addClass('selected');
                  } else {
                    bsOptionElements.eq(index).removeClass('selected');
                  }
                }

              }
            }
          }
          //console.log(nyaBsSelectCtrl.id + ' render end');
          updateButtonContent();
        };

        // simple keyboard support
        $element.on('keydown', function(event){
          var keyCode = event.keyCode;

          if(keyCode !== 27 && keyCode !== 13 && keyCode !== 38 && keyCode !== 40) {
            // we only handle special keys. don't waste time to traverse the dom tree.
            return;
          }

          // prevent a click event to be fired.
          event.preventDefault();
          if(isDisabled) {
            event.stopPropagation();
            return;
          }
          var toggleButton = filterTarget(event.target, $element[0], dropdownToggle[0]),
            menuContainer,
            searchBoxContainer,
            liElement,
            nyaBsOptionNode;

          if($attrs.liveSearch === 'true') {
            searchBoxContainer = filterTarget(event.target, $element[0], searchBox[0]);
          } else {
            menuContainer = filterTarget(event.target, $element[0], dropdownContainer[0])
          }

          if(toggleButton) {
            

            // press enter to active dropdown
            if((keyCode === 13 || keyCode === 38 || keyCode === 40) && !$element.hasClass('open')) {

              event.stopPropagation();

              $element.addClass('open');

              // calculate menu size
              if(typeof liHeight === 'undefined') {
                calcMenuSize();
              }

              // if live search enabled. give focus to search box.
              if($attrs.liveSearch === 'true') {
                searchBox.children().eq(0)[0].focus();
                // find the focusable node but we will use active
                nyaBsOptionNode = findFocus(true);
                if(nyaBsOptionNode) {
                  // remove previous active state
                  dropdownMenu.children().removeClass('active');
                  // set active to first focusable element
                  jqLite(nyaBsOptionNode).addClass('active');
                }
              } else {
                // otherwise, give focus to first menu item.
                nyaBsOptionNode = findFocus(true);
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                }
              }
            }

            // press enter or escape to de-active dropdown
            //if((keyCode === 13 || keyCode === 27) && $element.hasClass('open')) {
            //  $element.removeClass('open');
            //  event.stopPropagation();
            //}
          } else if(menuContainer) {

            if(keyCode === 27) {
              // escape pressed
              dropdownToggle[0].focus();
              if($element.hasClass('open')) {
                $element.triggerHandler('blur');
              }
              $element.removeClass('open');
              event.stopPropagation();

            } else if(keyCode === 38) {
              event.stopPropagation();
              // up arrow key
              nyaBsOptionNode = findNextFocus(event.target.parentNode, 'previousSibling');
              if(nyaBsOptionNode) {
                setFocus(nyaBsOptionNode);
              } else {
                nyaBsOptionNode = findFocus(false);
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                }
              }
            } else if(keyCode === 40) {
              event.stopPropagation();
              // down arrow key
              nyaBsOptionNode = findNextFocus(event.target.parentNode, 'nextSibling');
              if(nyaBsOptionNode) {
                setFocus(nyaBsOptionNode);
              } else {
                nyaBsOptionNode = findFocus(true);
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                }
              }
            } else if(keyCode === 13) {
              event.stopPropagation();
              // enter pressed
              liElement = jqLite(event.target.parentNode);
              if(liElement.hasClass('nya-bs-option')) {
                selectOption(liElement);
                if(!isMultiple) {
                  dropdownToggle[0].focus();
                }
              }
            }
          } else if(searchBoxContainer) {
            if(keyCode === 27) {
              dropdownToggle[0].focus();
              $element.removeClass('open');
              event.stopPropagation();
            } else if(keyCode === 38) {
              // up
              event.stopPropagation();

              liElement = findActive();
              if(liElement) {
                nyaBsOptionNode = findNextFocus(liElement[0], 'previousSibling');
                if(nyaBsOptionNode) {
                  liElement.removeClass('active');
                  jqLite(nyaBsOptionNode).addClass('active');
                } else {
                  nyaBsOptionNode = findFocus(false);
                  if(nyaBsOptionNode) {
                    liElement.removeClass('active');
                    jqLite(nyaBsOptionNode).addClass('active');
                  }
                }
              }

            } else if(keyCode === 40) {
              // down
              event.stopPropagation();

              liElement = findActive();
              if(liElement) {
                nyaBsOptionNode = findNextFocus(liElement[0], 'nextSibling');
                if(nyaBsOptionNode) {
                  liElement.removeClass('active');
                  jqLite(nyaBsOptionNode).addClass('active');
                } else {
                  nyaBsOptionNode = findFocus(true);
                  if(nyaBsOptionNode) {
                    liElement.removeClass('active');
                    jqLite(nyaBsOptionNode).addClass('active');
                  }
                }
              }
            } else if(keyCode === 13) {
              // select an option.
              liElement = findActive();
              if(liElement) {
                selectOption(liElement);
                if(!isMultiple) {
                  dropdownToggle[0].focus();
                }
              }
            }
          }
        });

        function findActive() {
          var list = dropdownMenu.children(),
            i, liElement,
            length = list.length;
          for(i = 0; i < length; i++) {
            liElement = list.eq(i);
            if(liElement.hasClass('active') && liElement.hasClass('nya-bs-option') && !liElement.hasClass('not-match')) {
              return liElement;
            }
          }
          return null;
        }

        /**
         * setFocus on a nya-bs-option element. it actually set focus on its child anchor element.
         * @param elem a nya-bs-option element.
         */
        function setFocus(elem) {
          var childList = elem.childNodes,
            length = childList.length,
            child;
          for(var i = 0; i < length; i++) {
            child = childList[i];
            if(child.nodeType === 1 && child.tagName.toLowerCase() === 'a') {
              child.focus();
              break;
            }
          }
        }

        function supportsSelector(selector) {
          var el = document.createElement('div');
          el.innerHTML = ['&shy;', '<style>', selector, '{}', '</style>'].join('');
          el = document.body.appendChild(el);
          var style = el.getElementsByTagName('style')[0];
            if (style && style.sheet && style.sheet.rules && style.sheet.cssRules) {
              var ret = !!(style.sheet.rules || style.sheet.cssRules)[0];
              document.body.removeChild(el);
              return ret;
            }
          return false;
        }

        function findFocus(fromFirst) {
          var firstLiElement;
          if(fromFirst) {
            firstLiElement = dropdownMenu.children().eq(0);
          } else {
            firstLiElement = dropdownMenu.children().eq(dropdownMenu.children().length - 1);
          }

          // focus on selected element
          if (supportsSelector(".selected:not(.not-match)")) {
            var match = dropdownMenu[0].querySelector('.selected:not(.not-match)');
              if (match)
                  return match;
          }
          else {
            // Fallback for IE8 users
            for(var i = 0; i < dropdownMenu.children().length; i++) {
              var childElement = dropdownMenu.children().eq(i);
              if (!childElement.hasClass('not-match') && childElement.hasClass('selected')) {
                return dropdownMenu.children().eq(i)[0];
              }
            }
          }

          if(firstLiElement.hasClass('nya-bs-option') && !firstLiElement.hasClass('disabled') && !firstLiElement.hasClass('not-match')) {
            return firstLiElement[0];
          } else {
            if(fromFirst) {
              return findNextFocus(firstLiElement[0], 'nextSibling');
            } else {
              return findNextFocus(firstLiElement[0], 'previousSibling');
            }
          }
        }

        /**
         * find next focusable element on direction
         * @param from the element traversed from
         * @param direction can be 'nextSibling' or 'previousSibling'
         * @returns the element if found, otherwise return null.
         */
        function findNextFocus(from, direction) {
          if(from && !hasClass(from, 'nya-bs-option')) {
            return;
          }
          var next = from;
          while ((next = sibling(next, direction)) && next.nodeType) {
            if(hasClass(next,'nya-bs-option') && !hasClass(next, 'disabled') && !hasClass(next, 'not-match')) {
              return next
            }
          }
          return null;
        }

        /**
         *
         */
        function setAllOptions(selectAll) {
          if (!isMultiple || isDisabled)
            return;

          var liElements,
            wv,
            viewValue;

          liElements = dropdownMenu[0].querySelectorAll('.nya-bs-option');
          if (liElements.length > 0) {
            wv = ngCtrl.$viewValue;

            // make a deep copy enforce ngModelController to call its $render method.
            // See: https://github.com/angular/angular.js/issues/1751
            viewValue = Array.isArray(wv) ? deepCopy(wv) : [];

            for (var i = 0; i < liElements.length; i++) {
              var nyaBsOption = jqLite(liElements[i]);
              if (nyaBsOption.hasClass('disabled') || nyaBsOption.hasClass('not-match'))
                continue;

              var value, index;

              // if user specify the value attribute. we should use the value attribute
              // otherwise, use the valueIdentifier specified field in target scope
              value = getOptionValue(nyaBsOption);

              if (typeof value !== 'undefined') {
                index = indexOf(viewValue, value);
                if (selectAll && index == -1) {
                  // check element
                  viewValue.push(value);
                  nyaBsOption.addClass('selected');
                } else if (!selectAll && index != -1) {
                  // uncheck element
                  viewValue.splice(index, 1);
                  nyaBsOption.removeClass('selected');
                }
              }
            }

            // update view value regardless
            ngCtrl.$setViewValue(viewValue);
            $scope.$digest();

            updateButtonContent();
          }
        }

        /**
         * select an option represented by nyaBsOption argument. Get the option's value and update model.
         * if isMultiple = true, doesn't close dropdown menu. otherwise close the menu.
         * @param nyaBsOption the jqLite wrapped `nya-bs-option` element.
         */
        function selectOption(nyaBsOption) {
          var value,
            viewValue,
            wv = ngCtrl.$viewValue,
            index;
          // if user specify the value attribute. we should use the value attribute
          // otherwise, use the valueIdentifier specified field in target scope

          value = getOptionValue(nyaBsOption);

          if(typeof value !== 'undefined') {
            if(isMultiple) {
              // make a deep copy enforce ngModelController to call its $render method.
              // See: https://github.com/angular/angular.js/issues/1751
              viewValue = Array.isArray(wv) ? deepCopy(wv) : [];
              index = indexOf(viewValue, value);
              if(index === -1) {
                // check element
                viewValue.push(value);
                nyaBsOption.addClass('selected');

              } else {
                // uncheck element
                viewValue.splice(index, 1);
                nyaBsOption.removeClass('selected');

              }

            } else {
              dropdownMenu.children().removeClass('selected');
              viewValue = value;
              nyaBsOption.addClass('selected');

            }
          }
          // update view value regardless
          ngCtrl.$setViewValue(viewValue);
          $scope.$digest();

          if(!isMultiple) {
            // in single selection mode. close the dropdown menu
            if($element.hasClass('open')) {
              $element.triggerHandler('blur');
            }
            $element.removeClass('open');
            dropdownToggle[0].focus();
          }
          updateButtonContent();
        }

        /**
         * get a value of current nyaBsOption. according to different setting.
         * - if `nya-bs-option` directive is used to populate options and a `value` attribute is specified. use expression of the attribute value.
         * - if `nya-bs-option` directive is used to populate options and no other settings, use the valueIdentifier or keyIdentifier to retrieve value from scope of current nyaBsOption.
         * - if `nya-bs-option` class is used on static options. use literal value of the `value` attribute.
         * @param nyaBsOption a jqLite wrapped `nya-bs-option` element
         */
        function getOptionValue(nyaBsOption) {
          var scopeOfOption;
          if(valueExpFn) {
            // here we use the scope bound by ourselves in the nya-bs-option.
            scopeOfOption = nyaBsOption.data('isolateScope');
            return valueExpFn(scopeOfOption);
          } else {
            if(nyaBsSelectCtrl.valueIdentifier || nyaBsSelectCtrl.keyIdentifier) {
              scopeOfOption = nyaBsOption.data('isolateScope');
              return scopeOfOption[nyaBsSelectCtrl.valueIdentifier] || scopeOfOption[nyaBsSelectCtrl.keyIdentifier];
            } else {
              return nyaBsOption.attr('data-value');
            }
          }

        }

        function getOptionText(nyaBsOption) {
          var item = nyaBsOption.find('a');
          if(item.children().length === 0 || item.children().eq(0).hasClass('check-mark')) {
            // if the first child is check-mark or has no children, means the option text is text node
            return item[0].firstChild.cloneNode(false);
          } else {
            // otherwise we clone the first element of the item
            return item.children().eq(0)[0].cloneNode(true);
          }
        }

        function updateButtonContent() {
          var viewValue = ngCtrl.$viewValue;
          $element.triggerHandler('change');

          var filterOption = jqLite(dropdownToggle[0].querySelector('.filter-option'));
          var specialTitle = jqLite(dropdownToggle[0].querySelector('.special-title'));
          if(typeof viewValue === 'undefined' || viewValue === null) {
            /**
             * Select empty option when model is undefined.
             */
            dropdownToggle.addClass('show-special-title');
            filterOption.empty();
            return;
          }
          if(isMultiple && viewValue.length === 0) {
            dropdownToggle.addClass('show-special-title');
            filterOption.empty();
          } else {
            dropdownToggle.removeClass('show-special-title');
            $timeout(function() {

              var bsOptionElements = dropdownMenu.children(),
                value,
                nyaBsOption,
                index,
                length = bsOptionElements.length,
                optionTitle,
                selection = [],
                optionScopes = [],
                match,
                count,
                clone;

              if(isMultiple && $attrs.selectedTextFormat === 'count') {
                count = 1;
              } else if(isMultiple && $attrs.selectedTextFormat && (match = $attrs.selectedTextFormat.match(/\s*count\s*>\s*(\d+)\s*/))) {
                count = parseInt(match[1], 10);
              }

              // data-selected-text-format="count" or data-selected-text-format="count>x"
              if((typeof count !== 'undefined') && viewValue.length > count) {
                filterOption.empty();
                if(localizedText.numberItemSelectedTpl) {
                  filterOption.append(jqLite(localizedText.numberItemSelectedTpl.replace('%d', viewValue.length)));
                } else if(localizedText.numberItemSelected) {
                  filterOption.append(document.createTextNode(localizedText.numberItemSelected.replace('%d', viewValue.length)));
                } else {
                  filterOption.append(document.createTextNode(viewValue.length + ' items selected'));
                }
                return;
              }

              // data-selected-text-format="values" or the number of selected items is less than count
              for(index = 0; index < length; index++) {
                nyaBsOption = bsOptionElements.eq(index);
                if(nyaBsOption.hasClass('nya-bs-option')) {

                  value = getOptionValue(nyaBsOption);

                  if(isMultiple) {
                    if(Array.isArray(viewValue) && contains(viewValue, value)) {
                      // if option has an title attribute. use the title value as content show in button.
                      // otherwise get very first child element.
                      optionTitle = nyaBsOption.attr('title');
                      if(optionTitle) {
                        selection.push(document.createTextNode(optionTitle));
                      } else {
                        selection.push(getOptionText(nyaBsOption));
                        optionScopes.push(nyaBsOption.data('isolateScope'))
                      }

                    }
                  } else {
                    if(deepEquals(viewValue, value)) {
                      optionTitle = nyaBsOption.attr('title');
                      if(optionTitle) {
                        selection.push(document.createTextNode(optionTitle));
                      } else {
                        selection.push(getOptionText(nyaBsOption));
                        optionScopes.push(nyaBsOption.data('isolateScope'))
                      }
                    }
                  }

                }
              }

              if(selection.length === 0) {
                filterOption.empty();
                dropdownToggle.addClass('show-special-title');
              } else if(selection.length === 1) {
                dropdownToggle.removeClass('show-special-title');
                // either single or multiple selection will show the only selected content.
                filterOption.empty();
                // the isolateScope attribute may not set when we use the static version nya-bs-option class with data-value attribute.
                if(optionScopes[0]) {
                  clone = $compile (selection[0])(optionScopes[0]);
                } else {
                  clone = selection[0];
                }
                filterOption.append(clone);
              } else {
                dropdownToggle.removeClass('show-special-title');
                filterOption.empty();
                for(index = 0; index < selection.length; index++) {
                  if(optionScopes[index]) {
                    clone = $compile (selection[index])(optionScopes[index]);
                  } else {
                    clone = selection[index];
                  }
                  filterOption.append(clone);
                  if(index < selection.length -1) {
                    filterOption.append(document.createTextNode(', '));
                  }
                }
              }

            });
          }

        }

        // will called only once.
        function calcMenuSize(){

          var liElements = dropdownMenu.find('li'),
            length = liElements.length,
            liElement,
            i;
          for(i = 0; i < length; i++) {
            liElement = liElements.eq(i);
            if(liElement.hasClass('nya-bs-option') || liElement.attr('nya-bs-option')) {
              liHeight = liElement[0].clientHeight;
              break;
            }
          }

          if(/\d+/.test($attrs.size)) {
            var dropdownSize = parseInt($attrs.size, 10);
            dropdownMenu.css('max-height', (dropdownSize * liHeight) + 'px');
            dropdownMenu.css('overflow-y', 'auto');
          }

        }

        $scope.$on('$destroy', function() {
          dropdownMenu.off();
          dropdownToggle.off();
          if (searchBox.off) searchBox.off();
          $document.off('click', outClick);
          
        });

      };
    }
  };
}]);

nyaBsSelect.directive('nyaBsOption', ['$parse', function($parse){

                        //00000011111111111111100000000022222222222222200000003333333333333330000000000000004444444444000000000000000000055555555550000000000000000000006666666666000000
  var BS_OPTION_REGEX = /^\s*(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/;

  return {
    restrict: 'A',
    transclude: 'element',
    priority: 1000,
    terminal: true,
    require: ['^nyaBsSelect', '^ngModel'],
    compile: function nyaBsOptionCompile (tElement, tAttrs) {

      var expression = tAttrs.nyaBsOption;
      var nyaBsOptionEndComment = document.createComment(' end nyaBsOption: ' + expression + ' ');
      var match = expression.match(BS_OPTION_REGEX);

      if(!match) {
        throw new Error('invalid expression');
      }

      // we want to keep our expression comprehensible so we don't use 'select as label for value in collection' expression.
      var valueExp = tAttrs.value,
        valueExpGetter = valueExp ? $parse(valueExp) : null;

      var valueIdentifier = match[3] || match[1],
        keyIdentifier = match[2],
        collectionExp = match[4],
        groupByExpGetter = match[5] ? $parse(match[5]) : null,
        trackByExp = match[6];

      var trackByIdArrayFn,
        trackByIdObjFn,
        trackByIdExpFn,
        trackByExpGetter;
      var hashFnLocals = {$id: hashKey};
      var groupByFn, locals = {};

      if(trackByExp) {
        trackByExpGetter = $parse(trackByExp);
      } else {
        trackByIdArrayFn = function(key, value) {
          return hashKey(value);
        };
        trackByIdObjFn = function(key) {
          return key;
        };
      }
      return function nyaBsOptionLink($scope, $element, $attr, ctrls, $transclude) {

        var nyaBsSelectCtrl = ctrls[0],
          ngCtrl = ctrls[1],
          valueExpFn,
          deepWatched,
          valueExpLocals = {};

        if(trackByExpGetter) {
          trackByIdExpFn = function(key, value, index) {
            // assign key, value, and $index to the locals so that they can be used in hash functions
            if (keyIdentifier) {
              hashFnLocals[keyIdentifier] = key;
            }
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        }

        if(groupByExpGetter) {
          groupByFn = function(key, value) {
            if(keyIdentifier) {
              locals[keyIdentifier] = key;
            }
            locals[valueIdentifier] = value;
            return groupByExpGetter($scope, locals);
          }
        }

        // set keyIdentifier and valueIdentifier property of nyaBsSelectCtrl
        if(keyIdentifier) {
          nyaBsSelectCtrl.keyIdentifier = keyIdentifier;
        }
        if(valueIdentifier) {
          nyaBsSelectCtrl.valueIdentifier = valueIdentifier;
        }

        if(valueExpGetter) {
          nyaBsSelectCtrl.valueExp = valueExp;
          valueExpFn = function(key, value) {
            if(keyIdentifier) {
              valueExpLocals[keyIdentifier] = key;
            }
            valueExpLocals[valueIdentifier] = value;
            return valueExpGetter($scope, valueExpLocals);
          }

        }


        // Store a list of elements from previous run. This is a hash where key is the item from the
        // iterator, and the value is objects with following properties.
        //   - scope: bound scope
        //   - element: previous element.
        //   - index: position
        //
        // We are using no-proto object so that we don't need to guard against inherited props via
        // hasOwnProperty.
        var lastBlockMap = createMap();

        // deepWatch will impact performance. use with caution.
        if($attr.deepWatch === 'true') {
          deepWatched = true;
          $scope.$watch(collectionExp, nyaBsOptionAction, true);
        } else {
          deepWatched = false;
          $scope.$watchCollection(collectionExp, nyaBsOptionAction);
        }

        function nyaBsOptionAction(collection) {
          var index,

            previousNode = $element[0],     // node that cloned nodes should be inserted after
          // initialized to the comment node anchor

            key, value,
            trackById,
            trackByIdFn,
            collectionKeys,
            collectionLength,
          // Same as lastBlockMap but it has the current state. It will become the
          // lastBlockMap on the next iteration.
            nextBlockMap = createMap(),
            nextBlockOrder,
            block,
            groupName,
            nextNode,
            group,
            lastGroup,

            removedClone, // removed clone node, should also remove isolateScope data as well

            values = [],
            valueObj; // the collection value

          if(groupByFn) {
            group = [];
          }

          if(isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (var itemKey in collection) {
              if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != '$') {
                collectionKeys.push(itemKey);
              }
            }
            collectionKeys.sort();
          }
          collectionLength = collectionKeys.length;
          nextBlockOrder = new Array(collectionLength);

          for(index = 0; index < collectionLength; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn(key, value, index);

            // copy the value with scope like structure to notify the select directive.
            valueObj = {};
            if(keyIdentifier) {
              valueObj[keyIdentifier] = key;
            }

            valueObj[valueIdentifier] = value;
            values.push(valueObj);

            if(groupByFn) {
              groupName = groupByFn(key, value);
              if(group.indexOf(groupName) === -1 && groupName) {
                group.push(groupName);
              }
            }

            if(lastBlockMap[trackById]) {
              // found previously seen block
              block = lastBlockMap[trackById];
              delete lastBlockMap[trackById];

              // must update block here because some data we stored may change.
              if(groupByFn) {
                block.group = groupName;
              }
              block.key = key;
              block.value = value;

              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            } else if(nextBlockMap[trackById]) {
              //if collision detected. restore lastBlockMap and throw an error
              nextBlockOrder.forEach(function(block) {
                if(block && block.scope) {
                  lastBlockMap[block.id] = block;
                }
              });
              throw new Error("Duplicates in a select are not allowed. Use 'track by' expression to specify unique keys.");
            } else {
              // new never before seen block
              nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined, key: key, value: value};
              nextBlockMap[trackById] = true;
              if(groupName) {
                nextBlockOrder[index].group = groupName;
              }
            }
          }

          // only resort nextBlockOrder when group found
          if(group && group.length > 0) {

            nextBlockOrder = sortByGroup(nextBlockOrder, group, 'group');
          }

          // remove DOM nodes
          for( var blockKey in lastBlockMap) {
            block = lastBlockMap[blockKey];
            removedClone = getBlockNodes(block.clone);
            // remove the isolateScope data to detach scope from this clone
            removedClone.removeData('isolateScope');
            removedClone.remove();
            block.scope.$destroy();
          }

          for(index = 0; index < collectionLength; index++) {
            block = nextBlockOrder[index];
            if(block.scope) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element

              nextNode = previousNode;
              if(getBlockStart(block) != nextNode) {
                jqLite(previousNode).after(block.clone);
              }
              previousNode = getBlockEnd(block);

              updateScope(block.scope, index, valueIdentifier, block.value, keyIdentifier, block.key, collectionLength, block.group);
            } else {
              $transclude(function nyaBsOptionTransclude(clone, scope) {
                // in case of the debugInfoEnable is set to false, we have to bind the scope to the clone node.
                setElementIsolateScope(clone, scope);

                block.scope = scope;

                var endNode = nyaBsOptionEndComment.cloneNode(false);
                clone[clone.length++] = endNode;

                jqLite(previousNode).after(clone);

                // add nya-bs-option class
                clone.addClass('nya-bs-option');

                // for newly created item we need to ensure its selected status from the model value.
                if(valueExpFn) {
                  value = valueExpFn(block.key, block.value);
                } else {
                  value = block.value || block.key;
                }

                if(nyaBsSelectCtrl.isMultiple) {
                  if(Array.isArray(ngCtrl.$modelValue) && contains(ngCtrl.$modelValue, value)) {
                    clone.addClass('selected');
                  }
                } else {
                  if(deepEquals(value, ngCtrl.$modelValue)) {
                    clone.addClass('selected');
                  }
                }

                previousNode = endNode;
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                // by a directive with templateUrl when its template arrives.
                block.clone = clone;
                nextBlockMap[block.id] = block;
                updateScope(block.scope, index, valueIdentifier, block.value, keyIdentifier, block.key, collectionLength, block.group);
              });

            }

            // we need to mark the first item of a group
            if(group) {
              if(!lastGroup || lastGroup !== block.group) {
                block.clone.addClass('first-in-group');
              } else {
                block.clone.removeClass('first-in-group');
              }

              lastGroup = block.group;

              // add special class for indent
              block.clone.addClass('group-item');
            }
          }

          lastBlockMap = nextBlockMap;

          nyaBsSelectCtrl.onCollectionChange(values, deepWatched);
        }
      };
    }
  }
}]);


})();
/*!
 * rrule.js - Library for working with recurrence rules for calendar dates.
 * https://github.com/jakubroztocil/rrule
 *
 * Copyright 2010, Jakub Roztocil and Lars Schoning
 * Licenced under the BSD licence.
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 * Based on:
 * python-dateutil - Extensions to the standard Python datetime module.
 * Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
 * Copyright (c) 2012 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 */
/* global module, define */

;(function (root, factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = factory()
  } else if (typeof define === 'function' && define.amd) {
    define([], factory)
  } else {
    root.RRule = factory(root)
    root.RRuleSet = root.RRule.RRuleSet
    root.rrulestr = root.RRule.rrulestr
  }
}(typeof window === 'object' ? window : this, function (root) {
  // =============================================================================
  // Date utilities
  // =============================================================================

  /**
   * General date-related utilities.
   * Also handles several incompatibilities between JavaScript and Python
   *
   */
  var dateutil = {
    MONTH_DAYS: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],

    /**
     * Number of milliseconds of one day
     */
    ONE_DAY: 1000 * 60 * 60 * 24,

    /**
     * @see: <http://docs.python.org/library/datetime.html#datetime.MAXYEAR>
     */
    MAXYEAR: 9999,

    /**
     * Python uses 1-Jan-1 as the base for calculating ordinals but we don't
     * want to confuse the JS engine with milliseconds > Number.MAX_NUMBER,
     * therefore we use 1-Jan-1970 instead
     */
    ORDINAL_BASE: new Date(1970, 0, 1),

    /**
     * Python: MO-SU: 0 - 6
     * JS: SU-SAT 0 - 6
     */
    PY_WEEKDAYS: [6, 0, 1, 2, 3, 4, 5],

    /**
     * py_date.timetuple()[7]
     */
    getYearDay: function (date) {
      var dateNoTime = new Date(
        date.getFullYear(), date.getMonth(), date.getDate())
      return Math.ceil(
        (dateNoTime - new Date(date.getFullYear(), 0, 1)) / dateutil.ONE_DAY) + 1
    },

    isLeapYear: function (year) {
      if (year instanceof Date) year = year.getFullYear()
      return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)
    },

    /**
     * @return {Number} the date's timezone offset in ms
     */
    tzOffset: function (date) {
      return date.getTimezoneOffset() * 60 * 1000
    },

    /**
     * @see: <http://www.mcfedries.com/JavaScript/DaysBetween.asp>
     */
    daysBetween: function (date1, date2) {
      // The number of milliseconds in one day
      // Convert both dates to milliseconds
      var date1_ms = date1.getTime() - dateutil.tzOffset(date1)
      var date2_ms = date2.getTime() - dateutil.tzOffset(date2)
      // Calculate the difference in milliseconds
      var difference_ms = Math.abs(date1_ms - date2_ms)
      // Convert back to days and return
      return Math.round(difference_ms / dateutil.ONE_DAY)
    },

    /**
     * @see: <http://docs.python.org/library/datetime.html#datetime.date.toordinal>
     */
    toOrdinal: function (date) {
      return dateutil.daysBetween(date, dateutil.ORDINAL_BASE)
    },

    /**
     * @see - <http://docs.python.org/library/datetime.html#datetime.date.fromordinal>
     */
    fromOrdinal: function (ordinal) {
      var millisecsFromBase = ordinal * dateutil.ONE_DAY
      return new Date(dateutil.ORDINAL_BASE.getTime() -
        dateutil.tzOffset(dateutil.ORDINAL_BASE) +
        millisecsFromBase +
        dateutil.tzOffset(new Date(millisecsFromBase)))
    },

    /**
     * @see: <http://docs.python.org/library/calendar.html#calendar.monthrange>
     */
    monthRange: function (year, month) {
      var date = new Date(year, month, 1)
      return [dateutil.getWeekday(date), dateutil.getMonthDays(date)]
    },

    getMonthDays: function (date) {
      var month = date.getMonth()
      return month === 1 && dateutil.isLeapYear(date)
        ? 29 : dateutil.MONTH_DAYS[month]
    },

    /**
     * @return {Number} python-like weekday
     */
    getWeekday: function (date) {
      return dateutil.PY_WEEKDAYS[date.getDay()]
    },

    /**
     * @see: <http://docs.python.org/library/datetime.html#datetime.datetime.combine>
     */
    combine: function (date, time) {
      time = time || date
      return new Date(
        date.getFullYear(), date.getMonth(), date.getDate(),
        time.getHours(), time.getMinutes(), time.getSeconds(),
        time.getMilliseconds())
    },

    clone: function (date) {
      var dolly = new Date(date.getTime())
      return dolly
    },

    cloneDates: function (dates) {
      var clones = []
      for (var i = 0; i < dates.length; i++) {
        clones.push(dateutil.clone(dates[i]))
      }
      return clones
    },

    /**
     * Sorts an array of Date or dateutil.Time objects
     */
    sort: function (dates) {
      dates.sort(function (a, b) {
        return a.getTime() - b.getTime()
      })
    },

    timeToUntilString: function (time) {
      var comp
      var date = new Date(time)
      var comps = [
        date.getUTCFullYear(),
        date.getUTCMonth() + 1,
        date.getUTCDate(),
        'T',
        date.getUTCHours(),
        date.getUTCMinutes(),
        date.getUTCSeconds(),
        'Z'
      ]

      for (var i = 0; i < comps.length; i++) {
        comp = comps[i]
        if (!/[TZ]/.test(comp) && comp < 10) comps[i] = '0' + String(comp)
      }
      return comps.join('')
    },

    untilStringToDate: function (until) {
      var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z)?$/
      var bits = re.exec(until)
      if (!bits) throw new Error('Invalid UNTIL value: ' + until)
      return new Date(Date.UTC(
        bits[1],
        bits[2] - 1,
        bits[3],
        bits[5] || 0,
        bits[6] || 0,
        bits[7] || 0))
    }
  }

  dateutil.Time = function (hour, minute, second, millisecond) {
    this.hour = hour
    this.minute = minute
    this.second = second
    this.millisecond = millisecond || 0
  }

  dateutil.Time.prototype = {
    constructor: dateutil.Time,
    getHours: function () {
      return this.hour
    },
    getMinutes: function () {
      return this.minute
    },
    getSeconds: function () {
      return this.second
    },
    getMilliseconds: function () {
      return this.millisecond
    },
    getTime: function () {
      return ((this.hour * 60 * 60) + (this.minute * 60) + this.second) * 1000 +
        this.millisecond
    }
  }

  // =============================================================================
  // Helper functions
  // =============================================================================

  /**
   * Simplified version of python's range()
   */
  var range = function (start, end) {
    if (arguments.length === 1) {
      end = start
      start = 0
    }
    var rang = []
    for (var i = start; i < end; i++) rang.push(i)
    return rang
  }

  var repeat = function (value, times) {
    var i = 0
    var array = []

    if (value instanceof Array) {
      for (; i < times; i++) array[i] = [].concat(value)
    } else {
      for (; i < times; i++) array[i] = value
    }
    return array
  }

  /**
   * Python like split
   */
  var split = function (str, sep, num) {
    var splits = str.split(sep)
    return num
      ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits
  }

  /**
   * closure/goog/math/math.js:modulo
   * Copyright 2006 The Closure Library Authors.
   * The % operator in JavaScript returns the remainder of a / b, but differs from
   * some other languages in that the result will have the same sign as the
   * dividend. For example, -1 % 8 == -1, whereas in some other languages
   * (such as Python) the result would be 7. This function emulates the more
   * correct modulo behavior, which is useful for certain applications such as
   * calculating an offset index in a circular list.
   *
   * @param {number} a The dividend.
   * @param {number} b The divisor.
   * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
   *     or b < x <= 0, depending on the sign of b).
   */
  var pymod = function (a, b) {
    var r = a % b
    // If r and b differ in sign, add b to wrap the result to the correct sign.
    return (r * b < 0) ? r + b : r
  }

  /**
   * @see: <http://docs.python.org/library/functions.html#divmod>
   */
  var divmod = function (a, b) {
    return {div: Math.floor(a / b), mod: pymod(a, b)}
  }

  /**
   * Python-like boolean
   * @return {Boolean} value of an object/primitive, taking into account
   * the fact that in Python an empty list's/tuple's
   * boolean value is False, whereas in JS it's true
   */
  var plb = function (obj) {
    return (obj instanceof Array && obj.length === 0)
      ? false : Boolean(obj)
  }

  /**
   * Return true if a value is in an array
   */
  var contains = function (arr, val) {
    return arr.indexOf(val) !== -1
  }

  // =============================================================================
  // Date masks
  // =============================================================================

  // Every mask is 7 days longer to handle cross-year weekly periods.

  var M365MASK = [].concat(
    repeat(1, 31), repeat(2, 28), repeat(3, 31),
    repeat(4, 30), repeat(5, 31), repeat(6, 30),
    repeat(7, 31), repeat(8, 31), repeat(9, 30),
    repeat(10, 31), repeat(11, 30), repeat(12, 31),
    repeat(1, 7))

  var M366MASK = [].concat(
    repeat(1, 31), repeat(2, 29), repeat(3, 31),
    repeat(4, 30), repeat(5, 31), repeat(6, 30),
    repeat(7, 31), repeat(8, 31), repeat(9, 30),
    repeat(10, 31), repeat(11, 30), repeat(12, 31),
    repeat(1, 7))

  var M28 = range(1, 29)
  var M29 = range(1, 30)
  var M30 = range(1, 31)
  var M31 = range(1, 32)

  var MDAY366MASK = [].concat(
    M31, M29, M31,
    M30, M31, M30,
    M31, M31, M30,
    M31, M30, M31,
    M31.slice(0, 7))

  var MDAY365MASK = [].concat(
    M31, M28, M31,
    M30, M31, M30,
    M31, M31, M30,
    M31, M30, M31,
    M31.slice(0, 7))

  M28 = range(-28, 0)
  M29 = range(-29, 0)
  M30 = range(-30, 0)
  M31 = range(-31, 0)

  var NMDAY366MASK = [].concat(
    M31, M29, M31,
    M30, M31, M30,
    M31, M31, M30,
    M31, M30, M31,
    M31.slice(0, 7))

  var NMDAY365MASK = [].concat(
    M31, M28, M31,
    M30, M31, M30,
    M31, M31, M30,
    M31, M30, M31,
    M31.slice(0, 7))

  var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
  var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]

  var WDAYMASK = (function () {
    for (var wdaymask = [], i = 0; i < 55; i++) wdaymask = wdaymask.concat(range(7))
    return wdaymask
  }())

  // =============================================================================
  // Weekday
  // =============================================================================

  var Weekday = function (weekday, n) {
    if (n === 0) throw new Error("Can't create weekday with n == 0")
    this.weekday = weekday
    this.n = n
  }

  Weekday.prototype = {
    constructor: Weekday,
    // __call__ - Cannot call the object directly, do it through
    // e.g. RRule.TH.nth(-1) instead,
    nth: function (n) {
      return this.n === n ? this : new Weekday(this.weekday, n)
    },

    // __eq__
    equals: function (other) {
      return this.weekday === other.weekday && this.n === other.n
    },

    // __repr__
    toString: function () {
      var s = ['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU'][this.weekday]
      if (this.n) s = (this.n > 0 ? '+' : '') + String(this.n) + s
      return s
    },

    getJsWeekday: function () {
      return this.weekday === 6 ? 0 : this.weekday + 1
    }

  }

  // =============================================================================
  // RRule
  // =============================================================================

  /**
   *
   * @param {Object?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>
   *        The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...
   * @constructor
   */
  var RRule = function (options, noCache) {
    options = options || {}
    // RFC string
    this._string = null
    this._cache = noCache ? null : {
      all: false,
      before: [],
      after: [],
      between: []
    }

    // used by toString()
    this.origOptions = {}

    var invalid = []
    var keys = Object.keys(options)
    var defaultKeys = Object.keys(RRule.DEFAULT_OPTIONS)

    // Shallow copy for origOptions and check for invalid
    keys.forEach(function (key) {
      this.origOptions[key] = options[key]
      if (!contains(defaultKeys, key)) invalid.push(key)
    }, this)

    if (invalid.length) throw new Error('Invalid options: ' + invalid.join(', '))

    if (!RRule.FREQUENCIES[options.freq] && options.byeaster === null) {
      throw new Error('Invalid frequency: ' + String(options.freq))
    }

    // Merge in default options
    defaultKeys.forEach(function (key) {
      if (!contains(keys, key)) options[key] = RRule.DEFAULT_OPTIONS[key]
    })

    var opts = this.options = options

    if (opts.byeaster !== null) opts.freq = RRule.YEARLY
    if (!opts.dtstart) opts.dtstart = new Date()

    var millisecondModulo = opts.dtstart.getTime() % 1000
    if (opts.wkst === null) {
      opts.wkst = RRule.MO.weekday
    } else if (typeof opts.wkst === 'number') {
      // cool, just keep it like that
    } else {
      opts.wkst = opts.wkst.weekday
    }

    if (opts.bysetpos !== null) {
      if (typeof opts.bysetpos === 'number') opts.bysetpos = [opts.bysetpos]

      for (var i = 0; i < opts.bysetpos.length; i++) {
        var v = opts.bysetpos[i]
        if (v === 0 || !(v >= -366 && v <= 366)) {
          throw new Error('bysetpos must be between 1 and 366,' +
            ' or between -366 and -1')
        }
      }
    }

    if (!(plb(opts.byweekno) || plb(opts.byyearday) || plb(opts.bymonthday) ||
      opts.byweekday !== null || opts.byeaster !== null)) {
      switch (opts.freq) {
        case RRule.YEARLY:
          if (!opts.bymonth) opts.bymonth = opts.dtstart.getMonth() + 1
          opts.bymonthday = opts.dtstart.getDate()
          break
        case RRule.MONTHLY:
          opts.bymonthday = opts.dtstart.getDate()
          break
        case RRule.WEEKLY:
          opts.byweekday = dateutil.getWeekday(opts.dtstart)
          break
      }
    }

    // bymonth
    if (opts.bymonth !== null && !(opts.bymonth instanceof Array)) {
      opts.bymonth = [opts.bymonth]
    }
    // byyearday
    if (opts.byyearday !== null && !(opts.byyearday instanceof Array)) {
      opts.byyearday = [opts.byyearday]
    }

    // bymonthday
    if (opts.bymonthday === null) {
      opts.bymonthday = []
      opts.bynmonthday = []
    } else if (opts.bymonthday instanceof Array) {
      var bymonthday = []
      var bynmonthday = []

      for (i = 0; i < opts.bymonthday.length; i++) {
        v = opts.bymonthday[i]
        if (v > 0) {
          bymonthday.push(v)
        } else if (v < 0) {
          bynmonthday.push(v)
        }
      }
      opts.bymonthday = bymonthday
      opts.bynmonthday = bynmonthday
    } else {
      if (opts.bymonthday < 0) {
        opts.bynmonthday = [opts.bymonthday]
        opts.bymonthday = []
      } else {
        opts.bynmonthday = []
        opts.bymonthday = [opts.bymonthday]
      }
    }

    // byweekno
    if (opts.byweekno !== null && !(opts.byweekno instanceof Array)) {
      opts.byweekno = [opts.byweekno]
    }

    // byweekday / bynweekday
    if (opts.byweekday === null) {
      opts.bynweekday = null
    } else if (typeof opts.byweekday === 'number') {
      opts.byweekday = [opts.byweekday]
      opts.bynweekday = null
    } else if (opts.byweekday instanceof Weekday) {
      if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
        opts.byweekday = [opts.byweekday.weekday]
        opts.bynweekday = null
      } else {
        opts.bynweekday = [
          [opts.byweekday.weekday, opts.byweekday.n]
        ]
        opts.byweekday = null
      }
    } else {
      var byweekday = []
      var bynweekday = []

      for (i = 0; i < opts.byweekday.length; i++) {
        var wday = opts.byweekday[i]

        if (typeof wday === 'number') {
          byweekday.push(wday)
        } else if (!wday.n || opts.freq > RRule.MONTHLY) {
          byweekday.push(wday.weekday)
        } else {
          bynweekday.push([wday.weekday, wday.n])
        }
      }
      opts.byweekday = plb(byweekday) ? byweekday : null
      opts.bynweekday = plb(bynweekday) ? bynweekday : null
    }

    // byhour
    if (opts.byhour === null) {
      opts.byhour = (opts.freq < RRule.HOURLY) ? [opts.dtstart.getHours()] : null
    } else if (typeof opts.byhour === 'number') {
      opts.byhour = [opts.byhour]
    }

    // byminute
    if (opts.byminute === null) {
      opts.byminute = (opts.freq < RRule.MINUTELY)
        ? [opts.dtstart.getMinutes()] : null
    } else if (typeof opts.byminute === 'number') {
      opts.byminute = [opts.byminute]
    }

    // bysecond
    if (opts.bysecond === null) {
      opts.bysecond = (opts.freq < RRule.SECONDLY)
        ? [opts.dtstart.getSeconds()] : null
    } else if (typeof opts.bysecond === 'number') {
      opts.bysecond = [opts.bysecond]
    }

    if (opts.freq >= RRule.HOURLY) {
      this.timeset = null
    } else {
      this.timeset = []
      for (i = 0; i < opts.byhour.length; i++) {
        var hour = opts.byhour[i]
        for (var j = 0; j < opts.byminute.length; j++) {
          var minute = opts.byminute[j]
          for (var k = 0; k < opts.bysecond.length; k++) {
            var second = opts.bysecond[k]
            // python:
            // datetime.time(hour, minute, second,
            // tzinfo=self._tzinfo))
            this.timeset.push(new dateutil.Time(hour, minute, second, millisecondModulo))
          }
        }
      }
      dateutil.sort(this.timeset)
    }
  }

  // RRule class 'constants'

  RRule.FREQUENCIES = [
    'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',
    'HOURLY', 'MINUTELY', 'SECONDLY'
  ]

  RRule.YEARLY = 0
  RRule.MONTHLY = 1
  RRule.WEEKLY = 2
  RRule.DAILY = 3
  RRule.HOURLY = 4
  RRule.MINUTELY = 5
  RRule.SECONDLY = 6

  RRule.MO = new Weekday(0)
  RRule.TU = new Weekday(1)
  RRule.WE = new Weekday(2)
  RRule.TH = new Weekday(3)
  RRule.FR = new Weekday(4)
  RRule.SA = new Weekday(5)
  RRule.SU = new Weekday(6)

  RRule.DEFAULT_OPTIONS = {
    freq: null,
    dtstart: null,
    interval: 1,
    wkst: RRule.MO,
    count: null,
    until: null,
    bysetpos: null,
    bymonth: null,
    bymonthday: null,
    bynmonthday: null,
    byyearday: null,
    byweekno: null,
    byweekday: null,
    bynweekday: null,
    byhour: null,
    byminute: null,
    bysecond: null,
    byeaster: null
  }

  RRule.parseText = function (text, language) {
    return getnlp().parseText(text, language)
  }

  RRule.fromText = function (text, language) {
    return getnlp().fromText(text, language)
  }

  RRule.optionsToString = function (options) {
    var key, value, strValues
    var pairs = []
    var keys = Object.keys(options)
    var defaultKeys = Object.keys(RRule.DEFAULT_OPTIONS)

    for (var i = 0; i < keys.length; i++) {
      if (!contains(defaultKeys, keys[i])) continue

      key = keys[i].toUpperCase()
      value = options[keys[i]]
      strValues = []

      if (value === null || value instanceof Array && !value.length) continue

      switch (key) {
        case 'FREQ':
          value = RRule.FREQUENCIES[options.freq]
          break
        case 'WKST':
          value = value.toString()
          break
        case 'BYWEEKDAY':
          /*
          NOTE: BYWEEKDAY is a special case.
          RRule() deconstructs the rule.options.byweekday array
          into an array of Weekday arguments.
          On the other hand, rule.origOptions is an array of Weekdays.
          We need to handle both cases here.
          It might be worth change RRule to keep the Weekdays.

          Also, BYWEEKDAY (used by RRule) vs. BYDAY (RFC)

          */
          key = 'BYDAY'
          if (!(value instanceof Array)) value = [value]

          for (var wday, j = 0; j < value.length; j++) {
            wday = value[j]
            if (wday instanceof Weekday) {
              // good
            } else if (wday instanceof Array) {
              wday = new Weekday(wday[0], wday[1])
            } else {
              wday = new Weekday(wday)
            }
            strValues[j] = wday.toString()
          }
          value = strValues
          break
        case 'DTSTART':
        case 'UNTIL':
          value = dateutil.timeToUntilString(value)
          break
        default:
          if (value instanceof Array) {
            for (j = 0; j < value.length; j++) strValues[j] = String(value[j])
            value = strValues
          } else {
            value = String(value)
          }

      }
      pairs.push([key, value])
    }

    var strings = []
    for (i = 0; i < pairs.length; i++) {
      var attr = pairs[i]
      strings.push(attr[0] + '=' + attr[1].toString())
    }
    return strings.join(';')
  }

  RRule.prototype = {
    constructor: RRule,

    /**
     * @param {Function} iterator - optional function that will be called
     *                   on each date that is added. It can return false
     *                   to stop the iteration.
     * @return Array containing all recurrences.
     */
    all: function (iterator) {
      if (iterator) {
        return this._iter(new CallbackIterResult('all', {}, iterator))
      } else {
        var result = this._cacheGet('all')
        if (result === false) {
          result = this._iter(new IterResult('all', {}))
          this._cacheAdd('all', result)
        }
        return result
      }
    },

    /**
     * Returns all the occurrences of the rrule between after and before.
     * The inc keyword defines what happens if after and/or before are
     * themselves occurrences. With inc == True, they will be included in the
     * list, if they are found in the recurrence set.
     * @return Array
     */
    between: function (after, before, inc, iterator) {
      var args = {
        before: before,
        after: after,
        inc: inc
      }

      if (iterator) {
        return this._iter(new CallbackIterResult('between', args, iterator))
      }
      var result = this._cacheGet('between', args)
      if (result === false) {
        result = this._iter(new IterResult('between', args))
        this._cacheAdd('between', result, args)
      }
      return result
    },

    /**
     * Returns the last recurrence before the given datetime instance.
     * The inc keyword defines what happens if dt is an occurrence.
     * With inc == True, if dt itself is an occurrence, it will be returned.
     * @return Date or null
     */
    before: function (dt, inc) {
      var args = {dt: dt, inc: inc}
      var result = this._cacheGet('before', args)
      if (result === false) {
        result = this._iter(new IterResult('before', args))
        this._cacheAdd('before', result, args)
      }
      return result
    },

    /**
     * Returns the first recurrence after the given datetime instance.
     * The inc keyword defines what happens if dt is an occurrence.
     * With inc == True, if dt itself is an occurrence, it will be returned.
     * @return Date or null
     */
    after: function (dt, inc) {
      var args = {dt: dt, inc: inc}
      var result = this._cacheGet('after', args)
      if (result === false) {
        result = this._iter(new IterResult('after', args))
        this._cacheAdd('after', result, args)
      }
      return result
    },

    /**
     * Returns the number of recurrences in this set. It will have go trough
     * the whole recurrence, if this hasn't been done before.
     */
    count: function () {
      return this.all().length
    },

    /**
     * Converts the rrule into its string representation
     * @see <http://www.ietf.org/rfc/rfc2445.txt>
     * @return String
     */
    toString: function () {
      return RRule.optionsToString(this.origOptions)
    },

    /**
    * Will convert all rules described in nlp:ToText
    * to text.
    */
    toText: function (gettext, language) {
      return getnlp().toText(this, gettext, language)
    },

    isFullyConvertibleToText: function () {
      return getnlp().isFullyConvertible(this)
    },

    /**
     * @param {String} what - all/before/after/between
     * @param {Array,Date} value - an array of dates, one date, or null
     * @param {Object?} args - _iter arguments
     */
    _cacheAdd: function (what, value, args) {
      if (!this._cache) return

      if (value) {
        value = (value instanceof Date)
          ? dateutil.clone(value) : dateutil.cloneDates(value)
      }

      if (what === 'all') {
        this._cache.all = value
      } else {
        args._value = value
        this._cache[what].push(args)
      }
    },

    /**
     * @return false - not in the cache
     *         null  - cached, but zero occurrences (before/after)
     *         Date  - cached (before/after)
     *         []    - cached, but zero occurrences (all/between)
     *         [Date1, DateN] - cached (all/between)
     */
    _cacheGet: function (what, args) {
      if (!this._cache) return false

      var cached = false
      var argsKeys = args ? Object.keys(args) : []
      var findCacheDiff = function (item) {
        for (var key, i = 0; i < argsKeys.length; i++) {
          key = argsKeys[i]
          if (String(args[key]) !== String(item[key])) return true
        }
        return false
      }

      if (what === 'all') {
        cached = this._cache.all
      } else {
        // Let's see whether we've already called the
        // 'what' method with the same 'args'
        for (var item, i = 0; i < this._cache[what].length; i++) {
          item = this._cache[what][i]
          if (argsKeys.length && findCacheDiff(item)) continue
          cached = item._value
          break
        }
      }

      if (!cached && this._cache.all) {
        // Not in the cache, but we already know all the occurrences,
        // so we can find the correct dates from the cached ones.
        var iterResult = new IterResult(what, args)
        for (i = 0; i < this._cache.all.length; i++) {
          if (!iterResult.accept(this._cache.all[i])) break
        }
        cached = iterResult.getValue()
        this._cacheAdd(what, cached, args)
      }

      return cached instanceof Array
        ? dateutil.cloneDates(cached)
        : (cached instanceof Date ? dateutil.clone(cached) : cached)
    },

    /**
     * @return a RRule instance with the same freq and options
     *          as this one (cache is not cloned)
     */
    clone: function () {
      return new RRule(this.origOptions)
    },

    _iter: function (iterResult) {
      /* Since JavaScript doesn't have the python's yield operator (<1.7),
         we use the IterResult object that tells us when to stop iterating.

      */

      var dtstart = this.options.dtstart
      var dtstartMillisecondModulo = this.options.dtstart % 1000

      var year = dtstart.getFullYear()
      var month = dtstart.getMonth() + 1
      var day = dtstart.getDate()
      var hour = dtstart.getHours()
      var minute = dtstart.getMinutes()
      var second = dtstart.getSeconds()
      var weekday = dateutil.getWeekday(dtstart)

      // Some local variables to speed things up a bit
      var freq = this.options.freq
      var interval = this.options.interval
      var wkst = this.options.wkst
      var until = this.options.until
      var bymonth = this.options.bymonth
      var byweekno = this.options.byweekno
      var byyearday = this.options.byyearday
      var byweekday = this.options.byweekday
      var byeaster = this.options.byeaster
      var bymonthday = this.options.bymonthday
      var bynmonthday = this.options.bynmonthday
      var bysetpos = this.options.bysetpos
      var byhour = this.options.byhour
      var byminute = this.options.byminute
      var bysecond = this.options.bysecond

      var ii = new Iterinfo(this)
      ii.rebuild(year, month)

      var getdayset = {}
      getdayset[RRule.YEARLY] = ii.ydayset
      getdayset[RRule.MONTHLY] = ii.mdayset
      getdayset[RRule.WEEKLY] = ii.wdayset
      getdayset[RRule.DAILY] = ii.ddayset
      getdayset[RRule.HOURLY] = ii.ddayset
      getdayset[RRule.MINUTELY] = ii.ddayset
      getdayset[RRule.SECONDLY] = ii.ddayset

      getdayset = getdayset[freq]

      var timeset
      if (freq < RRule.HOURLY) {
        timeset = this.timeset
      } else {
        var gettimeset = {}
        gettimeset[RRule.HOURLY] = ii.htimeset
        gettimeset[RRule.MINUTELY] = ii.mtimeset
        gettimeset[RRule.SECONDLY] = ii.stimeset
        gettimeset = gettimeset[freq]
        if ((freq >= RRule.HOURLY && plb(byhour) && !contains(byhour, hour)) ||
          (freq >= RRule.MINUTELY && plb(byminute) && !contains(byminute, minute)) ||
          (freq >= RRule.SECONDLY && plb(bysecond) && !contains(bysecond, minute))) {
          timeset = []
        } else {
          timeset = gettimeset.call(ii, hour, minute, second, dtstartMillisecondModulo)
        }
      }

      var total = 0
      var count = this.options.count
      var i, j, k, dm, div, mod, tmp, pos, dayset, start, end, fixday, filtered

      while (true) {
        // Get dayset with the right frequency
        tmp = getdayset.call(ii, year, month, day)
        dayset = tmp[0]
        start = tmp[1]
        end = tmp[2]

        // Do the "hard" work ;-)
        filtered = false
        for (j = start; j < end; j++) {
          i = dayset[j]

          filtered = (plb(bymonth) && !contains(bymonth, ii.mmask[i])) ||
            (plb(byweekno) && !ii.wnomask[i]) ||
            (plb(byweekday) && !contains(byweekday, ii.wdaymask[i])) ||
            (plb(ii.nwdaymask) && !ii.nwdaymask[i]) ||
            (byeaster !== null && !contains(ii.eastermask, i)) ||
            ((plb(bymonthday) || plb(bynmonthday)) &&
              !contains(bymonthday, ii.mdaymask[i]) &&
              !contains(bynmonthday, ii.nmdaymask[i])) ||
            (plb(byyearday) &&
              ((i < ii.yearlen &&
                !contains(byyearday, i + 1) &&
                !contains(byyearday, -ii.yearlen + i)) ||
              (i >= ii.yearlen &&
                !contains(byyearday, i + 1 - ii.yearlen) &&
                !contains(byyearday, -ii.nextyearlen + i - ii.yearlen))))

          if (filtered) dayset[i] = null
        }

        // Output results
        if (plb(bysetpos) && plb(timeset)) {
          var daypos, timepos
          var poslist = []

          for (i, j = 0; j < bysetpos.length; j++) {
            pos = bysetpos[j]

            if (pos < 0) {
              daypos = Math.floor(pos / timeset.length)
              timepos = pymod(pos, timeset.length)
            } else {
              daypos = Math.floor((pos - 1) / timeset.length)
              timepos = pymod((pos - 1), timeset.length)
            }

            try {
              tmp = []
              for (k = start; k < end; k++) {
                var val = dayset[k]
                if (val === null) continue
                tmp.push(val)
              }
              if (daypos < 0) {
                // we're trying to emulate python's aList[-n]
                i = tmp.slice(daypos)[0]
              } else {
                i = tmp[daypos]
              }

              var time = timeset[timepos]
              var date = dateutil.fromOrdinal(ii.yearordinal + i)
              var res = dateutil.combine(date, time)
              // XXX: can this ever be in the array?
              // - compare the actual date instead?
              if (!contains(poslist, res)) poslist.push(res)
            } catch (e) {}
          }

          dateutil.sort(poslist)
          for (j = 0; j < poslist.length; j++) {
            res = poslist[j]
            if (until && res > until) {
              this._len = total
              return iterResult.getValue()
            } else if (res >= dtstart) {
              ++total
              if (!iterResult.accept(res)) return iterResult.getValue()
              if (count) {
                --count
                if (!count) {
                  this._len = total
                  return iterResult.getValue()
                }
              }
            }
          }
        } else {
          for (j = start; j < end; j++) {
            i = dayset[j]
            if (i !== null) {
              date = dateutil.fromOrdinal(ii.yearordinal + i)
              for (k = 0; k < timeset.length; k++) {
                time = timeset[k]
                res = dateutil.combine(date, time)
                if (until && res > until) {
                  this._len = total
                  return iterResult.getValue()
                } else if (res >= dtstart) {
                  ++total
                  if (!iterResult.accept(res)) return iterResult.getValue()
                  if (count) {
                    --count
                    if (!count) {
                      this._len = total
                      return iterResult.getValue()
                    }
                  }
                }
              }
            }
          }
        }

        // Handle frequency and interval
        fixday = false
        if (freq === RRule.YEARLY) {
          year += interval
          if (year > dateutil.MAXYEAR) {
            this._len = total
            return iterResult.getValue()
          }
          ii.rebuild(year, month)
        } else if (freq === RRule.MONTHLY) {
          month += interval
          if (month > 12) {
            div = Math.floor(month / 12)
            mod = pymod(month, 12)
            month = mod
            year += div
            if (month === 0) {
              month = 12
              --year
            }
            if (year > dateutil.MAXYEAR) {
              this._len = total
              return iterResult.getValue()
            }
          }
          ii.rebuild(year, month)
        } else if (freq === RRule.WEEKLY) {
          if (wkst > weekday) {
            day += -(weekday + 1 + (6 - wkst)) + interval * 7
          } else {
            day += -(weekday - wkst) + interval * 7
          }
          weekday = wkst
          fixday = true
        } else if (freq === RRule.DAILY) {
          day += interval
          fixday = true
        } else if (freq === RRule.HOURLY) {
          if (filtered) {
            // Jump to one iteration before next day
            hour += Math.floor((23 - hour) / interval) * interval
          }
          while (true) {
            hour += interval
            dm = divmod(hour, 24)
            div = dm.div
            mod = dm.mod
            if (div) {
              hour = mod
              day += div
              fixday = true
            }
            if (!plb(byhour) || contains(byhour, hour)) break
          }
          timeset = gettimeset.call(ii, hour, minute, second)
        } else if (freq === RRule.MINUTELY) {
          if (filtered) {
            // Jump to one iteration before next day
            minute += Math.floor(
              (1439 - (hour * 60 + minute)) / interval) * interval
          }

          while (true) {
            minute += interval
            dm = divmod(minute, 60)
            div = dm.div
            mod = dm.mod
            if (div) {
              minute = mod
              hour += div
              dm = divmod(hour, 24)
              div = dm.div
              mod = dm.mod
              if (div) {
                hour = mod
                day += div
                fixday = true
                filtered = false
              }
            }
            if ((!plb(byhour) || contains(byhour, hour)) &&
              (!plb(byminute) || contains(byminute, minute))) {
              break
            }
          }
          timeset = gettimeset.call(ii, hour, minute, second)
        } else if (freq === RRule.SECONDLY) {
          if (filtered) {
            // Jump to one iteration before next day
            second += Math.floor(
                (86399 - (hour * 3600 + minute * 60 + second)) / interval) * interval
          }
          while (true) {
            second += interval
            dm = divmod(second, 60)
            div = dm.div
            mod = dm.mod
            if (div) {
              second = mod
              minute += div
              dm = divmod(minute, 60)
              div = dm.div
              mod = dm.mod
              if (div) {
                minute = mod
                hour += div
                dm = divmod(hour, 24)
                div = dm.div
                mod = dm.mod
                if (div) {
                  hour = mod
                  day += div
                  fixday = true
                }
              }
            }
            if ((!plb(byhour) || contains(byhour, hour)) &&
              (!plb(byminute) || contains(byminute, minute)) &&
              (!plb(bysecond) || contains(bysecond, second))) {
              break
            }
          }
          timeset = gettimeset.call(ii, hour, minute, second)
        }

        if (fixday && day > 28) {
          var daysinmonth = dateutil.monthRange(year, month - 1)[1]
          if (day > daysinmonth) {
            while (day > daysinmonth) {
              day -= daysinmonth
              ++month
              if (month === 13) {
                month = 1
                ++year
                if (year > dateutil.MAXYEAR) {
                  this._len = total
                  return iterResult.getValue()
                }
              }
              daysinmonth = dateutil.monthRange(year, month - 1)[1]
            }
            ii.rebuild(year, month)
          }
        }
      }
    }

  }

  RRule.parseString = function (rfcString) {
    rfcString = rfcString.replace(/^\s+|\s+$/, '')
    if (!rfcString.length) return null

    var i, j, key, value, attr
    var attrs = rfcString.split(';')
    var options = {}

    for (i = 0; i < attrs.length; i++) {
      attr = attrs[i].split('=')
      key = attr[0]
      value = attr[1]
      switch (key) {
        case 'FREQ':
          options.freq = RRule[value]
          break
        case 'WKST':
          options.wkst = RRule[value]
          break
        case 'COUNT':
        case 'INTERVAL':
        case 'BYSETPOS':
        case 'BYMONTH':
        case 'BYMONTHDAY':
        case 'BYYEARDAY':
        case 'BYWEEKNO':
        case 'BYHOUR':
        case 'BYMINUTE':
        case 'BYSECOND':
          if (value.indexOf(',') !== -1) {
            value = value.split(',')
            for (j = 0; j < value.length; j++) {
              if (/^[+-]?\d+$/.test(value[j])) value[j] = Number(value[j])
            }
          } else if (/^[+-]?\d+$/.test(value)) {
            value = Number(value)
          }
          key = key.toLowerCase()
          options[key] = value
          break
        case 'BYDAY': // => byweekday
          var n, wday, day
          var days = value.split(',')

          options.byweekday = []
          for (j = 0; j < days.length; j++) {
            day = days[j]
            if (day.length === 2) { // MO, TU, ...
              wday = RRule[day] // wday instanceof Weekday
              options.byweekday.push(wday)
            } else { // -1MO, +3FR, 1SO, ...
              day = day.match(/^([+-]?\d)([A-Z]{2})$/)
              n = Number(day[1])
              wday = day[2]
              wday = RRule[wday].weekday
              options.byweekday.push(new Weekday(wday, n))
            }
          }
          break
        case 'DTSTART':
          options.dtstart = dateutil.untilStringToDate(value)
          break
        case 'UNTIL':
          options.until = dateutil.untilStringToDate(value)
          break
        case 'BYEASTER':
          options.byeaster = Number(value)
          break
        default:
          throw new Error("Unknown RRULE property '" + key + "'")
      }
    }
    return options
  }

  RRule.fromString = function (string) {
    return new RRule(RRule.parseString(string))
  }

  // =============================================================================
  // Iterinfo
  // =============================================================================

  var Iterinfo = function (rrule) {
    this.rrule = rrule
    this.lastyear = null
    this.lastmonth = null
    this.yearlen = null
    this.nextyearlen = null
    this.yearordinal = null
    this.yearweekday = null
    this.mmask = null
    this.mrange = null
    this.mdaymask = null
    this.nmdaymask = null
    this.wdaymask = null
    this.wnomask = null
    this.nwdaymask = null
    this.eastermask = null
  }

  Iterinfo.prototype.easter = function (y, offset) {
    offset = offset || 0

    var a = y % 19
    var b = Math.floor(y / 100)
    var c = y % 100
    var d = Math.floor(b / 4)
    var e = b % 4
    var f = Math.floor((b + 8) / 25)
    var g = Math.floor((b - f + 1) / 3)
    var h = Math.floor(19 * a + b - d - g + 15) % 30
    var i = Math.floor(c / 4)
    var k = c % 4
    var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7
    var m = Math.floor((a + 11 * h + 22 * l) / 451)
    var month = Math.floor((h + l - 7 * m + 114) / 31)
    var day = (h + l - 7 * m + 114) % 31 + 1
    var date = Date.UTC(y, month - 1, day + offset)
    var yearStart = Date.UTC(y, 0, 1)

    return [Math.ceil((date - yearStart) / (1000 * 60 * 60 * 24))]
  }

  Iterinfo.prototype.rebuild = function (year, month) {
    var rr = this.rrule

    if (year !== this.lastyear) {
      this.yearlen = dateutil.isLeapYear(year) ? 366 : 365
      this.nextyearlen = dateutil.isLeapYear(year + 1) ? 366 : 365
      var firstyday = new Date(year, 0, 1)

      this.yearordinal = dateutil.toOrdinal(firstyday)
      this.yearweekday = dateutil.getWeekday(firstyday)

      var wday = dateutil.getWeekday(new Date(year, 0, 1))

      if (this.yearlen === 365) {
        this.mmask = [].concat(M365MASK)
        this.mdaymask = [].concat(MDAY365MASK)
        this.nmdaymask = [].concat(NMDAY365MASK)
        this.wdaymask = WDAYMASK.slice(wday)
        this.mrange = [].concat(M365RANGE)
      } else {
        this.mmask = [].concat(M366MASK)
        this.mdaymask = [].concat(MDAY366MASK)
        this.nmdaymask = [].concat(NMDAY366MASK)
        this.wdaymask = WDAYMASK.slice(wday)
        this.mrange = [].concat(M366RANGE)
      }

      if (!plb(rr.options.byweekno)) {
        this.wnomask = null
      } else {
        this.wnomask = repeat(0, this.yearlen + 7)
        var no1wkst, firstwkst, wyearlen
        no1wkst = firstwkst = pymod(7 - this.yearweekday + rr.options.wkst, 7)
        if (no1wkst >= 4) {
          no1wkst = 0
          // Number of days in the year, plus the days we got
          // from last year.
          wyearlen = this.yearlen + pymod(this.yearweekday - rr.options.wkst, 7)
        } else {
          // Number of days in the year, minus the days we
          // left in last year.
          wyearlen = this.yearlen - no1wkst
        }
        var div = Math.floor(wyearlen / 7)
        var mod = pymod(wyearlen, 7)
        var numweeks = Math.floor(div + (mod / 4))
        for (var n, i, j = 0; j < rr.options.byweekno.length; j++) {
          n = rr.options.byweekno[j]
          if (n < 0) {
            n += numweeks + 1
          } if (!(n > 0 && n <= numweeks)) {
            continue
          } if (n > 1) {
            i = no1wkst + (n - 1) * 7
            if (no1wkst !== firstwkst) {
              i -= 7 - firstwkst
            }
          } else {
            i = no1wkst
          }
          for (var k = 0; k < 7; k++) {
            this.wnomask[i] = 1
            i++
            if (this.wdaymask[i] === rr.options.wkst) break
          }
        }

        if (contains(rr.options.byweekno, 1)) {
          // Check week number 1 of next year as well
          // orig-TODO : Check -numweeks for next year.
          i = no1wkst + numweeks * 7
          if (no1wkst !== firstwkst) i -= 7 - firstwkst
          if (i < this.yearlen) {
            // If week starts in next year, we
            // don't care about it.
            for (j = 0; j < 7; j++) {
              this.wnomask[i] = 1
              i += 1
              if (this.wdaymask[i] === rr.options.wkst) break
            }
          }
        }

        if (no1wkst) {
          // Check last week number of last year as
          // well. If no1wkst is 0, either the year
          // started on week start, or week number 1
          // got days from last year, so there are no
          // days from last year's last week number in
          // this year.
          var lnumweeks
          if (!contains(rr.options.byweekno, -1)) {
            var lyearweekday = dateutil.getWeekday(new Date(year - 1, 0, 1))
            var lno1wkst = pymod(7 - lyearweekday + rr.options.wkst, 7)
            var lyearlen = dateutil.isLeapYear(year - 1) ? 366 : 365
            if (lno1wkst >= 4) {
              lno1wkst = 0
              lnumweeks = Math.floor(52 +
                pymod(lyearlen + pymod(lyearweekday - rr.options.wkst, 7), 7) / 4)
            } else {
              lnumweeks = Math.floor(52 + pymod(this.yearlen - no1wkst, 7) / 4)
            }
          } else {
            lnumweeks = -1
          }
          if (contains(rr.options.byweekno, lnumweeks)) {
            for (i = 0; i < no1wkst; i++) this.wnomask[i] = 1
          }
        }
      }
    }

    if (plb(rr.options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
      var ranges = []
      if (rr.options.freq === RRule.YEARLY) {
        if (plb(rr.options.bymonth)) {
          for (j = 0; j < rr.options.bymonth.length; j++) {
            month = rr.options.bymonth[j]
            ranges.push(this.mrange.slice(month - 1, month + 1))
          }
        } else {
          ranges = [[0, this.yearlen]]
        }
      } else if (rr.options.freq === RRule.MONTHLY) {
        ranges = [this.mrange.slice(month - 1, month + 1)]
      }
      if (plb(ranges)) {
        // Weekly frequency won't get here, so we may not
        // care about cross-year weekly periods.
        this.nwdaymask = repeat(0, this.yearlen)

        for (j = 0; j < ranges.length; j++) {
          var rang = ranges[j]
          var first = rang[0]
          var last = rang[1]
          last -= 1
          for (k = 0; k < rr.options.bynweekday.length; k++) {
            wday = rr.options.bynweekday[k][0]
            n = rr.options.bynweekday[k][1]
            if (n < 0) {
              i = last + (n + 1) * 7
              i -= pymod(this.wdaymask[i] - wday, 7)
            } else {
              i = first + (n - 1) * 7
              i += pymod(7 - this.wdaymask[i] + wday, 7)
            }
            if (first <= i && i <= last) this.nwdaymask[i] = 1
          }
        }
      }

      this.lastyear = year
      this.lastmonth = month
    }

    if (rr.options.byeaster !== null) {
      this.eastermask = this.easter(year, rr.options.byeaster)
    }
  }

  Iterinfo.prototype.ydayset = function (year, month, day) {
    return [range(this.yearlen), 0, this.yearlen]
  }

  Iterinfo.prototype.mdayset = function (year, month, day) {
    var set = repeat(null, this.yearlen)
    var start = this.mrange[month - 1]
    var end = this.mrange[month]
    for (var i = start; i < end; i++) set[i] = i
    return [set, start, end]
  }

  Iterinfo.prototype.wdayset = function (year, month, day) {
    // We need to handle cross-year weeks here.
    var set = repeat(null, this.yearlen + 7)
    var i = dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal
    var start = i
    for (var j = 0; j < 7; j++) {
      set[i] = i
      ++i
      if (this.wdaymask[i] === this.rrule.options.wkst) break
    }
    return [set, start, i]
  }

  Iterinfo.prototype.ddayset = function (year, month, day) {
    var set = repeat(null, this.yearlen)
    var i = dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal
    set[i] = i
    return [set, i, i + 1]
  }

  Iterinfo.prototype.htimeset = function (hour, minute, second, millisecond) {
    var set = []
    var rr = this.rrule
    for (var i = 0; i < rr.options.byminute.length; i++) {
      minute = rr.options.byminute[i]
      for (var j = 0; j < rr.options.bysecond.length; j++) {
        second = rr.options.bysecond[j]
        set.push(new dateutil.Time(hour, minute, second, millisecond))
      }
    }
    dateutil.sort(set)
    return set
  }

  Iterinfo.prototype.mtimeset = function (hour, minute, second, millisecond) {
    var set = []
    var rr = this.rrule
    for (var j = 0; j < rr.options.bysecond.length; j++) {
      second = rr.options.bysecond[j]
      set.push(new dateutil.Time(hour, minute, second, millisecond))
    }
    dateutil.sort(set)
    return set
  }

  Iterinfo.prototype.stimeset = function (hour, minute, second, millisecond) {
    return [new dateutil.Time(hour, minute, second, millisecond)]
  }

  // =============================================================================
  // Results
  // =============================================================================

  /**
   * This class helps us to emulate python's generators, sorta.
   */
  var IterResult = function (method, args) {
    this.init(method, args)
  }

  IterResult.prototype = {
    constructor: IterResult,
    init: function (method, args) {
      this.method = method
      this.args = args
      this.minDate = null
      this.maxDate = null
      this._result = []

      if (method === 'between') {
        this.maxDate = args.inc
          ? args.before : new Date(args.before.getTime() - 1)
        this.minDate = args.inc
          ? args.after : new Date(args.after.getTime() + 1)
      } else if (method === 'before') {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1)
      } else if (method === 'after') {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1)
      }
    },

    /**
     * Possibly adds a date into the result.
     *
     * @param {Date} date - the date isn't necessarly added to the result
     *                      list (if it is too late/too early)
     * @return {Boolean} true if it makes sense to continue the iteration
     *                   false if we're done.
     */
    accept: function (date) {
      var tooEarly = this.minDate && date < this.minDate
      var tooLate = this.maxDate && date > this.maxDate

      if (this.method === 'between') {
        if (tooEarly) return true
        if (tooLate) return false
      } else if (this.method === 'before') {
        if (tooLate) return false
      } else if (this.method === 'after') {
        if (tooEarly) return true
        this.add(date)
        return false
      }

      return this.add(date)
    },

    /**
     *
     * @param {Date} date that is part of the result.
     * @return {Boolean} whether we are interested in more values.
     */
    add: function (date) {
      this._result.push(date)
      return true
    },

    /**
     * 'before' and 'after' return only one date, whereas 'all'
     * and 'between' an array.
     * @return {Date,Array?}
     */
    getValue: function () {
      var res = this._result
      switch (this.method) {
        case 'all':
        case 'between':
          return res
        case 'before':
        case 'after':
          return res.length ? res[res.length - 1] : null
      }
    },

    clone: function () {
      return new IterResult(this.method, this.args)
    }
  }

  /**
   * IterResult subclass that calls a callback function on each add,
   * and stops iterating when the callback returns false.
   */
  var CallbackIterResult = function (method, args, iterator) {
    var allowedMethods = ['all', 'between']
    if (!contains(allowedMethods, method)) {
      throw new Error('Invalid method "' + method +
        '". Only all and between works with iterator.')
    }
    this.add = function (date) {
      if (iterator(date, this._result.length)) {
        this._result.push(date)
        return true
      }
      return false
    }

    this.init(method, args)
  }
  CallbackIterResult.prototype = IterResult.prototype

  /**
   *
   * @param {Boolean?} noCache
   *  The same stratagy as RRule on cache, default to false
   * @constructor
   */

  var RRuleSet = function (noCache) {
    // Let RRuleSet cacheable
    this._cache = noCache ? null : {
      all: false,
      before: [],
      after: [],
      between: []
    }
    this._rrule = []
    this._rdate = []
    this._exrule = []
    this._exdate = []
  }

  RRuleSet.prototype = {
    constructor: RRuleSet,

    /**
    * @param {RRule}
    */
    rrule: function (rrule) {
      if (!(rrule instanceof RRule)) {
        throw new TypeError(String(rrule) + ' is not RRule instance')
      }
      if (!contains(this._rrule.map(String), String(rrule))) {
        this._rrule.push(rrule)
      }
    },

    /**
    * @param {Date}
    */
    rdate: function (date) {
      if (!(date instanceof Date)) {
        throw new TypeError(String(date) + ' is not Date instance')
      }
      if (!contains(this._rdate.map(Number), Number(date))) {
        this._rdate.push(date)
        dateutil.sort(this._rdate)
      }
    },

    /**
    * @param {RRule}
    */
    exrule: function (rrule) {
      if (!(rrule instanceof RRule)) {
        throw new TypeError(String(rrule) + ' is not RRule instance')
      }
      if (!contains(this._exrule.map(String), String(rrule))) {
        this._exrule.push(rrule)
      }
    },

    /**
    * @param {Date}
    */
    exdate: function (date) {
      if (!(date instanceof Date)) {
        throw new TypeError(String(date) + ' is not Date instance')
      }
      if (!contains(this._exdate.map(Number), Number(date))) {
        this._exdate.push(date)
        dateutil.sort(this._exdate)
      }
    },

    valueOf: function () {
      var result = []
      if (this._rrule.length) {
        this._rrule.forEach(function (rrule) {
          result.push('RRULE:' + rrule)
        })
      }
      if (this._rdate.length) {
        result.push('RDATE:' + this._rdate.map(function (rdate) {
          return dateutil.timeToUntilString(rdate)
        }).join(','))
      }
      if (this._exrule.length) {
        this._exrule.forEach(function (exrule) {
          result.push('EXRULE:' + exrule)
        })
      }
      if (this._exdate.length) {
        result.push('EXDATE:' + this._exdate.map(function (exdate) {
          return dateutil.timeToUntilString(exdate)
        }).join(','))
      }
      return result
    },

    /**
    * to generate recurrence field sush as:
    *   ["RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU;DTSTART=19970902T010000Z","RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH;DTSTART=19970902T010000Z"]
    */
    toString: function () {
      return JSON.stringify(this.valueOf())
    },

    _iter: function (iterResult) {
      var _exdateHash = {}
      var _exrule = this._exrule
      var _accept = iterResult.accept

      function evalExdate (after, before) {
        _exrule.forEach(function (rrule) {
          rrule.between(after, before, true).forEach(function (date) {
            _exdateHash[Number(date)] = true
          })
        })
      }

      this._exdate.forEach(function (date) {
        _exdateHash[Number(date)] = true
      })

      iterResult.accept = function (date) {
        var dt = Number(date)
        if (!_exdateHash[dt]) {
          evalExdate(new Date(dt - 1), new Date(dt + 1))
          if (!_exdateHash[dt]) {
            _exdateHash[dt] = true
            return _accept.call(this, date)
          }
        }
        return true
      }

      if (iterResult.method === 'between') {
        evalExdate(iterResult.args.after, iterResult.args.before)
        iterResult.accept = function (date) {
          var dt = Number(date)
          if (!_exdateHash[dt]) {
            _exdateHash[dt] = true
            return _accept.call(this, date)
          }
          return true
        }
      }

      for (var i = 0; i < this._rdate.length; i++) {
        if (!iterResult.accept(new Date(this._rdate[i]))) break
      }

      this._rrule.forEach(function (rrule) {
        rrule._iter(iterResult)
      })

      var res = iterResult._result
      dateutil.sort(res)
      switch (iterResult.method) {
        case 'all':
        case 'between':
          return res
        case 'before':
          return (res.length && res[res.length - 1]) || null
        case 'after':
          return (res.length && res[0]) || null
        default:
          return null
      }
    },

    /**
    * Create a new RRuleSet Object completely base on current instance
    */
    clone: function () {
      var rrs = new RRuleSet(!!this._cache)
      var i
      for (i = 0; i < this._rrule.length; i++) {
        rrs.rrule(this._rrule[i].clone())
      }
      for (i = 0; i < this._rdate.length; i++) {
        rrs.rdate(new Date(this._rdate[i]))
      }
      for (i = 0; i < this._exrule.length; i++) {
        rrs.exrule(this._exrule[i].clone())
      }
      for (i = 0; i < this._exdate.length; i++) {
        rrs.exdate(new Date(this._exdate[i]))
      }
      return rrs
    }
  }

  /**
   * Inherts method from RRule
   *  add Read interface and set RRuleSet cacheable
   */
  var RRuleSetMethods = ['all', 'between', 'before', 'after', 'count', '_cacheAdd', '_cacheGet']
  RRuleSetMethods.forEach(function (method) {
    RRuleSet.prototype[method] = RRule.prototype[method]
  })

  /**
   * RRuleStr
   *  To parse a set of rrule strings
   */

  var RRuleStr = function () {}

  RRuleStr.DEFAULT_OPTIONS = {
    dtstart: null,
    cache: false,
    unfold: false,
    forceset: false,
    compatible: false,
    ignoretz: false,
    tzinfos: null
  }

  RRuleStr._freq_map = {
    'YEARLY': RRule.YEARLY,
    'MONTHLY': RRule.MONTHLY,
    'WEEKLY': RRule.WEEKLY,
    'DAILY': RRule.DAILY,
    'HOURLY': RRule.HOURLY,
    'MINUTELY': RRule.MINUTELY,
    'SECONDLY': RRule.SECONDLY
  }

  RRuleStr._weekday_map = {
    'MO': 0,
    'TU': 1,
    'WE': 2,
    'TH': 3,
    'FR': 4,
    'SA': 5,
    'SU': 6
  }

  RRuleStr.prototype = {
    constructor: RRuleStr,

    _handle_int: function (rrkwargs, name, value, options) {
      rrkwargs[name.toLowerCase()] = parseInt(value, 10)
    },

    _handle_int_list: function (rrkwargs, name, value, options) {
      rrkwargs[name.toLowerCase()] = value.split(',').map(function (x) {
        return parseInt(x, 10)
      })
    },

    _handle_FREQ: function (rrkwargs, name, value, options) {
      rrkwargs['freq'] = RRuleStr._freq_map[value]
    },

    _handle_UNTIL: function (rrkwargs, name, value, options) {
      try {
        rrkwargs['until'] = dateutil.untilStringToDate(value)
      } catch (error) {
        throw new Error('invalid until date')
      }
    },

    _handle_WKST: function (rrkwargs, name, value, options) {
      rrkwargs['wkst'] = RRuleStr._weekday_map[value]
    },

    _handle_BYWEEKDAY: function (rrkwargs, name, value, options) {
      // Two ways to specify this: +1MO or MO(+1)
      var splt, i, j, n, w, wday
      var l = []
      var wdays = value.split(',')

      for (i = 0; i < wdays.length; i++) {
        wday = wdays[i]
        if (wday.indexOf('(') > -1) {
          // If it's of the form TH(+1), etc.
          splt = wday.split('(')
          w = splt[0]
          n = parseInt(splt.slice(1, -1), 10)
        } else {
          // # If it's of the form +1MO
          for (j = 0; j < wday.length; j++) {
            if ('+-0123456789'.indexOf(wday[j]) === -1) break
          }
          n = wday.slice(0, j) || null
          w = wday.slice(j)

          if (n) n = parseInt(n, 10)
        }

        var weekday = new Weekday(RRuleStr._weekday_map[w], n)
        l.push(weekday)
      }
      rrkwargs['byweekday'] = l
    },

    _parseRfcRRule: function (line, options) {
      options = options || {}
      options.dtstart = options.dtstart || null
      options.cache = options.cache || false
      options.ignoretz = options.ignoretz || false
      options.tzinfos = options.tzinfos || null

      var name, value, parts
      if (line.indexOf(':') !== -1) {
        parts = line.split(':')
        name = parts[0]
        value = parts[1]

        if (name !== 'RRULE') throw new Error('unknown parameter name')
      } else {
        value = line
      }

      var i
      var rrkwargs = {}
      var pairs = value.split(';')

      for (i = 0; i < pairs.length; i++) {
        parts = pairs[i].split('=')
        name = parts[0].toUpperCase()
        value = parts[1].toUpperCase()

        try {
          this['_handle_' + name](rrkwargs, name, value, {
            ignoretz: options.ignoretz,
            tzinfos: options.tzinfos
          })
        } catch (error) {
          throw new Error("unknown parameter '" + name + "':" + value)
        }
      }
      rrkwargs.dtstart = rrkwargs.dtstart || options.dtstart
      return new RRule(rrkwargs, !options.cache)
    },

    _parseRfc: function (s, options) {
      if (options.compatible) {
        options.forceset = true
        options.unfold = true
      }

      s = s && s.toUpperCase().trim()
      if (!s) throw new Error('Invalid empty string')

      var i = 0
      var line, lines

      // More info about 'unfold' option
      // Go head to http://www.ietf.org/rfc/rfc2445.txt
      if (options.unfold) {
        lines = s.split('\n')
        while (i < lines.length) {
          // TODO
          line = lines[i] = lines[i].replace(/\s+$/g, '')
          if (!line) {
            lines.splice(i, 1)
          } else if (i > 0 && line[0] === ' ') {
            lines[i - 1] += line.slice(1)
            lines.splice(i, 1)
          } else {
            i += 1
          }
        }
      } else {
        lines = s.split(/\s/)
      }

      var rrulevals = []
      var rdatevals = []
      var exrulevals = []
      var exdatevals = []
      var name, value, parts, parms, parm, dtstart, rset, j, k, datestrs, datestr

      if (!options.forceset && lines.length === 1 && (s.indexOf(':') === -1 ||
        s.indexOf('RRULE:') === 0)) {
        return this._parseRfcRRule(lines[0], {
          cache: options.cache,
          dtstart: options.dtstart,
          ignoretz: options.ignoretz,
          tzinfos: options.tzinfos
        })
      } else {
        for (i = 0; i < lines.length; i++) {
          line = lines[i]
          if (!line) continue
          if (line.indexOf(':') === -1) {
            name = 'RRULE'
            value = line
          } else {
            parts = split(line, ':', 1)
            name = parts[0]
            value = parts[1]
          }
          parms = name.split(';')
          if (!parms) throw new Error('empty property name')
          name = parms[0]
          parms = parms.slice(1)

          if (name === 'RRULE') {
            for (j = 0; j < parms.length; j++) {
              parm = parms[j]
              throw new Error('unsupported RRULE parm: ' + parm)
            }
            rrulevals.push(value)
          } else if (name === 'RDATE') {
            for (j = 0; j < parms.length; j++) {
              parm = parms[j]
              if (parm !== 'VALUE=DATE-TIME') {
                throw new Error('unsupported RDATE parm: ' + parm)
              }
            }
            rdatevals.push(value)
          } else if (name === 'EXRULE') {
            for (j = 0; j < parms.length; j++) {
              parm = parms[j]
              throw new Error('unsupported EXRULE parm: ' + parm)
            }
            exrulevals.push(value)
          } else if (name === 'EXDATE') {
            for (j = 0; j < parms.length; j++) {
              parm = parms[j]
              if (parm !== 'VALUE=DATE-TIME') {
                throw new Error('unsupported RDATE parm: ' + parm)
              }
            }
            exdatevals.push(value)
          } else if (name === 'DTSTART') {
            dtstart = dateutil.untilStringToDate(value)
          } else {
            throw new Error('unsupported property: ' + name)
          }
        }

        if (options.forceset || rrulevals.length > 1 || rdatevals.length ||
          exrulevals.length || exdatevals.length) {
          rset = new RRuleSet(!options.cache)
          for (j = 0; j < rrulevals.length; j++) {
            rset.rrule(this._parseRfcRRule(rrulevals[j], {
              dtstart: options.dtstart || dtstart,
              ignoretz: options.ignoretz,
              tzinfos: options.tzinfos
            }))
          }
          for (j = 0; j < rdatevals.length; j++) {
            datestrs = rdatevals[j].split(',')
            for (k = 0; k < datestrs.length; k++) {
              datestr = datestrs[k]
              rset.rdate(dateutil.untilStringToDate(datestr))
            }
          }
          for (j = 0; j < exrulevals.length; j++) {
            rset.exrule(this._parseRfcRRule(exrulevals[j], {
              dtstart: options.dtstart || dtstart,
              ignoretz: options.ignoretz,
              tzinfos: options.tzinfos
            }))
          }
          for (j = 0; j < exdatevals.length; j++) {
            datestrs = exdatevals[j].split(',')
            for (k = 0; k < datestrs.length; k++) {
              datestr = datestrs[k]
              rset.exdate(dateutil.untilStringToDate(datestr))
            }
          }

          if (options.campatiable && options.dtstart) rset.rdate(dtstart)
          return rset
        } else {
          return this._parseRfcRRule(rrulevals[0], {
            dtstart: options.dtstart || dtstart,
            cache: options.cache,
            ignoretz: options.ignoretz,
            tzinfos: options.tzinfos
          })
        }
      }
    },

    parse: function (s, options) {
      options = options || {}

      var invalid = []
      var keys = Object.keys(options)
      var defaultKeys = Object.keys(RRuleStr.DEFAULT_OPTIONS)

      keys.forEach(function (key) {
        if (!contains(defaultKeys, key)) invalid.push(key)
      }, this)

      if (invalid.length) throw new Error('Invalid options: ' + invalid.join(', '))

      // Merge in default options
      defaultKeys.forEach(function (key) {
        if (!contains(keys, key)) options[key] = RRuleStr.DEFAULT_OPTIONS[key]
      })

      return this._parseRfc(s, options)
    }
  }

  RRuleStr.prototype._handle_DTSTART = function (rrkwargs, name, value, options) {
    rrkwargs[name.toLowerCase()] = dateutil.untilStringToDate(value)
  }

  RRuleStr.prototype._handle_BYDAY = RRuleStr.prototype._handle_BYWEEKDAY
  RRuleStr.prototype._handle_INTERVAL = RRuleStr.prototype._handle_int
  RRuleStr.prototype._handle_COUNT = RRuleStr.prototype._handle_int

  ;[
    '_handle_BYSETPOS', '_handle_BYMONTH', '_handle_BYMONTHDAY',
    '_handle_BYYEARDAY', '_handle_BYEASTER', '_handle_BYWEEKNO',
    '_handle_BYHOUR', '_handle_BYMINUTE', '_handle_BYSECOND'
  ].forEach(function (method) {
    RRuleStr.prototype[method] = RRuleStr.prototype._handle_int_list
  })

  // =============================================================================
  // Export
  // =============================================================================

  // Only one RRuleStr instance for all rrule string parsing work.
  var rruleStr = new RRuleStr()
  var rrulestr = function () {
    return rruleStr.parse.apply(rruleStr, arguments)
  }

  RRule.RRule = RRule
  RRule.RRuleSet = RRuleSet
  RRule.rrulestr = rrulestr
  return RRule

  function getnlp () {
    // Lazy, runtime import to avoid circular refs.
    if (!getnlp._nlp) {
      if (root && root._getRRuleNLP) {
        getnlp._nlp = root._getRRuleNLP(RRule)
      } else if (typeof require === 'function') {
        getnlp._nlp = require('./nlp')(RRule)
      } else {
        throw new Error('You need to include rrule/nlp.js for fromText/toText to work.')
      }
    }
    return getnlp._nlp
  }
}))

/*! Select2 4.0.2 | https://github.com/select2/select2/blob/master/LICENSE.md */!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a("object"==typeof exports?require("jquery"):jQuery)}(function(a){var b=function(){if(a&&a.fn&&a.fn.select2&&a.fn.select2.amd)var b=a.fn.select2.amd;var b;return function(){if(!b||!b.requirejs){b?c=b:b={};var a,c,d;!function(b){function e(a,b){return u.call(a,b)}function f(a,b){var c,d,e,f,g,h,i,j,k,l,m,n=b&&b.split("/"),o=s.map,p=o&&o["*"]||{};if(a&&"."===a.charAt(0))if(b){for(a=a.split("/"),g=a.length-1,s.nodeIdCompat&&w.test(a[g])&&(a[g]=a[g].replace(w,"")),a=n.slice(0,n.length-1).concat(a),k=0;k<a.length;k+=1)if(m=a[k],"."===m)a.splice(k,1),k-=1;else if(".."===m){if(1===k&&(".."===a[2]||".."===a[0]))break;k>0&&(a.splice(k-1,2),k-=2)}a=a.join("/")}else 0===a.indexOf("./")&&(a=a.substring(2));if((n||p)&&o){for(c=a.split("/"),k=c.length;k>0;k-=1){if(d=c.slice(0,k).join("/"),n)for(l=n.length;l>0;l-=1)if(e=o[n.slice(0,l).join("/")],e&&(e=e[d])){f=e,h=k;break}if(f)break;!i&&p&&p[d]&&(i=p[d],j=k)}!f&&i&&(f=i,h=j),f&&(c.splice(0,h,f),a=c.join("/"))}return a}function g(a,c){return function(){var d=v.call(arguments,0);return"string"!=typeof d[0]&&1===d.length&&d.push(null),n.apply(b,d.concat([a,c]))}}function h(a){return function(b){return f(b,a)}}function i(a){return function(b){q[a]=b}}function j(a){if(e(r,a)){var c=r[a];delete r[a],t[a]=!0,m.apply(b,c)}if(!e(q,a)&&!e(t,a))throw new Error("No "+a);return q[a]}function k(a){var b,c=a?a.indexOf("!"):-1;return c>-1&&(b=a.substring(0,c),a=a.substring(c+1,a.length)),[b,a]}function l(a){return function(){return s&&s.config&&s.config[a]||{}}}var m,n,o,p,q={},r={},s={},t={},u=Object.prototype.hasOwnProperty,v=[].slice,w=/\.js$/;o=function(a,b){var c,d=k(a),e=d[0];return a=d[1],e&&(e=f(e,b),c=j(e)),e?a=c&&c.normalize?c.normalize(a,h(b)):f(a,b):(a=f(a,b),d=k(a),e=d[0],a=d[1],e&&(c=j(e))),{f:e?e+"!"+a:a,n:a,pr:e,p:c}},p={require:function(a){return g(a)},exports:function(a){var b=q[a];return"undefined"!=typeof b?b:q[a]={}},module:function(a){return{id:a,uri:"",exports:q[a],config:l(a)}}},m=function(a,c,d,f){var h,k,l,m,n,s,u=[],v=typeof d;if(f=f||a,"undefined"===v||"function"===v){for(c=!c.length&&d.length?["require","exports","module"]:c,n=0;n<c.length;n+=1)if(m=o(c[n],f),k=m.f,"require"===k)u[n]=p.require(a);else if("exports"===k)u[n]=p.exports(a),s=!0;else if("module"===k)h=u[n]=p.module(a);else if(e(q,k)||e(r,k)||e(t,k))u[n]=j(k);else{if(!m.p)throw new Error(a+" missing "+k);m.p.load(m.n,g(f,!0),i(k),{}),u[n]=q[k]}l=d?d.apply(q[a],u):void 0,a&&(h&&h.exports!==b&&h.exports!==q[a]?q[a]=h.exports:l===b&&s||(q[a]=l))}else a&&(q[a]=d)},a=c=n=function(a,c,d,e,f){if("string"==typeof a)return p[a]?p[a](c):j(o(a,c).f);if(!a.splice){if(s=a,s.deps&&n(s.deps,s.callback),!c)return;c.splice?(a=c,c=d,d=null):a=b}return c=c||function(){},"function"==typeof d&&(d=e,e=f),e?m(b,a,c,d):setTimeout(function(){m(b,a,c,d)},4),n},n.config=function(a){return n(a)},a._defined=q,d=function(a,b,c){if("string"!=typeof a)throw new Error("See almond README: incorrect module build, no module name");b.splice||(c=b,b=[]),e(q,a)||e(r,a)||(r[a]=[a,b,c])},d.amd={jQuery:!0}}(),b.requirejs=a,b.require=c,b.define=d}}(),b.define("almond",function(){}),b.define("jquery",[],function(){var b=a||$;return null==b&&console&&console.error&&console.error("Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."),b}),b.define("select2/utils",["jquery"],function(a){function b(a){var b=a.prototype,c=[];for(var d in b){var e=b[d];"function"==typeof e&&"constructor"!==d&&c.push(d)}return c}var c={};c.Extend=function(a,b){function c(){this.constructor=a}var d={}.hasOwnProperty;for(var e in b)d.call(b,e)&&(a[e]=b[e]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},c.Decorate=function(a,c){function d(){var b=Array.prototype.unshift,d=c.prototype.constructor.length,e=a.prototype.constructor;d>0&&(b.call(arguments,a.prototype.constructor),e=c.prototype.constructor),e.apply(this,arguments)}function e(){this.constructor=d}var f=b(c),g=b(a);c.displayName=a.displayName,d.prototype=new e;for(var h=0;h<g.length;h++){var i=g[h];d.prototype[i]=a.prototype[i]}for(var j=(function(a){var b=function(){};a in d.prototype&&(b=d.prototype[a]);var e=c.prototype[a];return function(){var a=Array.prototype.unshift;return a.call(arguments,b),e.apply(this,arguments)}}),k=0;k<f.length;k++){var l=f[k];d.prototype[l]=j(l)}return d};var d=function(){this.listeners={}};return d.prototype.on=function(a,b){this.listeners=this.listeners||{},a in this.listeners?this.listeners[a].push(b):this.listeners[a]=[b]},d.prototype.trigger=function(a){var b=Array.prototype.slice;this.listeners=this.listeners||{},a in this.listeners&&this.invoke(this.listeners[a],b.call(arguments,1)),"*"in this.listeners&&this.invoke(this.listeners["*"],arguments)},d.prototype.invoke=function(a,b){for(var c=0,d=a.length;d>c;c++)a[c].apply(this,b)},c.Observable=d,c.generateChars=function(a){for(var b="",c=0;a>c;c++){var d=Math.floor(36*Math.random());b+=d.toString(36)}return b},c.bind=function(a,b){return function(){a.apply(b,arguments)}},c._convertData=function(a){for(var b in a){var c=b.split("-"),d=a;if(1!==c.length){for(var e=0;e<c.length;e++){var f=c[e];f=f.substring(0,1).toLowerCase()+f.substring(1),f in d||(d[f]={}),e==c.length-1&&(d[f]=a[b]),d=d[f]}delete a[b]}}return a},c.hasScroll=function(b,c){var d=a(c),e=c.style.overflowX,f=c.style.overflowY;return e!==f||"hidden"!==f&&"visible"!==f?"scroll"===e||"scroll"===f?!0:d.innerHeight()<c.scrollHeight||d.innerWidth()<c.scrollWidth:!1},c.escapeMarkup=function(a){var b={"\\":"&#92;","&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#47;"};return"string"!=typeof a?a:String(a).replace(/[&<>"'\/\\]/g,function(a){return b[a]})},c.appendMany=function(b,c){if("1.7"===a.fn.jquery.substr(0,3)){var d=a();a.map(c,function(a){d=d.add(a)}),c=d}b.append(c)},c}),b.define("select2/results",["jquery","./utils"],function(a,b){function c(a,b,d){this.$element=a,this.data=d,this.options=b,c.__super__.constructor.call(this)}return b.Extend(c,b.Observable),c.prototype.render=function(){var b=a('<ul class="select2-results__options" role="tree"></ul>');return this.options.get("multiple")&&b.attr("aria-multiselectable","true"),this.$results=b,b},c.prototype.clear=function(){this.$results.empty()},c.prototype.displayMessage=function(b){var c=this.options.get("escapeMarkup");this.clear(),this.hideLoading();var d=a('<li role="treeitem" aria-live="assertive" class="select2-results__option"></li>'),e=this.options.get("translations").get(b.message);d.append(c(e(b.args))),d[0].className+=" select2-results__message",this.$results.append(d)},c.prototype.hideMessages=function(){this.$results.find(".select2-results__message").remove()},c.prototype.append=function(a){this.hideLoading();var b=[];if(null==a.results||0===a.results.length)return void(0===this.$results.children().length&&this.trigger("results:message",{message:"noResults"}));a.results=this.sort(a.results);for(var c=0;c<a.results.length;c++){var d=a.results[c],e=this.option(d);b.push(e)}this.$results.append(b)},c.prototype.position=function(a,b){var c=b.find(".select2-results");c.append(a)},c.prototype.sort=function(a){var b=this.options.get("sorter");return b(a)},c.prototype.setClasses=function(){var b=this;this.data.current(function(c){var d=a.map(c,function(a){return a.id.toString()}),e=b.$results.find(".select2-results__option[aria-selected]");e.each(function(){var b=a(this),c=a.data(this,"data"),e=""+c.id;null!=c.element&&c.element.selected||null==c.element&&a.inArray(e,d)>-1?b.attr("aria-selected","true"):b.attr("aria-selected","false")});var f=e.filter("[aria-selected=true]");f.length>0?f.first().trigger("mouseenter"):e.first().trigger("mouseenter")})},c.prototype.showLoading=function(a){this.hideLoading();var b=this.options.get("translations").get("searching"),c={disabled:!0,loading:!0,text:b(a)},d=this.option(c);d.className+=" loading-results",this.$results.prepend(d)},c.prototype.hideLoading=function(){this.$results.find(".loading-results").remove()},c.prototype.option=function(b){var c=document.createElement("li");c.className="select2-results__option";var d={role:"treeitem","aria-selected":"false"};b.disabled&&(delete d["aria-selected"],d["aria-disabled"]="true"),null==b.id&&delete d["aria-selected"],null!=b._resultId&&(c.id=b._resultId),b.title&&(c.title=b.title),b.children&&(d.role="group",d["aria-label"]=b.text,delete d["aria-selected"]);for(var e in d){var f=d[e];c.setAttribute(e,f)}if(b.children){var g=a(c),h=document.createElement("strong");h.className="select2-results__group";a(h);this.template(b,h);for(var i=[],j=0;j<b.children.length;j++){var k=b.children[j],l=this.option(k);i.push(l)}var m=a("<ul></ul>",{"class":"select2-results__options select2-results__options--nested"});m.append(i),g.append(h),g.append(m)}else this.template(b,c);return a.data(c,"data",b),c},c.prototype.bind=function(b,c){var d=this,e=b.id+"-results";this.$results.attr("id",e),b.on("results:all",function(a){d.clear(),d.append(a.data),b.isOpen()&&d.setClasses()}),b.on("results:append",function(a){d.append(a.data),b.isOpen()&&d.setClasses()}),b.on("query",function(a){d.hideMessages(),d.showLoading(a)}),b.on("select",function(){b.isOpen()&&d.setClasses()}),b.on("unselect",function(){b.isOpen()&&d.setClasses()}),b.on("open",function(){d.$results.attr("aria-expanded","true"),d.$results.attr("aria-hidden","false"),d.setClasses(),d.ensureHighlightVisible()}),b.on("close",function(){d.$results.attr("aria-expanded","false"),d.$results.attr("aria-hidden","true"),d.$results.removeAttr("aria-activedescendant")}),b.on("results:toggle",function(){var a=d.getHighlightedResults();0!==a.length&&a.trigger("mouseup")}),b.on("results:select",function(){var a=d.getHighlightedResults();if(0!==a.length){var b=a.data("data");"true"==a.attr("aria-selected")?d.trigger("close",{}):d.trigger("select",{data:b})}}),b.on("results:previous",function(){var a=d.getHighlightedResults(),b=d.$results.find("[aria-selected]"),c=b.index(a);if(0!==c){var e=c-1;0===a.length&&(e=0);var f=b.eq(e);f.trigger("mouseenter");var g=d.$results.offset().top,h=f.offset().top,i=d.$results.scrollTop()+(h-g);0===e?d.$results.scrollTop(0):0>h-g&&d.$results.scrollTop(i)}}),b.on("results:next",function(){var a=d.getHighlightedResults(),b=d.$results.find("[aria-selected]"),c=b.index(a),e=c+1;if(!(e>=b.length)){var f=b.eq(e);f.trigger("mouseenter");var g=d.$results.offset().top+d.$results.outerHeight(!1),h=f.offset().top+f.outerHeight(!1),i=d.$results.scrollTop()+h-g;0===e?d.$results.scrollTop(0):h>g&&d.$results.scrollTop(i)}}),b.on("results:focus",function(a){a.element.addClass("select2-results__option--highlighted")}),b.on("results:message",function(a){d.displayMessage(a)}),a.fn.mousewheel&&this.$results.on("mousewheel",function(a){var b=d.$results.scrollTop(),c=d.$results.get(0).scrollHeight-b+a.deltaY,e=a.deltaY>0&&b-a.deltaY<=0,f=a.deltaY<0&&c<=d.$results.height();e?(d.$results.scrollTop(0),a.preventDefault(),a.stopPropagation()):f&&(d.$results.scrollTop(d.$results.get(0).scrollHeight-d.$results.height()),a.preventDefault(),a.stopPropagation())}),this.$results.on("mouseup",".select2-results__option[aria-selected]",function(b){var c=a(this),e=c.data("data");return"true"===c.attr("aria-selected")?void(d.options.get("multiple")?d.trigger("unselect",{originalEvent:b,data:e}):d.trigger("close",{})):void d.trigger("select",{originalEvent:b,data:e})}),this.$results.on("mouseenter",".select2-results__option[aria-selected]",function(b){var c=a(this).data("data");d.getHighlightedResults().removeClass("select2-results__option--highlighted"),d.trigger("results:focus",{data:c,element:a(this)})})},c.prototype.getHighlightedResults=function(){var a=this.$results.find(".select2-results__option--highlighted");return a},c.prototype.destroy=function(){this.$results.remove()},c.prototype.ensureHighlightVisible=function(){var a=this.getHighlightedResults();if(0!==a.length){var b=this.$results.find("[aria-selected]"),c=b.index(a),d=this.$results.offset().top,e=a.offset().top,f=this.$results.scrollTop()+(e-d),g=e-d;f-=2*a.outerHeight(!1),2>=c?this.$results.scrollTop(0):(g>this.$results.outerHeight()||0>g)&&this.$results.scrollTop(f)}},c.prototype.template=function(b,c){var d=this.options.get("templateResult"),e=this.options.get("escapeMarkup"),f=d(b,c);null==f?c.style.display="none":"string"==typeof f?c.innerHTML=e(f):a(c).append(f)},c}),b.define("select2/keys",[],function(){var a={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46};return a}),b.define("select2/selection/base",["jquery","../utils","../keys"],function(a,b,c){function d(a,b){this.$element=a,this.options=b,d.__super__.constructor.call(this)}return b.Extend(d,b.Observable),d.prototype.render=function(){var b=a('<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>');return this._tabindex=0,null!=this.$element.data("old-tabindex")?this._tabindex=this.$element.data("old-tabindex"):null!=this.$element.attr("tabindex")&&(this._tabindex=this.$element.attr("tabindex")),b.attr("title",this.$element.attr("title")),b.attr("tabindex",this._tabindex),this.$selection=b,b},d.prototype.bind=function(a,b){var d=this,e=(a.id+"-container",a.id+"-results");this.container=a,this.$selection.on("focus",function(a){d.trigger("focus",a)}),this.$selection.on("blur",function(a){d._handleBlur(a)}),this.$selection.on("keydown",function(a){d.trigger("keypress",a),a.which===c.SPACE&&a.preventDefault()}),a.on("results:focus",function(a){d.$selection.attr("aria-activedescendant",a.data._resultId)}),a.on("selection:update",function(a){d.update(a.data)}),a.on("open",function(){d.$selection.attr("aria-expanded","true"),d.$selection.attr("aria-owns",e),d._attachCloseHandler(a)}),a.on("close",function(){d.$selection.attr("aria-expanded","false"),d.$selection.removeAttr("aria-activedescendant"),d.$selection.removeAttr("aria-owns"),d.$selection.focus(),d._detachCloseHandler(a)}),a.on("enable",function(){d.$selection.attr("tabindex",d._tabindex)}),a.on("disable",function(){d.$selection.attr("tabindex","-1")})},d.prototype._handleBlur=function(b){var c=this;window.setTimeout(function(){document.activeElement==c.$selection[0]||a.contains(c.$selection[0],document.activeElement)||c.trigger("blur",b)},1)},d.prototype._attachCloseHandler=function(b){a(document.body).on("mousedown.select2."+b.id,function(b){var c=a(b.target),d=c.closest(".select2"),e=a(".select2.select2-container--open");e.each(function(){var b=a(this);if(this!=d[0]){var c=b.data("element");c.select2("close")}})})},d.prototype._detachCloseHandler=function(b){a(document.body).off("mousedown.select2."+b.id)},d.prototype.position=function(a,b){var c=b.find(".selection");c.append(a)},d.prototype.destroy=function(){this._detachCloseHandler(this.container)},d.prototype.update=function(a){throw new Error("The `update` method must be defined in child classes.")},d}),b.define("select2/selection/single",["jquery","./base","../utils","../keys"],function(a,b,c,d){function e(){e.__super__.constructor.apply(this,arguments)}return c.Extend(e,b),e.prototype.render=function(){var a=e.__super__.render.call(this);return a.addClass("select2-selection--single"),a.html('<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'),a},e.prototype.bind=function(a,b){var c=this;e.__super__.bind.apply(this,arguments);var d=a.id+"-container";this.$selection.find(".select2-selection__rendered").attr("id",d),this.$selection.attr("aria-labelledby",d),this.$selection.on("mousedown",function(a){1===a.which&&c.trigger("toggle",{originalEvent:a})}),this.$selection.on("focus",function(a){}),this.$selection.on("blur",function(a){}),a.on("selection:update",function(a){c.update(a.data)})},e.prototype.clear=function(){this.$selection.find(".select2-selection__rendered").empty()},e.prototype.display=function(a,b){var c=this.options.get("templateSelection"),d=this.options.get("escapeMarkup");return d(c(a,b))},e.prototype.selectionContainer=function(){return a("<span></span>")},e.prototype.update=function(a){if(0===a.length)return void this.clear();var b=a[0],c=this.$selection.find(".select2-selection__rendered"),d=this.display(b,c);c.empty().append(d),c.prop("title",b.title||b.text)},e}),b.define("select2/selection/multiple",["jquery","./base","../utils"],function(a,b,c){function d(a,b){d.__super__.constructor.apply(this,arguments)}return c.Extend(d,b),d.prototype.render=function(){var a=d.__super__.render.call(this);return a.addClass("select2-selection--multiple"),a.html('<ul class="select2-selection__rendered"></ul>'),a},d.prototype.bind=function(b,c){var e=this;d.__super__.bind.apply(this,arguments),this.$selection.on("click",function(a){e.trigger("toggle",{originalEvent:a})}),this.$selection.on("click",".select2-selection__choice__remove",function(b){if(!e.options.get("disabled")){var c=a(this),d=c.parent(),f=d.data("data");e.trigger("unselect",{originalEvent:b,data:f})}})},d.prototype.clear=function(){this.$selection.find(".select2-selection__rendered").empty()},d.prototype.display=function(a,b){var c=this.options.get("templateSelection"),d=this.options.get("escapeMarkup");return d(c(a,b))},d.prototype.selectionContainer=function(){var b=a('<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>');return b},d.prototype.update=function(a){if(this.clear(),0!==a.length){for(var b=[],d=0;d<a.length;d++){var e=a[d],f=this.selectionContainer(),g=this.display(e,f);f.append(g),f.prop("title",e.title||e.text),f.data("data",e),b.push(f)}var h=this.$selection.find(".select2-selection__rendered");c.appendMany(h,b)}},d}),b.define("select2/selection/placeholder",["../utils"],function(a){function b(a,b,c){this.placeholder=this.normalizePlaceholder(c.get("placeholder")),a.call(this,b,c)}return b.prototype.normalizePlaceholder=function(a,b){return"string"==typeof b&&(b={id:"",text:b}),b},b.prototype.createPlaceholder=function(a,b){var c=this.selectionContainer();return c.html(this.display(b)),c.addClass("select2-selection__placeholder").removeClass("select2-selection__choice"),c},b.prototype.update=function(a,b){var c=1==b.length&&b[0].id!=this.placeholder.id,d=b.length>1;if(d||c)return a.call(this,b);this.clear();var e=this.createPlaceholder(this.placeholder);this.$selection.find(".select2-selection__rendered").append(e)},b}),b.define("select2/selection/allowClear",["jquery","../keys"],function(a,b){function c(){}return c.prototype.bind=function(a,b,c){var d=this;a.call(this,b,c),null==this.placeholder&&this.options.get("debug")&&window.console&&console.error&&console.error("Select2: The `allowClear` option should be used in combination with the `placeholder` option."),this.$selection.on("mousedown",".select2-selection__clear",function(a){d._handleClear(a)}),b.on("keypress",function(a){d._handleKeyboardClear(a,b)})},c.prototype._handleClear=function(a,b){if(!this.options.get("disabled")){var c=this.$selection.find(".select2-selection__clear");if(0!==c.length){b.stopPropagation();for(var d=c.data("data"),e=0;e<d.length;e++){var f={data:d[e]};if(this.trigger("unselect",f),f.prevented)return}this.$element.val(this.placeholder.id).trigger("change"),this.trigger("toggle",{})}}},c.prototype._handleKeyboardClear=function(a,c,d){d.isOpen()||(c.which==b.DELETE||c.which==b.BACKSPACE)&&this._handleClear(c)},c.prototype.update=function(b,c){if(b.call(this,c),!(this.$selection.find(".select2-selection__placeholder").length>0||0===c.length)){var d=a('<span class="select2-selection__clear">&times;</span>');d.data("data",c),this.$selection.find(".select2-selection__rendered").prepend(d)}},c}),b.define("select2/selection/search",["jquery","../utils","../keys"],function(a,b,c){function d(a,b,c){a.call(this,b,c)}return d.prototype.render=function(b){var c=a('<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" aria-autocomplete="list" /></li>');this.$searchContainer=c,this.$search=c.find("input");var d=b.call(this);return this._transferTabIndex(),d},d.prototype.bind=function(a,b,d){var e=this;a.call(this,b,d),b.on("open",function(){e.$search.trigger("focus")}),b.on("close",function(){e.$search.val(""),e.$search.removeAttr("aria-activedescendant"),e.$search.trigger("focus")}),b.on("enable",function(){e.$search.prop("disabled",!1),e._transferTabIndex()}),b.on("disable",function(){e.$search.prop("disabled",!0)}),b.on("focus",function(a){e.$search.trigger("focus")}),b.on("results:focus",function(a){e.$search.attr("aria-activedescendant",a.id)}),this.$selection.on("focusin",".select2-search--inline",function(a){e.trigger("focus",a)}),this.$selection.on("focusout",".select2-search--inline",function(a){e._handleBlur(a)}),this.$selection.on("keydown",".select2-search--inline",function(a){a.stopPropagation(),e.trigger("keypress",a),e._keyUpPrevented=a.isDefaultPrevented();var b=a.which;if(b===c.BACKSPACE&&""===e.$search.val()){var d=e.$searchContainer.prev(".select2-selection__choice");if(d.length>0){var f=d.data("data");e.searchRemoveChoice(f),a.preventDefault()}}});var f=document.documentMode,g=f&&11>=f;this.$selection.on("input.searchcheck",".select2-search--inline",function(a){return g?void e.$selection.off("input.search input.searchcheck"):void e.$selection.off("keyup.search")}),this.$selection.on("keyup.search input.search",".select2-search--inline",function(a){if(g&&"input"===a.type)return void e.$selection.off("input.search input.searchcheck");var b=a.which;b!=c.SHIFT&&b!=c.CTRL&&b!=c.ALT&&b!=c.TAB&&e.handleSearch(a)})},d.prototype._transferTabIndex=function(a){this.$search.attr("tabindex",this.$selection.attr("tabindex")),this.$selection.attr("tabindex","-1")},d.prototype.createPlaceholder=function(a,b){this.$search.attr("placeholder",b.text)},d.prototype.update=function(a,b){var c=this.$search[0]==document.activeElement;this.$search.attr("placeholder",""),a.call(this,b),this.$selection.find(".select2-selection__rendered").append(this.$searchContainer),this.resizeSearch(),c&&this.$search.focus()},d.prototype.handleSearch=function(){if(this.resizeSearch(),!this._keyUpPrevented){var a=this.$search.val();this.trigger("query",{term:a})}this._keyUpPrevented=!1},d.prototype.searchRemoveChoice=function(a,b){this.trigger("unselect",{data:b}),this.$search.val(b.text),this.handleSearch()},d.prototype.resizeSearch=function(){this.$search.css("width","25px");var a="";if(""!==this.$search.attr("placeholder"))a=this.$selection.find(".select2-selection__rendered").innerWidth();else{var b=this.$search.val().length+1;a=.75*b+"em"}this.$search.css("width",a)},d}),b.define("select2/selection/eventRelay",["jquery"],function(a){function b(){}return b.prototype.bind=function(b,c,d){var e=this,f=["open","opening","close","closing","select","selecting","unselect","unselecting"],g=["opening","closing","selecting","unselecting"];b.call(this,c,d),c.on("*",function(b,c){if(-1!==a.inArray(b,f)){c=c||{};var d=a.Event("select2:"+b,{params:c});e.$element.trigger(d),-1!==a.inArray(b,g)&&(c.prevented=d.isDefaultPrevented())}})},b}),b.define("select2/translation",["jquery","require"],function(a,b){function c(a){this.dict=a||{}}return c.prototype.all=function(){return this.dict},c.prototype.get=function(a){return this.dict[a]},c.prototype.extend=function(b){this.dict=a.extend({},b.all(),this.dict)},c._cache={},c.loadPath=function(a){if(!(a in c._cache)){var d=b(a);c._cache[a]=d}return new c(c._cache[a])},c}),b.define("select2/diacritics",[],function(){var a={"Ⓐ":"A","Ａ":"A","À":"A","Á":"A","Â":"A","Ầ":"A","Ấ":"A","Ẫ":"A","Ẩ":"A","Ã":"A","Ā":"A","Ă":"A","Ằ":"A","Ắ":"A","Ẵ":"A","Ẳ":"A","Ȧ":"A","Ǡ":"A","Ä":"A","Ǟ":"A","Ả":"A","Å":"A","Ǻ":"A","Ǎ":"A","Ȁ":"A","Ȃ":"A","Ạ":"A","Ậ":"A","Ặ":"A","Ḁ":"A","Ą":"A","Ⱥ":"A","Ɐ":"A","Ꜳ":"AA","Æ":"AE","Ǽ":"AE","Ǣ":"AE","Ꜵ":"AO","Ꜷ":"AU","Ꜹ":"AV","Ꜻ":"AV","Ꜽ":"AY","Ⓑ":"B","Ｂ":"B","Ḃ":"B","Ḅ":"B","Ḇ":"B","Ƀ":"B","Ƃ":"B","Ɓ":"B","Ⓒ":"C","Ｃ":"C","Ć":"C","Ĉ":"C","Ċ":"C","Č":"C","Ç":"C","Ḉ":"C","Ƈ":"C","Ȼ":"C","Ꜿ":"C","Ⓓ":"D","Ｄ":"D","Ḋ":"D","Ď":"D","Ḍ":"D","Ḑ":"D","Ḓ":"D","Ḏ":"D","Đ":"D","Ƌ":"D","Ɗ":"D","Ɖ":"D","Ꝺ":"D","Ǳ":"DZ","Ǆ":"DZ","ǲ":"Dz","ǅ":"Dz","Ⓔ":"E","Ｅ":"E","È":"E","É":"E","Ê":"E","Ề":"E","Ế":"E","Ễ":"E","Ể":"E","Ẽ":"E","Ē":"E","Ḕ":"E","Ḗ":"E","Ĕ":"E","Ė":"E","Ë":"E","Ẻ":"E","Ě":"E","Ȅ":"E","Ȇ":"E","Ẹ":"E","Ệ":"E","Ȩ":"E","Ḝ":"E","Ę":"E","Ḙ":"E","Ḛ":"E","Ɛ":"E","Ǝ":"E","Ⓕ":"F","Ｆ":"F","Ḟ":"F","Ƒ":"F","Ꝼ":"F","Ⓖ":"G","Ｇ":"G","Ǵ":"G","Ĝ":"G","Ḡ":"G","Ğ":"G","Ġ":"G","Ǧ":"G","Ģ":"G","Ǥ":"G","Ɠ":"G","Ꞡ":"G","Ᵹ":"G","Ꝿ":"G","Ⓗ":"H","Ｈ":"H","Ĥ":"H","Ḣ":"H","Ḧ":"H","Ȟ":"H","Ḥ":"H","Ḩ":"H","Ḫ":"H","Ħ":"H","Ⱨ":"H","Ⱶ":"H","Ɥ":"H","Ⓘ":"I","Ｉ":"I","Ì":"I","Í":"I","Î":"I","Ĩ":"I","Ī":"I","Ĭ":"I","İ":"I","Ï":"I","Ḯ":"I","Ỉ":"I","Ǐ":"I","Ȉ":"I","Ȋ":"I","Ị":"I","Į":"I","Ḭ":"I","Ɨ":"I","Ⓙ":"J","Ｊ":"J","Ĵ":"J","Ɉ":"J","Ⓚ":"K","Ｋ":"K","Ḱ":"K","Ǩ":"K","Ḳ":"K","Ķ":"K","Ḵ":"K","Ƙ":"K","Ⱪ":"K","Ꝁ":"K","Ꝃ":"K","Ꝅ":"K","Ꞣ":"K","Ⓛ":"L","Ｌ":"L","Ŀ":"L","Ĺ":"L","Ľ":"L","Ḷ":"L","Ḹ":"L","Ļ":"L","Ḽ":"L","Ḻ":"L","Ł":"L","Ƚ":"L","Ɫ":"L","Ⱡ":"L","Ꝉ":"L","Ꝇ":"L","Ꞁ":"L","Ǉ":"LJ","ǈ":"Lj","Ⓜ":"M","Ｍ":"M","Ḿ":"M","Ṁ":"M","Ṃ":"M","Ɱ":"M","Ɯ":"M","Ⓝ":"N","Ｎ":"N","Ǹ":"N","Ń":"N","Ñ":"N","Ṅ":"N","Ň":"N","Ṇ":"N","Ņ":"N","Ṋ":"N","Ṉ":"N","Ƞ":"N","Ɲ":"N","Ꞑ":"N","Ꞥ":"N","Ǌ":"NJ","ǋ":"Nj","Ⓞ":"O","Ｏ":"O","Ò":"O","Ó":"O","Ô":"O","Ồ":"O","Ố":"O","Ỗ":"O","Ổ":"O","Õ":"O","Ṍ":"O","Ȭ":"O","Ṏ":"O","Ō":"O","Ṑ":"O","Ṓ":"O","Ŏ":"O","Ȯ":"O","Ȱ":"O","Ö":"O","Ȫ":"O","Ỏ":"O","Ő":"O","Ǒ":"O","Ȍ":"O","Ȏ":"O","Ơ":"O","Ờ":"O","Ớ":"O","Ỡ":"O","Ở":"O","Ợ":"O","Ọ":"O","Ộ":"O","Ǫ":"O","Ǭ":"O","Ø":"O","Ǿ":"O","Ɔ":"O","Ɵ":"O","Ꝋ":"O","Ꝍ":"O","Ƣ":"OI","Ꝏ":"OO","Ȣ":"OU","Ⓟ":"P","Ｐ":"P","Ṕ":"P","Ṗ":"P","Ƥ":"P","Ᵽ":"P","Ꝑ":"P","Ꝓ":"P","Ꝕ":"P","Ⓠ":"Q","Ｑ":"Q","Ꝗ":"Q","Ꝙ":"Q","Ɋ":"Q","Ⓡ":"R","Ｒ":"R","Ŕ":"R","Ṙ":"R","Ř":"R","Ȑ":"R","Ȓ":"R","Ṛ":"R","Ṝ":"R","Ŗ":"R","Ṟ":"R","Ɍ":"R","Ɽ":"R","Ꝛ":"R","Ꞧ":"R","Ꞃ":"R","Ⓢ":"S","Ｓ":"S","ẞ":"S","Ś":"S","Ṥ":"S","Ŝ":"S","Ṡ":"S","Š":"S","Ṧ":"S","Ṣ":"S","Ṩ":"S","Ș":"S","Ş":"S","Ȿ":"S","Ꞩ":"S","Ꞅ":"S","Ⓣ":"T","Ｔ":"T","Ṫ":"T","Ť":"T","Ṭ":"T","Ț":"T","Ţ":"T","Ṱ":"T","Ṯ":"T","Ŧ":"T","Ƭ":"T","Ʈ":"T","Ⱦ":"T","Ꞇ":"T","Ꜩ":"TZ","Ⓤ":"U","Ｕ":"U","Ù":"U","Ú":"U","Û":"U","Ũ":"U","Ṹ":"U","Ū":"U","Ṻ":"U","Ŭ":"U","Ü":"U","Ǜ":"U","Ǘ":"U","Ǖ":"U","Ǚ":"U","Ủ":"U","Ů":"U","Ű":"U","Ǔ":"U","Ȕ":"U","Ȗ":"U","Ư":"U","Ừ":"U","Ứ":"U","Ữ":"U","Ử":"U","Ự":"U","Ụ":"U","Ṳ":"U","Ų":"U","Ṷ":"U","Ṵ":"U","Ʉ":"U","Ⓥ":"V","Ｖ":"V","Ṽ":"V","Ṿ":"V","Ʋ":"V","Ꝟ":"V","Ʌ":"V","Ꝡ":"VY","Ⓦ":"W","Ｗ":"W","Ẁ":"W","Ẃ":"W","Ŵ":"W","Ẇ":"W","Ẅ":"W","Ẉ":"W","Ⱳ":"W","Ⓧ":"X","Ｘ":"X","Ẋ":"X","Ẍ":"X","Ⓨ":"Y","Ｙ":"Y","Ỳ":"Y","Ý":"Y","Ŷ":"Y","Ỹ":"Y","Ȳ":"Y","Ẏ":"Y","Ÿ":"Y","Ỷ":"Y","Ỵ":"Y","Ƴ":"Y","Ɏ":"Y","Ỿ":"Y","Ⓩ":"Z","Ｚ":"Z","Ź":"Z","Ẑ":"Z","Ż":"Z","Ž":"Z","Ẓ":"Z","Ẕ":"Z","Ƶ":"Z","Ȥ":"Z","Ɀ":"Z","Ⱬ":"Z","Ꝣ":"Z","ⓐ":"a","ａ":"a","ẚ":"a","à":"a","á":"a","â":"a","ầ":"a","ấ":"a","ẫ":"a","ẩ":"a","ã":"a","ā":"a","ă":"a","ằ":"a","ắ":"a","ẵ":"a","ẳ":"a","ȧ":"a","ǡ":"a","ä":"a","ǟ":"a","ả":"a","å":"a","ǻ":"a","ǎ":"a","ȁ":"a","ȃ":"a","ạ":"a","ậ":"a","ặ":"a","ḁ":"a","ą":"a","ⱥ":"a","ɐ":"a","ꜳ":"aa","æ":"ae","ǽ":"ae","ǣ":"ae","ꜵ":"ao","ꜷ":"au","ꜹ":"av","ꜻ":"av","ꜽ":"ay","ⓑ":"b","ｂ":"b","ḃ":"b","ḅ":"b","ḇ":"b","ƀ":"b","ƃ":"b","ɓ":"b","ⓒ":"c","ｃ":"c","ć":"c","ĉ":"c","ċ":"c","č":"c","ç":"c","ḉ":"c","ƈ":"c","ȼ":"c","ꜿ":"c","ↄ":"c","ⓓ":"d","ｄ":"d","ḋ":"d","ď":"d","ḍ":"d","ḑ":"d","ḓ":"d","ḏ":"d","đ":"d","ƌ":"d","ɖ":"d","ɗ":"d","ꝺ":"d","ǳ":"dz","ǆ":"dz","ⓔ":"e","ｅ":"e","è":"e","é":"e","ê":"e","ề":"e","ế":"e","ễ":"e","ể":"e","ẽ":"e","ē":"e","ḕ":"e","ḗ":"e","ĕ":"e","ė":"e","ë":"e","ẻ":"e","ě":"e","ȅ":"e","ȇ":"e","ẹ":"e","ệ":"e","ȩ":"e","ḝ":"e","ę":"e","ḙ":"e","ḛ":"e","ɇ":"e","ɛ":"e","ǝ":"e","ⓕ":"f","ｆ":"f","ḟ":"f","ƒ":"f","ꝼ":"f","ⓖ":"g","ｇ":"g","ǵ":"g","ĝ":"g","ḡ":"g","ğ":"g","ġ":"g","ǧ":"g","ģ":"g","ǥ":"g","ɠ":"g","ꞡ":"g","ᵹ":"g","ꝿ":"g","ⓗ":"h","ｈ":"h","ĥ":"h","ḣ":"h","ḧ":"h","ȟ":"h","ḥ":"h","ḩ":"h","ḫ":"h","ẖ":"h","ħ":"h","ⱨ":"h","ⱶ":"h","ɥ":"h","ƕ":"hv","ⓘ":"i","ｉ":"i","ì":"i","í":"i","î":"i","ĩ":"i","ī":"i","ĭ":"i","ï":"i","ḯ":"i","ỉ":"i","ǐ":"i","ȉ":"i","ȋ":"i","ị":"i","į":"i","ḭ":"i","ɨ":"i","ı":"i","ⓙ":"j","ｊ":"j","ĵ":"j","ǰ":"j","ɉ":"j","ⓚ":"k","ｋ":"k","ḱ":"k","ǩ":"k","ḳ":"k","ķ":"k","ḵ":"k","ƙ":"k","ⱪ":"k","ꝁ":"k","ꝃ":"k","ꝅ":"k","ꞣ":"k","ⓛ":"l","ｌ":"l","ŀ":"l","ĺ":"l","ľ":"l","ḷ":"l","ḹ":"l","ļ":"l","ḽ":"l","ḻ":"l","ſ":"l","ł":"l","ƚ":"l","ɫ":"l","ⱡ":"l","ꝉ":"l","ꞁ":"l","ꝇ":"l","ǉ":"lj","ⓜ":"m","ｍ":"m","ḿ":"m","ṁ":"m","ṃ":"m","ɱ":"m","ɯ":"m","ⓝ":"n","ｎ":"n","ǹ":"n","ń":"n","ñ":"n","ṅ":"n","ň":"n","ṇ":"n","ņ":"n","ṋ":"n","ṉ":"n","ƞ":"n","ɲ":"n","ŉ":"n","ꞑ":"n","ꞥ":"n","ǌ":"nj","ⓞ":"o","ｏ":"o","ò":"o","ó":"o","ô":"o","ồ":"o","ố":"o","ỗ":"o","ổ":"o","õ":"o","ṍ":"o","ȭ":"o","ṏ":"o","ō":"o","ṑ":"o","ṓ":"o","ŏ":"o","ȯ":"o","ȱ":"o","ö":"o","ȫ":"o","ỏ":"o","ő":"o","ǒ":"o","ȍ":"o","ȏ":"o","ơ":"o","ờ":"o","ớ":"o","ỡ":"o","ở":"o","ợ":"o","ọ":"o","ộ":"o","ǫ":"o","ǭ":"o","ø":"o","ǿ":"o","ɔ":"o","ꝋ":"o","ꝍ":"o","ɵ":"o","ƣ":"oi","ȣ":"ou","ꝏ":"oo","ⓟ":"p","ｐ":"p","ṕ":"p","ṗ":"p","ƥ":"p","ᵽ":"p","ꝑ":"p","ꝓ":"p","ꝕ":"p","ⓠ":"q","ｑ":"q","ɋ":"q","ꝗ":"q","ꝙ":"q","ⓡ":"r","ｒ":"r","ŕ":"r","ṙ":"r","ř":"r","ȑ":"r","ȓ":"r","ṛ":"r","ṝ":"r","ŗ":"r","ṟ":"r","ɍ":"r","ɽ":"r","ꝛ":"r","ꞧ":"r","ꞃ":"r","ⓢ":"s","ｓ":"s","ß":"s","ś":"s","ṥ":"s","ŝ":"s","ṡ":"s","š":"s","ṧ":"s","ṣ":"s","ṩ":"s","ș":"s","ş":"s","ȿ":"s","ꞩ":"s","ꞅ":"s","ẛ":"s","ⓣ":"t","ｔ":"t","ṫ":"t","ẗ":"t","ť":"t","ṭ":"t","ț":"t","ţ":"t","ṱ":"t","ṯ":"t","ŧ":"t","ƭ":"t","ʈ":"t","ⱦ":"t","ꞇ":"t","ꜩ":"tz","ⓤ":"u","ｕ":"u","ù":"u","ú":"u","û":"u","ũ":"u","ṹ":"u","ū":"u","ṻ":"u","ŭ":"u","ü":"u","ǜ":"u","ǘ":"u","ǖ":"u","ǚ":"u","ủ":"u","ů":"u","ű":"u","ǔ":"u","ȕ":"u","ȗ":"u","ư":"u","ừ":"u","ứ":"u","ữ":"u","ử":"u","ự":"u","ụ":"u","ṳ":"u","ų":"u","ṷ":"u","ṵ":"u","ʉ":"u","ⓥ":"v","ｖ":"v","ṽ":"v","ṿ":"v","ʋ":"v","ꝟ":"v","ʌ":"v","ꝡ":"vy","ⓦ":"w","ｗ":"w","ẁ":"w","ẃ":"w","ŵ":"w","ẇ":"w","ẅ":"w","ẘ":"w","ẉ":"w","ⱳ":"w","ⓧ":"x","ｘ":"x","ẋ":"x","ẍ":"x","ⓨ":"y","ｙ":"y","ỳ":"y","ý":"y","ŷ":"y","ỹ":"y","ȳ":"y","ẏ":"y","ÿ":"y","ỷ":"y","ẙ":"y","ỵ":"y","ƴ":"y","ɏ":"y","ỿ":"y","ⓩ":"z","ｚ":"z","ź":"z","ẑ":"z","ż":"z","ž":"z","ẓ":"z","ẕ":"z","ƶ":"z","ȥ":"z","ɀ":"z","ⱬ":"z","ꝣ":"z","Ά":"Α","Έ":"Ε","Ή":"Η","Ί":"Ι","Ϊ":"Ι","Ό":"Ο","Ύ":"Υ","Ϋ":"Υ","Ώ":"Ω","ά":"α","έ":"ε","ή":"η","ί":"ι","ϊ":"ι","ΐ":"ι","ό":"ο","ύ":"υ","ϋ":"υ","ΰ":"υ","ω":"ω","ς":"σ"};return a}),b.define("select2/data/base",["../utils"],function(a){function b(a,c){b.__super__.constructor.call(this)}return a.Extend(b,a.Observable),b.prototype.current=function(a){throw new Error("The `current` method must be defined in child classes.")},b.prototype.query=function(a,b){throw new Error("The `query` method must be defined in child classes.")},b.prototype.bind=function(a,b){},b.prototype.destroy=function(){},b.prototype.generateResultId=function(b,c){var d=b.id+"-result-";return d+=a.generateChars(4),d+=null!=c.id?"-"+c.id.toString():"-"+a.generateChars(4)},b}),b.define("select2/data/select",["./base","../utils","jquery"],function(a,b,c){function d(a,b){this.$element=a,this.options=b,d.__super__.constructor.call(this)}return b.Extend(d,a),d.prototype.current=function(a){var b=[],d=this;this.$element.find(":selected").each(function(){var a=c(this),e=d.item(a);b.push(e)}),a(b)},d.prototype.select=function(a){var b=this;if(a.selected=!0,c(a.element).is("option"))return a.element.selected=!0,void this.$element.trigger("change");if(this.$element.prop("multiple"))this.current(function(d){var e=[];a=[a],a.push.apply(a,d);for(var f=0;f<a.length;f++){var g=a[f].id;-1===c.inArray(g,e)&&e.push(g)}b.$element.val(e),b.$element.trigger("change")});else{var d=a.id;this.$element.val(d),this.$element.trigger("change")}},d.prototype.unselect=function(a){var b=this;if(this.$element.prop("multiple"))return a.selected=!1,
c(a.element).is("option")?(a.element.selected=!1,void this.$element.trigger("change")):void this.current(function(d){for(var e=[],f=0;f<d.length;f++){var g=d[f].id;g!==a.id&&-1===c.inArray(g,e)&&e.push(g)}b.$element.val(e),b.$element.trigger("change")})},d.prototype.bind=function(a,b){var c=this;this.container=a,a.on("select",function(a){c.select(a.data)}),a.on("unselect",function(a){c.unselect(a.data)})},d.prototype.destroy=function(){this.$element.find("*").each(function(){c.removeData(this,"data")})},d.prototype.query=function(a,b){var d=[],e=this,f=this.$element.children();f.each(function(){var b=c(this);if(b.is("option")||b.is("optgroup")){var f=e.item(b),g=e.matches(a,f);null!==g&&d.push(g)}}),b({results:d})},d.prototype.addOptions=function(a){b.appendMany(this.$element,a)},d.prototype.option=function(a){var b;a.children?(b=document.createElement("optgroup"),b.label=a.text):(b=document.createElement("option"),void 0!==b.textContent?b.textContent=a.text:b.innerText=a.text),a.id&&(b.value=a.id),a.disabled&&(b.disabled=!0),a.selected&&(b.selected=!0),a.title&&(b.title=a.title);var d=c(b),e=this._normalizeItem(a);return e.element=b,c.data(b,"data",e),d},d.prototype.item=function(a){var b={};if(b=c.data(a[0],"data"),null!=b)return b;if(a.is("option"))b={id:a.val(),text:a.text(),disabled:a.prop("disabled"),selected:a.prop("selected"),title:a.prop("title")};else if(a.is("optgroup")){b={text:a.prop("label"),children:[],title:a.prop("title")};for(var d=a.children("option"),e=[],f=0;f<d.length;f++){var g=c(d[f]),h=this.item(g);e.push(h)}b.children=e}return b=this._normalizeItem(b),b.element=a[0],c.data(a[0],"data",b),b},d.prototype._normalizeItem=function(a){c.isPlainObject(a)||(a={id:a,text:a}),a=c.extend({},{text:""},a);var b={selected:!1,disabled:!1};return null!=a.id&&(a.id=a.id.toString()),null!=a.text&&(a.text=a.text.toString()),null==a._resultId&&a.id&&null!=this.container&&(a._resultId=this.generateResultId(this.container,a)),c.extend({},b,a)},d.prototype.matches=function(a,b){var c=this.options.get("matcher");return c(a,b)},d}),b.define("select2/data/array",["./select","../utils","jquery"],function(a,b,c){function d(a,b){var c=b.get("data")||[];d.__super__.constructor.call(this,a,b),this.addOptions(this.convertToOptions(c))}return b.Extend(d,a),d.prototype.select=function(a){var b=this.$element.find("option").filter(function(b,c){return c.value==a.id.toString()});0===b.length&&(b=this.option(a),this.addOptions(b)),d.__super__.select.call(this,a)},d.prototype.convertToOptions=function(a){function d(a){return function(){return c(this).val()==a.id}}for(var e=this,f=this.$element.find("option"),g=f.map(function(){return e.item(c(this)).id}).get(),h=[],i=0;i<a.length;i++){var j=this._normalizeItem(a[i]);if(c.inArray(j.id,g)>=0){var k=f.filter(d(j)),l=this.item(k),m=c.extend(!0,{},j,l),n=this.option(m);k.replaceWith(n)}else{var o=this.option(j);if(j.children){var p=this.convertToOptions(j.children);b.appendMany(o,p)}h.push(o)}}return h},d}),b.define("select2/data/ajax",["./array","../utils","jquery"],function(a,b,c){function d(a,b){this.ajaxOptions=this._applyDefaults(b.get("ajax")),null!=this.ajaxOptions.processResults&&(this.processResults=this.ajaxOptions.processResults),d.__super__.constructor.call(this,a,b)}return b.Extend(d,a),d.prototype._applyDefaults=function(a){var b={data:function(a){return c.extend({},a,{q:a.term})},transport:function(a,b,d){var e=c.ajax(a);return e.then(b),e.fail(d),e}};return c.extend({},b,a,!0)},d.prototype.processResults=function(a){return a},d.prototype.query=function(a,b){function d(){var d=f.transport(f,function(d){var f=e.processResults(d,a);e.options.get("debug")&&window.console&&console.error&&(f&&f.results&&c.isArray(f.results)||console.error("Select2: The AJAX results did not return an array in the `results` key of the response.")),b(f)},function(){e.trigger("results:message",{message:"errorLoading"})});e._request=d}var e=this;null!=this._request&&(c.isFunction(this._request.abort)&&this._request.abort(),this._request=null);var f=c.extend({type:"GET"},this.ajaxOptions);"function"==typeof f.url&&(f.url=f.url.call(this.$element,a)),"function"==typeof f.data&&(f.data=f.data.call(this.$element,a)),this.ajaxOptions.delay&&""!==a.term?(this._queryTimeout&&window.clearTimeout(this._queryTimeout),this._queryTimeout=window.setTimeout(d,this.ajaxOptions.delay)):d()},d}),b.define("select2/data/tags",["jquery"],function(a){function b(b,c,d){var e=d.get("tags"),f=d.get("createTag");void 0!==f&&(this.createTag=f);var g=d.get("insertTag");if(void 0!==g&&(this.insertTag=g),b.call(this,c,d),a.isArray(e))for(var h=0;h<e.length;h++){var i=e[h],j=this._normalizeItem(i),k=this.option(j);this.$element.append(k)}}return b.prototype.query=function(a,b,c){function d(a,f){for(var g=a.results,h=0;h<g.length;h++){var i=g[h],j=null!=i.children&&!d({results:i.children},!0),k=i.text===b.term;if(k||j)return f?!1:(a.data=g,void c(a))}if(f)return!0;var l=e.createTag(b);if(null!=l){var m=e.option(l);m.attr("data-select2-tag",!0),e.addOptions([m]),e.insertTag(g,l)}a.results=g,c(a)}var e=this;return this._removeOldTags(),null==b.term||null!=b.page?void a.call(this,b,c):void a.call(this,b,d)},b.prototype.createTag=function(b,c){var d=a.trim(c.term);return""===d?null:{id:d,text:d}},b.prototype.insertTag=function(a,b,c){b.unshift(c)},b.prototype._removeOldTags=function(b){var c=(this._lastTag,this.$element.find("option[data-select2-tag]"));c.each(function(){this.selected||a(this).remove()})},b}),b.define("select2/data/tokenizer",["jquery"],function(a){function b(a,b,c){var d=c.get("tokenizer");void 0!==d&&(this.tokenizer=d),a.call(this,b,c)}return b.prototype.bind=function(a,b,c){a.call(this,b,c),this.$search=b.dropdown.$search||b.selection.$search||c.find(".select2-search__field")},b.prototype.query=function(a,b,c){function d(a){e.trigger("select",{data:a})}var e=this;b.term=b.term||"";var f=this.tokenizer(b,this.options,d);f.term!==b.term&&(this.$search.length&&(this.$search.val(f.term),this.$search.focus()),b.term=f.term),a.call(this,b,c)},b.prototype.tokenizer=function(b,c,d,e){for(var f=d.get("tokenSeparators")||[],g=c.term,h=0,i=this.createTag||function(a){return{id:a.term,text:a.term}};h<g.length;){var j=g[h];if(-1!==a.inArray(j,f)){var k=g.substr(0,h),l=a.extend({},c,{term:k}),m=i(l);null!=m?(e(m),g=g.substr(h+1)||"",h=0):h++}else h++}return{term:g}},b}),b.define("select2/data/minimumInputLength",[],function(){function a(a,b,c){this.minimumInputLength=c.get("minimumInputLength"),a.call(this,b,c)}return a.prototype.query=function(a,b,c){return b.term=b.term||"",b.term.length<this.minimumInputLength?void this.trigger("results:message",{message:"inputTooShort",args:{minimum:this.minimumInputLength,input:b.term,params:b}}):void a.call(this,b,c)},a}),b.define("select2/data/maximumInputLength",[],function(){function a(a,b,c){this.maximumInputLength=c.get("maximumInputLength"),a.call(this,b,c)}return a.prototype.query=function(a,b,c){return b.term=b.term||"",this.maximumInputLength>0&&b.term.length>this.maximumInputLength?void this.trigger("results:message",{message:"inputTooLong",args:{maximum:this.maximumInputLength,input:b.term,params:b}}):void a.call(this,b,c)},a}),b.define("select2/data/maximumSelectionLength",[],function(){function a(a,b,c){this.maximumSelectionLength=c.get("maximumSelectionLength"),a.call(this,b,c)}return a.prototype.query=function(a,b,c){var d=this;this.current(function(e){var f=null!=e?e.length:0;return d.maximumSelectionLength>0&&f>=d.maximumSelectionLength?void d.trigger("results:message",{message:"maximumSelected",args:{maximum:d.maximumSelectionLength}}):void a.call(d,b,c)})},a}),b.define("select2/dropdown",["jquery","./utils"],function(a,b){function c(a,b){this.$element=a,this.options=b,c.__super__.constructor.call(this)}return b.Extend(c,b.Observable),c.prototype.render=function(){var b=a('<span class="select2-dropdown"><span class="select2-results"></span></span>');return b.attr("dir",this.options.get("dir")),this.$dropdown=b,b},c.prototype.bind=function(){},c.prototype.position=function(a,b){},c.prototype.destroy=function(){this.$dropdown.remove()},c}),b.define("select2/dropdown/search",["jquery","../utils"],function(a,b){function c(){}return c.prototype.render=function(b){var c=b.call(this),d=a('<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" /></span>');return this.$searchContainer=d,this.$search=d.find("input"),c.prepend(d),c},c.prototype.bind=function(b,c,d){var e=this;b.call(this,c,d),this.$search.on("keydown",function(a){e.trigger("keypress",a),e._keyUpPrevented=a.isDefaultPrevented()}),this.$search.on("input",function(b){a(this).off("keyup")}),this.$search.on("keyup input",function(a){e.handleSearch(a)}),c.on("open",function(){e.$search.attr("tabindex",0),e.$search.focus(),window.setTimeout(function(){e.$search.focus()},0)}),c.on("close",function(){e.$search.attr("tabindex",-1),e.$search.val("")}),c.on("results:all",function(a){if(null==a.query.term||""===a.query.term){var b=e.showSearch(a);b?e.$searchContainer.removeClass("select2-search--hide"):e.$searchContainer.addClass("select2-search--hide")}})},c.prototype.handleSearch=function(a){if(!this._keyUpPrevented){var b=this.$search.val();this.trigger("query",{term:b})}this._keyUpPrevented=!1},c.prototype.showSearch=function(a,b){return!0},c}),b.define("select2/dropdown/hidePlaceholder",[],function(){function a(a,b,c,d){this.placeholder=this.normalizePlaceholder(c.get("placeholder")),a.call(this,b,c,d)}return a.prototype.append=function(a,b){b.results=this.removePlaceholder(b.results),a.call(this,b)},a.prototype.normalizePlaceholder=function(a,b){return"string"==typeof b&&(b={id:"",text:b}),b},a.prototype.removePlaceholder=function(a,b){for(var c=b.slice(0),d=b.length-1;d>=0;d--){var e=b[d];this.placeholder.id===e.id&&c.splice(d,1)}return c},a}),b.define("select2/dropdown/infiniteScroll",["jquery"],function(a){function b(a,b,c,d){this.lastParams={},a.call(this,b,c,d),this.$loadingMore=this.createLoadingMore(),this.loading=!1}return b.prototype.append=function(a,b){this.$loadingMore.remove(),this.loading=!1,a.call(this,b),this.showLoadingMore(b)&&this.$results.append(this.$loadingMore)},b.prototype.bind=function(b,c,d){var e=this;b.call(this,c,d),c.on("query",function(a){e.lastParams=a,e.loading=!0}),c.on("query:append",function(a){e.lastParams=a,e.loading=!0}),this.$results.on("scroll",function(){var b=a.contains(document.documentElement,e.$loadingMore[0]);if(!e.loading&&b){var c=e.$results.offset().top+e.$results.outerHeight(!1),d=e.$loadingMore.offset().top+e.$loadingMore.outerHeight(!1);c+50>=d&&e.loadMore()}})},b.prototype.loadMore=function(){this.loading=!0;var b=a.extend({},{page:1},this.lastParams);b.page++,this.trigger("query:append",b)},b.prototype.showLoadingMore=function(a,b){return b.pagination&&b.pagination.more},b.prototype.createLoadingMore=function(){var b=a('<li class="select2-results__option select2-results__option--load-more"role="treeitem" aria-disabled="true"></li>'),c=this.options.get("translations").get("loadingMore");return b.html(c(this.lastParams)),b},b}),b.define("select2/dropdown/attachBody",["jquery","../utils"],function(a,b){function c(b,c,d){this.$dropdownParent=d.get("dropdownParent")||a(document.body),b.call(this,c,d)}return c.prototype.bind=function(a,b,c){var d=this,e=!1;a.call(this,b,c),b.on("open",function(){d._showDropdown(),d._attachPositioningHandler(b),e||(e=!0,b.on("results:all",function(){d._positionDropdown(),d._resizeDropdown()}),b.on("results:append",function(){d._positionDropdown(),d._resizeDropdown()}))}),b.on("close",function(){d._hideDropdown(),d._detachPositioningHandler(b)}),this.$dropdownContainer.on("mousedown",function(a){a.stopPropagation()})},c.prototype.destroy=function(a){a.call(this),this.$dropdownContainer.remove()},c.prototype.position=function(a,b,c){b.attr("class",c.attr("class")),b.removeClass("select2"),b.addClass("select2-container--open"),b.css({position:"absolute",top:-999999}),this.$container=c},c.prototype.render=function(b){var c=a("<span></span>"),d=b.call(this);return c.append(d),this.$dropdownContainer=c,c},c.prototype._hideDropdown=function(a){this.$dropdownContainer.detach()},c.prototype._attachPositioningHandler=function(c,d){var e=this,f="scroll.select2."+d.id,g="resize.select2."+d.id,h="orientationchange.select2."+d.id,i=this.$container.parents().filter(b.hasScroll);i.each(function(){a(this).data("select2-scroll-position",{x:a(this).scrollLeft(),y:a(this).scrollTop()})}),i.on(f,function(b){var c=a(this).data("select2-scroll-position");a(this).scrollTop(c.y)}),a(window).on(f+" "+g+" "+h,function(a){e._positionDropdown(),e._resizeDropdown()})},c.prototype._detachPositioningHandler=function(c,d){var e="scroll.select2."+d.id,f="resize.select2."+d.id,g="orientationchange.select2."+d.id,h=this.$container.parents().filter(b.hasScroll);h.off(e),a(window).off(e+" "+f+" "+g)},c.prototype._positionDropdown=function(){var b=a(window),c=this.$dropdown.hasClass("select2-dropdown--above"),d=this.$dropdown.hasClass("select2-dropdown--below"),e=null,f=this.$container.offset();f.bottom=f.top+this.$container.outerHeight(!1);var g={height:this.$container.outerHeight(!1)};g.top=f.top,g.bottom=f.top+g.height;var h={height:this.$dropdown.outerHeight(!1)},i={top:b.scrollTop(),bottom:b.scrollTop()+b.height()},j=i.top<f.top-h.height,k=i.bottom>f.bottom+h.height,l={left:f.left,top:g.bottom},m=this.$dropdownParent;"static"===m.css("position")&&(m=m.offsetParent());var n=m.offset();l.top-=n.top,l.left-=n.left,c||d||(e="below"),k||!j||c?!j&&k&&c&&(e="below"):e="above",("above"==e||c&&"below"!==e)&&(l.top=g.top-h.height),null!=e&&(this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--"+e),this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--"+e)),this.$dropdownContainer.css(l)},c.prototype._resizeDropdown=function(){var a={width:this.$container.outerWidth(!1)+"px"};this.options.get("dropdownAutoWidth")&&(a.minWidth=a.width,a.width="auto"),this.$dropdown.css(a)},c.prototype._showDropdown=function(a){this.$dropdownContainer.appendTo(this.$dropdownParent),this._positionDropdown(),this._resizeDropdown()},c}),b.define("select2/dropdown/minimumResultsForSearch",[],function(){function a(b){for(var c=0,d=0;d<b.length;d++){var e=b[d];e.children?c+=a(e.children):c++}return c}function b(a,b,c,d){this.minimumResultsForSearch=c.get("minimumResultsForSearch"),this.minimumResultsForSearch<0&&(this.minimumResultsForSearch=1/0),a.call(this,b,c,d)}return b.prototype.showSearch=function(b,c){return a(c.data.results)<this.minimumResultsForSearch?!1:b.call(this,c)},b}),b.define("select2/dropdown/selectOnClose",[],function(){function a(){}return a.prototype.bind=function(a,b,c){var d=this;a.call(this,b,c),b.on("close",function(){d._handleSelectOnClose()})},a.prototype._handleSelectOnClose=function(){var a=this.getHighlightedResults();if(!(a.length<1)){var b=a.data("data");null!=b.element&&b.element.selected||null==b.element&&b.selected||this.trigger("select",{data:b})}},a}),b.define("select2/dropdown/closeOnSelect",[],function(){function a(){}return a.prototype.bind=function(a,b,c){var d=this;a.call(this,b,c),b.on("select",function(a){d._selectTriggered(a)}),b.on("unselect",function(a){d._selectTriggered(a)})},a.prototype._selectTriggered=function(a,b){var c=b.originalEvent;c&&c.ctrlKey||this.trigger("close",{})},a}),b.define("select2/i18n/en",[],function(){return{errorLoading:function(){return"The results could not be loaded."},inputTooLong:function(a){var b=a.input.length-a.maximum,c="Please delete "+b+" character";return 1!=b&&(c+="s"),c},inputTooShort:function(a){var b=a.minimum-a.input.length,c="Please enter "+b+" or more characters";return c},loadingMore:function(){return"Loading more results…"},maximumSelected:function(a){var b="You can only select "+a.maximum+" item";return 1!=a.maximum&&(b+="s"),b},noResults:function(){return"No results found"},searching:function(){return"Searching…"}}}),b.define("select2/defaults",["jquery","require","./results","./selection/single","./selection/multiple","./selection/placeholder","./selection/allowClear","./selection/search","./selection/eventRelay","./utils","./translation","./diacritics","./data/select","./data/array","./data/ajax","./data/tags","./data/tokenizer","./data/minimumInputLength","./data/maximumInputLength","./data/maximumSelectionLength","./dropdown","./dropdown/search","./dropdown/hidePlaceholder","./dropdown/infiniteScroll","./dropdown/attachBody","./dropdown/minimumResultsForSearch","./dropdown/selectOnClose","./dropdown/closeOnSelect","./i18n/en"],function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C){function D(){this.reset()}D.prototype.apply=function(l){if(l=a.extend(!0,{},this.defaults,l),null==l.dataAdapter){if(null!=l.ajax?l.dataAdapter=o:null!=l.data?l.dataAdapter=n:l.dataAdapter=m,l.minimumInputLength>0&&(l.dataAdapter=j.Decorate(l.dataAdapter,r)),l.maximumInputLength>0&&(l.dataAdapter=j.Decorate(l.dataAdapter,s)),l.maximumSelectionLength>0&&(l.dataAdapter=j.Decorate(l.dataAdapter,t)),l.tags&&(l.dataAdapter=j.Decorate(l.dataAdapter,p)),(null!=l.tokenSeparators||null!=l.tokenizer)&&(l.dataAdapter=j.Decorate(l.dataAdapter,q)),null!=l.query){var C=b(l.amdBase+"compat/query");l.dataAdapter=j.Decorate(l.dataAdapter,C)}if(null!=l.initSelection){var D=b(l.amdBase+"compat/initSelection");l.dataAdapter=j.Decorate(l.dataAdapter,D)}}if(null==l.resultsAdapter&&(l.resultsAdapter=c,null!=l.ajax&&(l.resultsAdapter=j.Decorate(l.resultsAdapter,x)),null!=l.placeholder&&(l.resultsAdapter=j.Decorate(l.resultsAdapter,w)),l.selectOnClose&&(l.resultsAdapter=j.Decorate(l.resultsAdapter,A))),null==l.dropdownAdapter){if(l.multiple)l.dropdownAdapter=u;else{var E=j.Decorate(u,v);l.dropdownAdapter=E}if(0!==l.minimumResultsForSearch&&(l.dropdownAdapter=j.Decorate(l.dropdownAdapter,z)),l.closeOnSelect&&(l.dropdownAdapter=j.Decorate(l.dropdownAdapter,B)),null!=l.dropdownCssClass||null!=l.dropdownCss||null!=l.adaptDropdownCssClass){var F=b(l.amdBase+"compat/dropdownCss");l.dropdownAdapter=j.Decorate(l.dropdownAdapter,F)}l.dropdownAdapter=j.Decorate(l.dropdownAdapter,y)}if(null==l.selectionAdapter){if(l.multiple?l.selectionAdapter=e:l.selectionAdapter=d,null!=l.placeholder&&(l.selectionAdapter=j.Decorate(l.selectionAdapter,f)),l.allowClear&&(l.selectionAdapter=j.Decorate(l.selectionAdapter,g)),l.multiple&&(l.selectionAdapter=j.Decorate(l.selectionAdapter,h)),null!=l.containerCssClass||null!=l.containerCss||null!=l.adaptContainerCssClass){var G=b(l.amdBase+"compat/containerCss");l.selectionAdapter=j.Decorate(l.selectionAdapter,G)}l.selectionAdapter=j.Decorate(l.selectionAdapter,i)}if("string"==typeof l.language)if(l.language.indexOf("-")>0){var H=l.language.split("-"),I=H[0];l.language=[l.language,I]}else l.language=[l.language];if(a.isArray(l.language)){var J=new k;l.language.push("en");for(var K=l.language,L=0;L<K.length;L++){var M=K[L],N={};try{N=k.loadPath(M)}catch(O){try{M=this.defaults.amdLanguageBase+M,N=k.loadPath(M)}catch(P){l.debug&&window.console&&console.warn&&console.warn('Select2: The language file for "'+M+'" could not be automatically loaded. A fallback will be used instead.');continue}}J.extend(N)}l.translations=J}else{var Q=k.loadPath(this.defaults.amdLanguageBase+"en"),R=new k(l.language);R.extend(Q),l.translations=R}return l},D.prototype.reset=function(){function b(a){function b(a){return l[a]||a}return a.replace(/[^\u0000-\u007E]/g,b)}function c(d,e){if(""===a.trim(d.term))return e;if(e.children&&e.children.length>0){for(var f=a.extend(!0,{},e),g=e.children.length-1;g>=0;g--){var h=e.children[g],i=c(d,h);null==i&&f.children.splice(g,1)}return f.children.length>0?f:c(d,f)}var j=b(e.text).toUpperCase(),k=b(d.term).toUpperCase();return j.indexOf(k)>-1?e:null}this.defaults={amdBase:"./",amdLanguageBase:"./i18n/",closeOnSelect:!0,debug:!1,dropdownAutoWidth:!1,escapeMarkup:j.escapeMarkup,language:C,matcher:c,minimumInputLength:0,maximumInputLength:0,maximumSelectionLength:0,minimumResultsForSearch:0,selectOnClose:!1,sorter:function(a){return a},templateResult:function(a){return a.text},templateSelection:function(a){return a.text},theme:"default",width:"resolve"}},D.prototype.set=function(b,c){var d=a.camelCase(b),e={};e[d]=c;var f=j._convertData(e);a.extend(this.defaults,f)};var E=new D;return E}),b.define("select2/options",["require","jquery","./defaults","./utils"],function(a,b,c,d){function e(b,e){if(this.options=b,null!=e&&this.fromElement(e),this.options=c.apply(this.options),e&&e.is("input")){var f=a(this.get("amdBase")+"compat/inputData");this.options.dataAdapter=d.Decorate(this.options.dataAdapter,f)}}return e.prototype.fromElement=function(a){var c=["select2"];null==this.options.multiple&&(this.options.multiple=a.prop("multiple")),null==this.options.disabled&&(this.options.disabled=a.prop("disabled")),null==this.options.language&&(a.prop("lang")?this.options.language=a.prop("lang").toLowerCase():a.closest("[lang]").prop("lang")&&(this.options.language=a.closest("[lang]").prop("lang"))),null==this.options.dir&&(a.prop("dir")?this.options.dir=a.prop("dir"):a.closest("[dir]").prop("dir")?this.options.dir=a.closest("[dir]").prop("dir"):this.options.dir="ltr"),a.prop("disabled",this.options.disabled),a.prop("multiple",this.options.multiple),a.data("select2Tags")&&(this.options.debug&&window.console&&console.warn&&console.warn('Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'),a.data("data",a.data("select2Tags")),a.data("tags",!0)),a.data("ajaxUrl")&&(this.options.debug&&window.console&&console.warn&&console.warn("Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."),a.attr("ajax--url",a.data("ajaxUrl")),a.data("ajax--url",a.data("ajaxUrl")));var e={};e=b.fn.jquery&&"1."==b.fn.jquery.substr(0,2)&&a[0].dataset?b.extend(!0,{},a[0].dataset,a.data()):a.data();var f=b.extend(!0,{},e);f=d._convertData(f);for(var g in f)b.inArray(g,c)>-1||(b.isPlainObject(this.options[g])?b.extend(this.options[g],f[g]):this.options[g]=f[g]);return this},e.prototype.get=function(a){return this.options[a]},e.prototype.set=function(a,b){this.options[a]=b},e}),b.define("select2/core",["jquery","./options","./utils","./keys"],function(a,b,c,d){var e=function(a,c){null!=a.data("select2")&&a.data("select2").destroy(),this.$element=a,this.id=this._generateId(a),c=c||{},this.options=new b(c,a),e.__super__.constructor.call(this);var d=a.attr("tabindex")||0;a.data("old-tabindex",d),a.attr("tabindex","-1");var f=this.options.get("dataAdapter");this.dataAdapter=new f(a,this.options);var g=this.render();this._placeContainer(g);var h=this.options.get("selectionAdapter");this.selection=new h(a,this.options),this.$selection=this.selection.render(),this.selection.position(this.$selection,g);var i=this.options.get("dropdownAdapter");this.dropdown=new i(a,this.options),this.$dropdown=this.dropdown.render(),this.dropdown.position(this.$dropdown,g);var j=this.options.get("resultsAdapter");this.results=new j(a,this.options,this.dataAdapter),this.$results=this.results.render(),this.results.position(this.$results,this.$dropdown);var k=this;this._bindAdapters(),this._registerDomEvents(),this._registerDataEvents(),this._registerSelectionEvents(),this._registerDropdownEvents(),this._registerResultsEvents(),this._registerEvents(),this.dataAdapter.current(function(a){k.trigger("selection:update",{data:a})}),a.addClass("select2-hidden-accessible"),a.attr("aria-hidden","true"),this._syncAttributes(),a.data("select2",this)};return c.Extend(e,c.Observable),e.prototype._generateId=function(a){var b="";return b=null!=a.attr("id")?a.attr("id"):null!=a.attr("name")?a.attr("name")+"-"+c.generateChars(2):c.generateChars(4),b=b.replace(/(:|\.|\[|\]|,)/g,""),b="select2-"+b},e.prototype._placeContainer=function(a){a.insertAfter(this.$element);var b=this._resolveWidth(this.$element,this.options.get("width"));null!=b&&a.css("width",b)},e.prototype._resolveWidth=function(a,b){var c=/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;if("resolve"==b){var d=this._resolveWidth(a,"style");return null!=d?d:this._resolveWidth(a,"element")}if("element"==b){var e=a.outerWidth(!1);return 0>=e?"auto":e+"px"}if("style"==b){var f=a.attr("style");if("string"!=typeof f)return null;for(var g=f.split(";"),h=0,i=g.length;i>h;h+=1){var j=g[h].replace(/\s/g,""),k=j.match(c);if(null!==k&&k.length>=1)return k[1]}return null}return b},e.prototype._bindAdapters=function(){this.dataAdapter.bind(this,this.$container),this.selection.bind(this,this.$container),this.dropdown.bind(this,this.$container),this.results.bind(this,this.$container)},e.prototype._registerDomEvents=function(){var b=this;this.$element.on("change.select2",function(){b.dataAdapter.current(function(a){b.trigger("selection:update",{data:a})})}),this._sync=c.bind(this._syncAttributes,this),this.$element[0].attachEvent&&this.$element[0].attachEvent("onpropertychange",this._sync);var d=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;null!=d?(this._observer=new d(function(c){a.each(c,b._sync)}),this._observer.observe(this.$element[0],{attributes:!0,subtree:!1})):this.$element[0].addEventListener&&this.$element[0].addEventListener("DOMAttrModified",b._sync,!1)},e.prototype._registerDataEvents=function(){var a=this;this.dataAdapter.on("*",function(b,c){a.trigger(b,c)})},e.prototype._registerSelectionEvents=function(){var b=this,c=["toggle","focus"];this.selection.on("toggle",function(){b.toggleDropdown()}),this.selection.on("focus",function(a){b.focus(a)}),this.selection.on("*",function(d,e){-1===a.inArray(d,c)&&b.trigger(d,e)})},e.prototype._registerDropdownEvents=function(){var a=this;this.dropdown.on("*",function(b,c){a.trigger(b,c)})},e.prototype._registerResultsEvents=function(){var a=this;this.results.on("*",function(b,c){a.trigger(b,c)})},e.prototype._registerEvents=function(){var a=this;this.on("open",function(){a.$container.addClass("select2-container--open")}),this.on("close",function(){a.$container.removeClass("select2-container--open")}),this.on("enable",function(){a.$container.removeClass("select2-container--disabled")}),this.on("disable",function(){a.$container.addClass("select2-container--disabled")}),this.on("blur",function(){a.$container.removeClass("select2-container--focus")}),this.on("query",function(b){a.isOpen()||a.trigger("open",{}),this.dataAdapter.query(b,function(c){a.trigger("results:all",{data:c,query:b})})}),this.on("query:append",function(b){this.dataAdapter.query(b,function(c){a.trigger("results:append",{data:c,query:b})})}),this.on("keypress",function(b){var c=b.which;a.isOpen()?c===d.ESC||c===d.TAB||c===d.UP&&b.altKey?(a.close(),b.preventDefault()):c===d.ENTER?(a.trigger("results:select",{}),b.preventDefault()):c===d.SPACE&&b.ctrlKey?(a.trigger("results:toggle",{}),b.preventDefault()):c===d.UP?(a.trigger("results:previous",{}),b.preventDefault()):c===d.DOWN&&(a.trigger("results:next",{}),b.preventDefault()):(c===d.ENTER||c===d.SPACE||c===d.DOWN&&b.altKey)&&(a.open(),b.preventDefault())})},e.prototype._syncAttributes=function(){this.options.set("disabled",this.$element.prop("disabled")),this.options.get("disabled")?(this.isOpen()&&this.close(),this.trigger("disable",{})):this.trigger("enable",{})},e.prototype.trigger=function(a,b){var c=e.__super__.trigger,d={open:"opening",close:"closing",select:"selecting",unselect:"unselecting"};if(void 0===b&&(b={}),a in d){var f=d[a],g={prevented:!1,name:a,args:b};if(c.call(this,f,g),g.prevented)return void(b.prevented=!0)}c.call(this,a,b)},e.prototype.toggleDropdown=function(){this.options.get("disabled")||(this.isOpen()?this.close():this.open())},e.prototype.open=function(){this.isOpen()||this.trigger("query",{})},e.prototype.close=function(){this.isOpen()&&this.trigger("close",{})},e.prototype.isOpen=function(){return this.$container.hasClass("select2-container--open")},e.prototype.hasFocus=function(){return this.$container.hasClass("select2-container--focus")},e.prototype.focus=function(a){this.hasFocus()||(this.$container.addClass("select2-container--focus"),this.trigger("focus",{}))},e.prototype.enable=function(a){this.options.get("debug")&&window.console&&console.warn&&console.warn('Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'),(null==a||0===a.length)&&(a=[!0]);var b=!a[0];this.$element.prop("disabled",b)},e.prototype.data=function(){this.options.get("debug")&&arguments.length>0&&window.console&&console.warn&&console.warn('Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.');var a=[];return this.dataAdapter.current(function(b){a=b}),a},e.prototype.val=function(b){if(this.options.get("debug")&&window.console&&console.warn&&console.warn('Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'),null==b||0===b.length)return this.$element.val();var c=b[0];a.isArray(c)&&(c=a.map(c,function(a){return a.toString()})),this.$element.val(c).trigger("change")},e.prototype.destroy=function(){this.$container.remove(),this.$element[0].detachEvent&&this.$element[0].detachEvent("onpropertychange",this._sync),null!=this._observer?(this._observer.disconnect(),this._observer=null):this.$element[0].removeEventListener&&this.$element[0].removeEventListener("DOMAttrModified",this._sync,!1),this._sync=null,this.$element.off(".select2"),this.$element.attr("tabindex",this.$element.data("old-tabindex")),this.$element.removeClass("select2-hidden-accessible"),this.$element.attr("aria-hidden","false"),this.$element.removeData("select2"),this.dataAdapter.destroy(),this.selection.destroy(),this.dropdown.destroy(),this.results.destroy(),this.dataAdapter=null,this.selection=null,this.dropdown=null,this.results=null},e.prototype.render=function(){var b=a('<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>');return b.attr("dir",this.options.get("dir")),this.$container=b,this.$container.addClass("select2-container--"+this.options.get("theme")),b.data("element",this.$element),b},e}),b.define("jquery-mousewheel",["jquery"],function(a){return a}),b.define("jquery.select2",["jquery","jquery-mousewheel","./select2/core","./select2/defaults"],function(a,b,c,d){if(null==a.fn.select2){var e=["open","close","destroy"];a.fn.select2=function(b){if(b=b||{},"object"==typeof b)return this.each(function(){var d=a.extend(!0,{},b);new c(a(this),d)}),this;if("string"==typeof b){var d;return this.each(function(){var c=a(this).data("select2");null==c&&window.console&&console.error&&console.error("The select2('"+b+"') method was called on an element that is not using Select2.");var e=Array.prototype.slice.call(arguments,1);d=c[b].apply(c,e)}),a.inArray(b,e)>-1?this:d}throw new Error("Invalid arguments for Select2: "+b)}}return null==a.fn.select2.defaults&&(a.fn.select2.defaults=d),c}),{define:b.define,require:b.require}}(),c=b.require("jquery.select2");return a.fn.select2.amd=b,c});
"use strict";

angular.module('config', [])

.constant('ENV', {stationArtUrl:'https://media.cloudcovermusic.com/stationart/',name:'local_development_environment',version:'5.4.40-4',debug:true,apiUrl:'https://api-dev-c.cloudcovermusic.com',webUrl:'http://localhost:9001',deviceStateUrl:'https://api-dev.cloudcovermusic.com/device-state',intercomAppId:'xoqzlebt',recurly:'cloudcovermusic-dev',recurlyPublicKey:'ewr1-jd00BOBJigdVnTQFQEmSak',recurlyFraudDetectionEnabled:true,duo:{apiHostname:'api-5c2606f7.duosecurity.com'},featureFlags:{prop65:false,artistRadio:true}})

;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    },
    configurable: true,
    writable: true
  });
}

if (!Object.values) {
  Object.values = function values(obj) {
    return Object.keys(obj).map(function (e) { return obj[e]; });
  };
}
window.config = {
  autologinExpiry: 30, // in days
  debugMode: true,
  debug: function() {
    window.config.debugMode = true;
  }
};

window.timeZones = [
  'US/Eastern',
  'US/Central',
  'US/Mountain',
  'US/Arizona',
  'US/Pacific',
  'US/Alaska',
  'US/Hawaii',
  'Canada/Newfoundland',
  'Canada/Atlantic',
  'Canada/Eastern',
  'Canada/Central',
  'Canada/Saskatchewan',
  'Canada/Mountain',
  'Canada/Pacific',
  'Canada/Yukon'
];

window.countries = [
  { name: 'United States', abbreviation: 'US' },
  { name: 'Canada', abbreviation: 'CA' }
];

window.statesProvinces = [
  { name: 'Alabama', abbreviation: 'AL', country: 'US' },
  { name: 'Alaska', abbreviation: 'AK', country: 'US' },
  { name: 'Alberta', abbreviation: 'AB', country: 'CA' },
  { name: 'American Samoa', abbreviation: 'AS', country: 'US' },
  { name: 'Arizona', abbreviation: 'AZ', country: 'US' },
  { name: 'Arkansas', abbreviation: 'AR', country: 'US' },
  { name: 'British Columbia', abbreviation: 'BC', country: 'CA' },
  { name: 'California', abbreviation: 'CA', country: 'US' },
  { name: 'Colorado', abbreviation: 'CO', country: 'US' },
  { name: 'Connecticut', abbreviation: 'CT', country: 'US' },
  { name: 'Delaware', abbreviation: 'DE', country: 'US' },
  { name: 'District of Columbia', abbreviation: 'DC', country: 'US' },
  { name: 'Federated States of Micronesia', abbreviation: 'FM', country: 'US' },
  { name: 'Florida', abbreviation: 'FL', country: 'US' },
  { name: 'Georgia', abbreviation: 'GA', country: 'US' },
  { name: 'Guam', abbreviation: 'GU', country: 'US' },
  { name: 'Hawaii', abbreviation: 'HI', country: 'US' },
  { name: 'Idaho', abbreviation: 'ID', country: 'US' },
  { name: 'Illinois', abbreviation: 'IL', country: 'US' },
  { name: 'Indiana', abbreviation: 'IN', country: 'US' },
  { name: 'Iowa', abbreviation: 'IA', country: 'US' },
  { name: 'Kansas', abbreviation: 'KS', country: 'US' },
  { name: 'Kentucky', abbreviation: 'KY', country: 'US' },
  { name: 'Louisiana', abbreviation: 'LA', country: 'US' },
  { name: 'Maine', abbreviation: 'ME', country: 'US' },
  { name: 'Manitoba', abbreviation: 'MB', country: 'CA' },
  { name: 'Marshall Islands', abbreviation: 'MH', country: 'US' },
  { name: 'Maryland', abbreviation: 'MD', country: 'US' },
  { name: 'Massachusetts', abbreviation: 'MA', country: 'US' },
  { name: 'Michigan', abbreviation: 'MI', country: 'US' },
  { name: 'Minnesota', abbreviation: 'MN', country: 'US' },
  { name: 'Mississippi', abbreviation: 'MS', country: 'US' },
  { name: 'Missouri', abbreviation: 'MO', country: 'US' },
  { name: 'Montana', abbreviation: 'MT', country: 'US' },
  { name: 'Nebraska', abbreviation: 'NE', country: 'US' },
  { name: 'Nevada', abbreviation: 'NV', country: 'US' },
  { name: 'New Brunswick', abbreviation: 'NB', country: 'CA' },
  { name: 'New Hampshire', abbreviation: 'NH', country: 'US' },
  { name: 'New Jersey', abbreviation: 'NJ', country: 'US' },
  { name: 'New Mexico', abbreviation: 'NM', country: 'US' },
  { name: 'New York', abbreviation: 'NY', country: 'US' },
  { name: 'Newfoundland and Labrador', abbreviation: 'NL', country: 'CA' },
  { name: 'North Carolina', abbreviation: 'NC', country: 'US' },
  { name: 'North Dakota', abbreviation: 'ND', country: 'US' },
  { name: 'Northern Mariana Islands', abbreviation: 'MP', country: 'US' },
  { name: 'Northwest Territories', abbreviation: 'NT', country: 'CA' },
  { name: 'Nova Scotia', abbreviation: 'NS', country: 'CA' },
  { name: 'Nunavut', abbreviation: 'NU', country: 'CA' },
  { name: 'Ohio', abbreviation: 'OH', country: 'US' },
  { name: 'Oklahoma', abbreviation: 'OK', country: 'US' },
  { name: 'Ontario', abbreviation: 'ON', country: 'CA' },
  { name: 'Oregon', abbreviation: 'OR', country: 'US' },
  { name: 'Palau', abbreviation: 'PW', country: 'US' },
  { name: 'Pennsylvania', abbreviation: 'PA', country: 'US' },
  { name: 'Prince Edward Island', abbreviation: 'PE', country: 'CA' },
  { name: 'Puerto Rico', abbreviation: 'PR', country: 'US' },
  { name: 'Quebec', abbreviation: 'QC', country: 'CA' },
  { name: 'Rhode Island', abbreviation: 'RI', country: 'US' },
  { name: 'Saskatchewan', abbreviation: 'SK', country: 'CA' },
  { name: 'South Carolina', abbreviation: 'SC', country: 'US' },
  { name: 'South Dakota', abbreviation: 'SD', country: 'US' },
  { name: 'Tennessee', abbreviation: 'TN', country: 'US' },
  { name: 'Texas', abbreviation: 'TX', country: 'US' },
  { name: 'Utah', abbreviation: 'UT', country: 'US' },
  { name: 'Vermont', abbreviation: 'VT', country: 'US' },
  { name: 'Virgin Islands', abbreviation: 'VI', country: 'US' },
  { name: 'Virginia', abbreviation: 'VA', country: 'US' },
  { name: 'Washington', abbreviation: 'WA', country: 'US' },
  { name: 'West Virginia', abbreviation: 'WV', country: 'US' },
  { name: 'Wisconsin', abbreviation: 'WI', country: 'US' },
  { name: 'Wyoming', abbreviation: 'WY', country: 'US' },
  { name: 'Yukon', abbreviation: 'YT', country: 'CA' }
];

var BrowserDetect = {
  init: function() {
    this.browser = this.searchString(this.dataBrowser) || 'An unknown browser';
    this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || 'an unknown version';
    this.OS = this.searchString(this.dataOS) || 'an unknown OS';
    this.mobile = this.isMobile.any();
  },

  browserInfo: function() {
    return {
      browser: this.browser,
      version: this.version,
      os: this.OS,
      mobile: this.mobile
    };
  },

  searchString: function(data) {
    for (var i = 0; i < data.length; i++) {
      var dataString = data[i].string;
      var dataProp = data[i].prop;
      this.versionSearchString = data[i].versionSearch || data[i].identity;
      if (dataString) {
        if (dataString.indexOf(data[i].subString) != -1)
          return data[i].identity;
      } else if (dataProp)
        return data[i].identity;
    }
  },

  searchVersion: function(dataString) {
    if (dataString.match(/Google Page Speed Insights/i)) return 9000;
    if (dataString.match(/pingdom/i)) return 9000;
    var index = dataString.indexOf(this.versionSearchString);
    if (index == -1) return;
    return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
  },

  dataBrowser: [
    { string: navigator.userAgent, subString: 'Edge', identity: 'Edge' },
    { string: navigator.userAgent, subString: 'Chrome', identity: 'Chrome' },
    { string: navigator.userAgent, subString: 'Google Page Speed Insights', identity: 'Chrome' },
    { string: navigator.userAgent, subString: 'pingdom', identity: 'Chrome' },
    { string: navigator.userAgent, subString: 'OmniWeb', versionSearch: 'OmniWeb/', identity: 'OmniWeb' },
    { string: navigator.vendor, subString: 'Apple', identity: 'Safari', versionSearch: 'Version' },
    { prop: window.opera, identity: 'Opera', versionSearch: 'Version' },
    { string: navigator.vendor, subString: 'iCab', identity: 'iCab' },
    { string: navigator.vendor, subString: 'KDE', identity: 'Konqueror' },
    { string: navigator.userAgent, subString: 'Firefox', identity: 'Firefox' },
    { string: navigator.vendor, subString: 'Camino', identity: 'Camino' },
    { string: navigator.userAgent, subString: 'Netscape', identity: 'Netscape' },
    { string: navigator.userAgent, subString: 'MSIE', identity: 'Explorer', versionSearch: 'MSIE' },
    { string: navigator.userAgent, subString: 'Gecko', identity: 'Explorer', versionSearch: 'rv' },
    { string: navigator.userAgent, subString: 'Mozilla', identity: 'Netscape', versionSearch: 'Mozilla' },
    { string: navigator.userAgent, subString: 'Silk', identity: 'Silk' },
    { string: navigator.userAgent, subString: 'AppleWebKit', versionSearch: 'AppleWebKit/', identity: 'Safari' }
  ],

  dataOS: [
    { string: navigator.platform, subString: 'Win', identity: 'Windows' },
    { string: navigator.platform, subString: 'Mac', identity: 'Mac' },
    { string: navigator.userAgent, subString: 'iPhone', identity: 'iOS' },
    { string: navigator.userAgent, subString: 'iPad', identity: 'iOS' },
    { string: navigator.userAgent, subString: 'Android', identity: 'Android' },
    { string: navigator.userAgent, subString: 'android', identity: 'Android' },
    { string: navigator.platform, subString: 'Linux', identity: 'Linux' }],

  digitalSignage: function () {
    var match = navigator.userAgent.match(/Chrome/i) &&
      navigator.userAgent.match(/Crosswalk/i) &&
      navigator.userAgent.match(/Safari/i);
    if (match) {
      console.log('digital signage!!!');
    }

    return match;
  },

  isMobile: {
    Android: function() {
      return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function() {
      return navigator.userAgent.match(/BlackBerry/i);
    },
    Amazon: function() {
      return navigator.userAgent.match(/Silk/);
    },
    iOS: function() {
      if (
        navigator.platform === 'iPhone' ||
        navigator.platform === 'iPad' ||
        navigator.platform === 'iPod' ||
        navigator.userAgent.match(/iPhone|iPad|iPod/i)
      )
        return true;
    },
    Opera: function() {
      return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function() {
      return navigator.userAgent.match(/IEMobile/i);
    },
    any: function() {
      return false; // !BrowserDetect.digitalSignage() && (this.Android() || this.BlackBerry() || this.iOS() || this.Opera() || this.Windows());
    }
  },

  supportedBrowser: function(os, browser, version) {
    if (typeof os != 'String') os = this.OS;
    if (typeof browser != 'String') browser = this.browser;
    if (typeof version != 'String') version = this.version;

    if (os != 'iOS' && os != 'Android') {
      // Computer browser
      if (browser == 'Explorer') {
        if (version > '10') {
          return true;
        }
      }
      else if (browser == 'Chrome') {
        if (version > '26') {
          return true;
        }
      }
      else if (browser == 'Firefox') {
        if (version > '28') {
          return true;
        }
      }
      else if (browser == 'Safari') {
        if (version > '8') {
          return true;
        }
      }
      else if (browser == 'Edge') {
        // Edge is new enough that we support all versions
        return true;
      }
    } else {
      // Mobile browser
      if (browser == 'Safari') {
        if (version > '8' && version < '400') {
          return true;
        }
        else if (version > '580') {
          return true;
        }
      }
      else if (browser == 'Chrome') {
        if (version > '32') {
          return true;
        }
      }
      else if (browser == 'Silk') {
        return true;
      }
      else if (browser == 'Firefox') {
        if (version > '32') {
          return true;
        }
      }
    }
    return false;
  }

  /*
   * The following 3 userAgentTo functions look to be unreliable and are not being used anywhere.
   * Perhaps they should be purged. Commenting out for now.
   *
  userAgentToBrowser: function(userAgent) {
    if (!userAgent) userAgent = navigator.userAgent;
    if (userAgent.match(/Seamonkey/i)) {
      return 'Seamonkey';
    }
    else if (userAgent.match(/Firefox/i)) {
      return 'Firefox';
    }
    else if (userAgent.match(/Chromium/i)) {
      return 'Chromium';
    }
    // Edge puts itself at the end of the string, after Chrome. Nobody else claims to be Edge, so check for it first.
    else if (userAgent.match(/Edge/i)) {
      return 'Edge';
    }
    else if (userAgent.match(/Chrome/i)) {
      return 'Chrome';
    }
    else if (userAgent.match(/Safari/i)) {
      return 'Safari';
    }
    else if (userAgent.match(/Opera/i) || userAgent.match(/OPR/i)) {
      return 'Opera';
    }
    else if (userAgent.match(/MSIE/i)) {
      return 'Internet Explorer';
    }
    else if (userAgent.match(/Windows/i) && userAgent.match(/rv:11/i)) {
      return 'Internet Explorer';
    }
    else if (userAgent.match(/AppleWebKit/i)) {
      return 'Safari';
    }
    else if (userAgent.match(/Google Page Speed Insights/i)) {
      return 'Chrome';
    }
    else if (userAgent.match(/pingdom/i)) {
      return 'Chrome';
    }
    else {
      return 'Unknown Browser';
    }
  },

  userAgentToOS: function(userAgent) {
    if (!userAgent) userAgent = navigator.userAgent;
    if (userAgent.match(/(Windows|WOW64)/i)) {
      return 'Windows';
    }
    else if (userAgent.match(/;\s*Android.*;/i)) {
      return 'Android';
    }
    else if (userAgent.match(/Android.*;/i)) {
      return 'Android';
    }
    else if (userAgent.match(/;\s*Linux.*;/i)) {
      return 'Linux';
    }
    else if (userAgent.match(/;\s*Mac.*;/i)) {
      return 'Machintosh';
    }
    else if (userAgent.match(/;\s*iOS.*;/i)) {
      return 'iOS';
    }
    else if (userAgent.match(/;\s*OS 8_[0-9]+;/i)) {
      return 'iOS';
    }
    else if (userAgent.match(/;\s*AppleWebKit.*;/i)) {
      return 'iOS';
    }
    else if (userAgent.match(/iPhone/i)) {
      return 'iOS';
    }
    else {
      return 'Unknown OS';
    }
  },

  userAgentToDeviceType: function(userAgent) {
    if (!userAgent) userAgent = navigator.userAgent;
    if (userAgent.match(/Mobi/)) {
      return 'Mobile';
    }
    else if (userAgent.match(/Tablet/)) {
      return 'Tablet';
    }
    else {
      return 'Desktop';
    }
  },
  /**/

};

BrowserDetect.init();

var soundManagerOpts = {
  useHighPerformance: true,
  useHTML5Audio: true,
  debugMode: true,
  useConsole: true,
  consoleOnly: true
};

if (BrowserDetect.digitalSignage()) {
  soundManagerOpts.ignoreMobileRestrictions = true;
}

soundManager.setup(soundManagerOpts);

function getURLParams() {
  var URLHash = window.location.hash.substr(1);
  var URLParamSection = URLHash.split('?')[1];
  var params = {};
  if (URLParamSection) {
    var paramSegments = URLParamSection.split('&');
    var nv = [];
    for (var i=0; i<paramSegments.length; i++) {
      nv = paramSegments[i].split('=');
      params[nv[0]] = nv[1];
    }
  }
  return params;
}

var app = angular.module('ccmAccountApp', [
  'ngAnimate',
  'ngCookies',
  'ngMessages',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap',
  'angular-growl',
  'dndLists',
  'config',
  'autocomplete',
  'ngclipboard',
  'angularUtils.directives.dirPagination',
  'ngCsv',
  'mp.datePicker',
  'ngFileUpload',
  'daypartScheduler',
  'messageSchedulerCalendar',
  'inputDropdown',
  'nya.bootstrap.select',
  'hmTouchEvents'
]).run(['$location', '$log', '$rootScope', '$state', '$stateParams', 'confirmationDialog', 'intercom', 'navigationService', 'requirements',
  function($location, $log, $rootScope, $state, $stateParams, confirmationDialog, intercom, navigationService, requirements) {

    $rootScope.urlParameters = getURLParams();

    // Skip all this when using a self serve device.
    if (/^\/selfserveautologin/.test($location.$$path)) {
      return;
    }

    // Initialize Intercom
    intercom.login();

    // makes location available in any scope to change page in templates
    $rootScope.messages = {};
    $rootScope.location = $location;
    $rootScope.$state = $state;
    $rootScope.$stateParams = $stateParams;

    $rootScope.browserInfo = BrowserDetect.browserInfo();

    // TODO: Remove dependency on this function
    $rootScope.changelocation = function (url) {

      if ($rootScope.confirmLocationSwitch) {
        confirmationDialog($rootScope, $rootScope.confirmLocationSwitch, function () {
          $rootScope.confirmLocationSwitch = false;
          $location.path(url);
        }, function() {
          return;
        }).catch(angular.noop);
      } else {
        $location.path(url);
      }
    };

    // this is catch-all just in case we didn't catch with changelocation()
    $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState) {

      // Force the state transition and skip the "requirements" check once it has already been performed for the next state
      if (navigationService.stateChangeData.forceNextTransition) {
        return;
      }

      // Check browser compatibility
      if (!BrowserDetect.supportedBrowser() && $location.$$path !== '/unsupported-browser') {

        // Prevent the current state transition
        event.preventDefault();

        navigationService.stateChangeData.forceNextTransition = true;
        $state.go('unsupportedbrowser');

        return;
      }

      var shouldRedirectToLogin = navigationService.shouldRedirectToLogin(toState);
      if (shouldRedirectToLogin) {

        // Prevent the current state transition
        event.preventDefault();

        if (fromState.name !== 'loggedout.login') {
          navigationService.stateChangeData.forceNextTransition = true;
          $state.go('loggedout.login', { returnPath: $location.path() });
        }

        return;
      }

      $rootScope.loadingContent = true;

      requirements.check(event, toState, toParams, function () {
        if ($rootScope.confirmLocationSwitch) {

          // Can't use the confirmation dialog here because of its asynchronous nature
          if (window.confirm($rootScope.confirmLocationSwitch)) {
            $rootScope.confirmLocationSwitch = false;

            navigationService.stateChangeData.forceNextTransition = true;
            navigationService.stateChangeData.userConfirmedNextTransition = true;

            $state.go(toState.name, toParams);
          } else {
            $rootScope.loadingContent = false;
          }
        }
      });
    });

    $rootScope.$on('$stateChangeSuccess', function (event, toState) {
      var intercomEventData = {
        show_view: toState.url
      };

      if (navigationService.stateChangeData.userConfirmedNextTransition) {
        intercomEventData.confirmed = 'OK';
      }

      intercom.sendEvent('Switch view', intercomEventData);

      navigationService.clearStateChangeData();
    });

    $rootScope.$on('$stateChangeError', function (event, toState, toParams, fromState, fromParams, error) {
      $log.error(error);

      event.preventDefault();
      navigationService.clearStateChangeData();

      $state.go('error');
    });

  }
]);

app.config(['growlProvider', function(growlProvider) {
  growlProvider.globalTimeToLive(6000);
  growlProvider.globalEnableHtml(true);
}]);

app.directive('selectOnClick', function() {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      element.on('click', function() {
        this.select();
      });
    }
  };
});

app.directive('ngFocus', function() {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      scope.$watch(attrs.ngFocus, function(newValue) {
        if (newValue) {
          setTimeout(function() {
            element[0].focus();
          }, 100);
        }
      });
    }
  };
});

(function (app) {
  app.config(configBlock);

  configBlock.$inject = ['$compileProvider', '$httpProvider', '$locationProvider', '$logProvider', 'ENV'];

  function configBlock($compileProvider, $httpProvider, $locationProvider, $logProvider, ENV) {
    var debugEnabled = ENV.debug;

    $logProvider.debugEnabled(debugEnabled);

    // Remove the default "!" hash prefix
    $locationProvider.hashPrefix('');

    $compileProvider.debugInfoEnabled(debugEnabled);
    $compileProvider.commentDirectivesEnabled(false);

    $httpProvider.useApplyAsync(true);
  }

})(app);
app.constant('Duo', window.Duo);

app.config(['$stateProvider', '$urlRouterProvider', 'ENV',
  function ($stateProvider, $urlRouterProvider, ENV) {
    $urlRouterProvider.otherwise('/playlists/public');

    $stateProvider
      .state('loggedout', {
        templateUrl: 'views/loggedout.html',
        controller: 'MainCtrl'
      })
      .state('unsupportedbrowser', {
        url: '/unsupported-browser',
        templateUrl: 'views/unsupported_browser.html'
      })
      .state('error', {
        template:
          '<div class="logout-container" ng-click="hideVolumeControl()">' +
            '<div class="login-background"></div>' +
            '<div class="cloudanimation"></div>' +
            '<div class="logout-header-wrapper">' +
              '<div class="logo"></div>' +
            '</div>' +
            '<div class="container">' +
              '<div class="error-container">' +
                '<h1>Something went wrong...</h1>' +
                '<a class="btn btn-lg btn-default" href="/"><i class="fa fa-refresh fa-push-right"></i>Try Again</a>' +
              '</div>' +
            '</div>' +
            '<a class="intercom-launcher intercom-booted" ng-class="{\'intercom-open\': intercomLauncherOpen, \'mobile-media-toolbar-open\': mobileMediaToolbarOpen, mobile: isMobile}" href="mailto:{{intercomAppId}}@incoming.intercom.io">'  +
              '<div class="intercom-icon-close"></div>' +
              '<div class="intercom-icon-open"></div>' +
              '<span class="intercom-unread-count"></span>' +
            '</a>' +
          '</div>'
      })
      .state('account', {
        templateUrl: 'views/account.html',
        controller: 'AccountCtrl',
        resolve: {
          me: ['api',
            function (api) {
              return api.getMe(true);
            }
          ],
          subscription: ['$q', 'api',
            function($q, api) {
              var deferred = $q.defer();

              api.getMe()
                .then(function () {
                  return api.getSubscription({ skipBilling: true });
                })
                .then(deferred.resolve)
                .catch(deferred.reject);

              return deferred.promise;
            }
          ],
          streams: ['$q', 'api',
            function ($q, api) {
              var deferred = $q.defer();

              api.getMe()
                .then(function () {
                  api.getStreamsForUser(api.userObject.user.userid,
                    function (result) {
                      deferred.resolve(result);
                    }, function (response) {
                      deferred.reject(response);
                    });
                })
                .catch(deferred.reject);

              return deferred.promise;
            }
          ],
          plans: ['$q', 'api', 'subscriptionInfo',
            function ($q, api, subscriptionInfo) {
              var deferred = $q.defer();

              $q.all([api.getPlans(), api.getEnterprisePlans()])
                .then(function (results) {
                  var plansResults = results[0];
                  var enterprisePlansResults = results[1];

                  var plansData = plansResults.plans ? plansResults.plans : plansResults;
                  var plansInfo = plansData.concat(enterprisePlansResults.enterprise);
                  var plans = subscriptionInfo.getPlansObject(plansInfo);

                  deferred.resolve(plans);
                })
                .catch(deferred.reject);

              return deferred.promise;
            }
          ],
          account: ['$q', 'api',
            function ($q, api) {
              var deferred = $q.defer();

              api.getMe()
                .then(function () {
                  api.getAccount(api.userObject.user.custid,
                    function (result) {
                      deferred.resolve(result);
                    }, function (response) {
                      deferred.reject(response);
                    });
                })
                .catch(deferred.reject);

              return deferred.promise;
            }
          ],
          contentRatings: ['contentRatingService',
            function (contentRatingService) {
              return contentRatingService.refreshContentRatings();
            }
          ],
          // Player is used across all pages and initialized before the page loads, requires current preset and schedule
          // Initialize with currentSelection
          messageCurrentSelection: ['api', 'messageSelection',
            function(api, messageSelection) {

              return api.getMe()
                .then(function() {
                  var currentSelection = {
                    messagePreset: api.userObject.message_preset,
                    messageSchedule: api.userObject.schedule_id
                  };
                  messageSelection.initSelection(currentSelection);
              });
            }
          ],
          // Player is used across all pages and initialized before the page loads, requires current preset and schedule
          // Load all presets before player is initialized
          messagePresets: ['messageSelection',
            function(messageSelection) {
              return messageSelection.loadPresets();
            }
          ],
          // Player is used across all pages and initialized before the page loads, requires current preset and schedule
          // Load all schedules before player is initialized
          messageSchedules: ['messageSelection',
            function(messageSelection) {
              return messageSelection.loadSchedules();
            }
          ]
        }
      })
      .state('loggedout.logout', {
        url: '/logout',
        templateUrl: 'views/loggedout.html',
        controller: 'LogoutCtrl'
      })
      .state('loggedout.forgotpassword', {
        url: '/password_request?linkcode',
        templateUrl: 'views/forgot_password.html',
        controller: 'ForgotCtrl'
      })
      .state('loggedout.resetpassword', {
        url: '/password_reset/:token',
        templateUrl: 'views/reset_password.html',
        controller: 'ResetPasswordController',
        controllerAs: 'vm',
        resolve: {
          passwordResetUser: ['$stateParams', 'api',
            function ($stateParams, api) {
              return api.getPasswordResetUser($stateParams.token)
                .then(function (data) {
                  return {
                    isError: false,
                    data: data
                  };
                })
                .catch(function (response) {
                  var isResetTokenExpired = false;
                  var isResetTokenNotFound = false;

                  if (response.status === 401) {
                    isResetTokenExpired = true;
                  } else if (response.status === 404) {
                    isResetTokenNotFound = true;
                  }

                  return {
                    isError: true,
                    isResetTokenExpired: isResetTokenExpired,
                    isResetTokenNotFound: isResetTokenNotFound,
                    response: response
                  };
                });
            }
          ]
        }
      })
      .state('account.admin', {
        templateUrl: 'views/admin.html',
        controller: 'AdminCtrl'
      })
      .state('account.admin.messages', {
        url: '/admin/messages',
        templateUrl: 'views/admin_messages.html',
        controller: 'AdminMessagesCtrl',
        resolve: {
          requests: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(function(result) {

                if (!result.permissions.account.owner && !result.permissions.account.messages) return defer.resolve({});

                api.getMessageRequests().then(function(result) {
                  defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ],
          messages: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getMessagesWithStatus.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.playlists', {
        url: '/admin/mix',
        templateUrl: 'views/admin_mix_playlists.html',
        controller: 'AdminPlaylistsCtrl',
        resolve: {
          userPerms: ['$q', 'userInfo',
            function ($q, userInfo) {
              var defer = $q.defer();

              userInfo.getUserPerms(function (userPerms) {
                defer.resolve(userPerms);
              });

              return defer.promise;
            }
          ],
          mixes: ['api', 'userPerms',
            function (api, userPerms) {
              return api.getMe()
                .then(function (me) {

                  // Allow music admins to view all music selections, regardless of whether they are limited to company selections.
                  if (me.has_company_stations === 1 && !userPerms.isMusicAdmin) {
                    return api.getCompanyStations(me);
                  } else {
                    return api.getMixPlaylists();
                  }
                });
            }
          ]
        }
      })
      .state('account.admin.companystations', {
        url: '/admin/companystations',
        templateUrl: 'views/admin_company_stations.html',
        controller: 'AdminCompanyStationsCtrl',
        controllerAs: 'vm',
        resolve: {
          me: ['api',
            function(api) {
              return api.getMe(true);
            }
          ],
          companyStations: ['api', 'me',
            function (api, me) {
              return api.getCompanyStations(me);
            }
          ],
          playlists: ['api', 'me',
            function (api, me) {
              return api.getMusic(true);
            }
          ],
          mixes: ['api', 'me',
            function (api, me) {
              return api.getMixPlaylists();
            }
          ],
          locations: ['api',
            function(api) {
              return api.getMe().then(function() {
                return api.getLocsWithStreamCounts(api.userObject.account.custid);
              }).then(function(locationData) {
                if (locationData && locationData.locations) {
                  return locationData.locations;
                }
              }, function(err) {
                console.error("Error getting stream data while routing /admin/locations");
              });
            }
          ]
        }
      })
      .state('register_token', {
        url: '/register_token/:userid/:uuid',
        template: 'One moment while we redirect you...., if this doesnt happen please refresh',
        resolve: {
          info: ['$q', 'api', '$stateParams',
            function($q, api, $stateParams) {
              api.registerToken($stateParams.uuid, $stateParams.userid);
            }
          ]

        }
      })
      .state('account.admin.downvotes', {
        url: '/admin/removedsongs',
        templateUrl: 'views/admin_downvotes.html',
        controller: 'AdminDownvotesCtrl',
        resolve: {
          removed: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(function() {
                api.getRemoved(function(result) {
                  defer.resolve(result);
                }, function(err) {
                  console.error("Error in getRemoved while routing /admin/removedsongs.",err);
                });
              }, function(err) {
                console.error("Error in getMe while routing /admin/removedsongs.",err);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.streamhistory', {
        url: '/admin/streamhistory',
        templateUrl: 'views/admin_stream_history.html',
        controller: 'AdminStreamHistoryController',
        resolve: {
          streamed: ['api',
            function (api) {
              return api.getMe()
                .then(function () {
                  return api.getStreamHistory(api.userObject.streamid, 50);
                });
            }
          ],
          streams: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getStreamsForUser(api.userObject.user.userid, function(streams) {
                  defer.resolve(streams.streams);
                }, function(err) {
                  console.error("Error getting streams while routing /admin/streamhistory (streams)");
                });
              }, function(err) {
                console.error('Error in getMe while routing /admin/streamhistory (streams)');
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.enterprise', {
        url: '/admin/enterprise',
        templateUrl: 'views/admin_enterprise.html',
        controller: 'AdminEnterpriseCtrl'
      })
      .state('account.admin.dayparting', {
        url: '/admin/dayparting',
        templateUrl: 'views/admin_dayparting.html',
        controller: 'AdminDaypartingCtrl',
        resolve: {
          userPerms: ['$q', 'userInfo',
            function ($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function (userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ],
          dayparting: ['api', 'userPerms',
            function (api, userPerms) {
              return api.getMe()
                .then(function (me) {

                  // Allow music admins to view all music selections, regardless of whether they are limited to company selections.
                  if (me.has_company_stations === 1 && !userPerms.isMusicAdmin) {
                    return api.getCompanyStations(me);
                  } else {
                    return api.getDayPartingPresets();
                  }
                });
            }
          ],

        }
      })
      .state('account.admin.request_message', {
        url: '/admin/request_message',
        templateUrl: 'views/request_message.html',
        controller: 'AdminMessageRequestCtrl'
      })
      .state('account.admin.billing', {
        url: '/admin/billing',
        templateUrl: 'views/admin_billing.html',
        controller: 'AdminBillingCtrl',
        resolve: {
          plansInfo: ['api',
            function (api) {
              return api.getPlans();
            }
          ],
          enterprisePlansInfo: ['api',
            function (api) {
              return api.getEnterprisePlans();
            }
          ],
          subscription: ['$q', 'api', '$location', 'subscriptionInfo',
            function($q, api, $location, subscriptionInfo) {
              var defer = $q.defer();
              api.getMe().then(api.getSubscription.bind(api)).then(function(subscription) {
                subscriptionInfo.calculateAddonStreams(subscription).then(function(addonStreams) {
                  subscription.addonStreams = addonStreams;
                  if (!api.userObject.account.recurly) {
                    subscriptionInfo.setPaymentStatus(false);
                    defer.resolve(subscription);
                  } else {
                    api.getPayment().then(function(paymentInfo) {
                      if (paymentInfo.last_four || api.userObject.recurly.collection_method === "manual") {
                        subscription.paymentInfo = paymentInfo;
                        subscriptionInfo.setPaymentStatus(true);
                      } else {
                        subscriptionInfo.setPaymentStatus(false);
                      }
                      defer.resolve(subscription);
                    });
                  }
                }, function(err) {
                  console.error('Error fetching subscription information when routing billing page')
                });
              });
              return defer.promise;
            }
          ],
          invoices: ['api',
            function (api) {
              return api.getMe()
                .then(function (me) {
                  if(me.recurly && me.recurly.account_code && !me.account.has_private_billing) {
                    return api.getAccountInvoices()
                      .then(function (invoiceList) {
                        return invoiceList;
                      })
                      .catch(function () {
                        return null;
                      });
                  } else {
                    return [];
                  }
                });
            }
          ]
        }
      })
      .state('account.admin.plan', {
        url: '/admin/plan',
        templateUrl: 'views/admin_plan.html',
        controller: 'AdminPlansCtrl',
        resolve: {
          enterprise: ['api',
            function (api) {
              return api.getEnterprisePlans();
            }
          ]

        }
      })
      .state('account.admin.locations', {
        url: '/admin/locations',
        templateUrl: 'views/admin_locations.html',
        controller: 'LocationsCtrl',
        resolve: {
          locations: ['api',
            function(api) {
              return api.getMe().then(function() {
                return api.getLocsWithStreamCounts(api.userObject.account.custid);
              }).then(function(locationData) {
                if (locationData && locationData.locations) {
                  return locationData.locations;
                }
              }, function(err) {
                console.error("Error getting stream data while routing /admin/locations");
              });
            }
          ]
        }
      })
      .state('account.admin.streams', {
        url: '/admin/zones',
        templateUrl: 'views/admin_streams.html',
        controller: 'AdminStreamsCtrl',
        resolve: {
          initialData: ['$q', 'api', 'subscriptionInfo', function($q, api, subscriptionInfo) {
            var getGroups = function() {
              var defer = $q.defer();
              api.getGroups(function(result) {
                defer.resolve(result.groups);
              }, function(err) {
                console.error("Error getting groups while routing admin/zones");
              });
              return defer.promise;
            };
            var getStreams = function() {
              var defer = $q.defer();
              api.getStreamsWithDevice(1, function(result) {
                defer.resolve(result);
              },function(err) {
                console.error("Error in getStreamsWithDevice while routing /admin/zones.",err);
              });
              return defer.promise;
            };
            var getMusic = function() {
              var defer = $q.defer();
              api.getMusic().then(function(result) {
              defer.resolve(result);
              }, function() {
              defer.resolve(null);
              });
              return defer.promise;
            };
            var getPresets = function() {
              var defer = $q.defer();
              api.getPresets().then(function(result) {
              defer.resolve(result.presets);
              });
              return defer.promise;
            };
            var getMessageSchedules = function() {
              var defer = $q.defer();
              api.getMessageSchedules().then(function(result) {
                defer.resolve(result.schedules);
              });
              return defer.promise;
            };

            return api.getMe().then(function() {
              var promisesObj = {
                groups: getGroups(),
                streams: getStreams(),
                music: getMusic()
              };
              if (subscriptionInfo.messageQuantityAllowedPerPreset()) {
                promisesObj.messagePresets = getPresets();
                promisesObj.messageSchedules = getMessageSchedules();
              }
              return $q.all(promisesObj).then(function(response) {
                return response;
              });
            });
          }],
          userPerms: ['$q', 'userInfo', function($q, userInfo) {
            var defer = $q.defer();
            userInfo.getUserPerms(function(userPerms) {
              defer.resolve(userPerms);
            });
            return defer.promise;
          }]
        }
      })
      .state('account.admin.admins', {
        url: '/admin/admins',
        templateUrl: 'views/admin_admins.html',
        controller: 'AdminsCtrl',
        resolve: {
          admins: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getAdmins(1, function(result) {
                  return defer.resolve(result);
                }, function(err) {
                  console.error('/admin/admins called api.getAdmins: ', err);
                });
              });

              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.regions', {
        url: '/admin/regions',
        templateUrl: 'views/admin_regions.html',
        controller: 'RegionsCtrl',
        resolve: {
          groups: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getGroups(function(result) {
                  return defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ],
          music: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getMusic().then(function(music) {
                  defer.resolve(music);
                });
              });
              return defer.promise;
            }
          ],
          messagePresets: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getPresets(1).then(function(presets) {
                  defer.resolve(presets.presets);
                });
              });
              return defer.promise;
            }
          ],
          messageSchedules: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(function() {
                api.getMessageSchedules().then(function(result) {
                  defer.resolve(result.schedules);
                });
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.prefetch', {
        url: '/admin/prefetch',
        templateUrl: 'views/admin_prefetch.html',
        controller: 'AdminPrefetchCtrl',
        resolve: {
          networkConstraints: ['api', 'networkConstraintsService', function (api, networkConstraintsService) {
            return api.getMe().then(networkConstraintsService.getNetworkConstraints);
          }],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.devices', {
        url: '/admin/devices',
        templateUrl: 'views/admin_devices.html',
        controller: 'AdminDevicesCtrl',
        resolve: {
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.deviceapikeys', {
        url: '/admin/deviceapikeys',
        templateUrl: 'views/admin_device_apis.html',
        controller: 'AdminDeviceApisCtrl',
        resolve: {
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ],
          apiKeys: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getSelfServeAPIKeyHistory(function(keyList) {
                  defer.resolve(keyList);
                }, function(error) {
                  console.log(error);
                })
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.messagepresets', {
        url: '/admin/messages/presets',
        templateUrl: 'views/admin_messagepresets.html',
        controller: 'AdminMessagePresetCtrl',
        resolve: {
          presets: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getPresets(1).then(function(result) {
                  return defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.createmessagepresets', {
        url: '/admin/messages/presets/create',
        templateUrl: 'views/admin_edit_message_preset.html',
        controller: 'EditMessagePresetCtrl',
        controllerAs: 'vm',
        resolve: {
          messages: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getMessages.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          preset: ['$q', function($q) {
            var defer = $q.defer();
            defer.resolve(null);
            return defer.promise;
          }],
          subscription: ['api',
            function (api) {
              return api.getMe()
                .then(function () {
                  return api.getSubscription({ skipBilling: true });
                });
            }
          ]
        }
      })
      .state('account.admin.editmessagepresets', {
        url: '/admin/messages/presets/:presetid/edit',
        templateUrl: 'views/admin_edit_message_preset.html',
        controller: 'EditMessagePresetCtrl',
        controllerAs: 'vm',
        resolve: {
          messages: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getMessages.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          preset: ['$q', 'api', '$stateParams',
            function($q, api, $stateParams) {
              var defer = $q.defer();

              api.getMe().then(function() {
                api.getMessagePresetDetails($stateParams.presetid).then(function(result) {
                  return defer.resolve(result.preset);
                });
              });

              return defer.promise;
            }
          ],
          subscription: ['api',
            function (api) {
              return api.getMe()
                .then(function () {
                  return api.getSubscription({ skipBilling: true });
                });
            }
          ]
        }
      })
      .state('account.admin.messageschedules', {
        url: '/admin/messages/schedules',
        templateUrl: 'views/admin_message_schedules.html',
        controller: 'AdminMessageScheduleCtrl',
        resolve: {
          schedules: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getMessageSchedules.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.addmessageschedule', {
        url: '/admin/messages/schedule/add/:scheduleName',
        templateUrl: 'views/admin_edit_message_schedule.html',
        controller: 'AdminEditMessageScheduleCtrl',
        controllerAs: 'vm',
        resolve: {
          scheduleId: function () {
            return null;
          },
          messageScheduleDetails: ['$stateParams', 'api',
            function ($stateParams, api) {
              return api.getMe()
                .then(function () {
                  return {
                    schedule: {
                      custid: api.userObject.user.custid,
                      name: $stateParams.scheduleName,
                      scheduleitems: [],
                      userid: api.userObject.user.userid
                    }
                  };
                });
            }],
          messages: ['api',
            function (api) {
              return api.getMe()
                .then(function () {
                  return api.getMessages();
                });
            }
          ]
        }
      })
      .state('account.admin.editmessageschedules', {
        url: '/admin/messages/schedule/:scheduleid/edit',
        templateUrl: 'views/admin_edit_message_schedule.html',
        controller: 'AdminEditMessageScheduleCtrl',
        controllerAs: 'vm',
        resolve: {
          scheduleId: ['$stateParams',function($stateParams) {
            return $stateParams.scheduleid;
          }],
          messageScheduleDetails: ['$q', 'api', '$stateParams',
            function($q, api, $stateParams) {
              var defer = $q.defer();
              api.getMe()
                .then(function() {
                  api.getMessageScheduleDetails($stateParams.scheduleid)
                    .then(function(result) {
                      defer.resolve(result);
                    })
                    .catch(function(err) {
                      console.error("Error in getMessageScheduleDetails while routing /admin/messages/schedule/id/edit.", err);
                    });
                });
              return defer.promise;
            }
          ],
          messages: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getMessages.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.addlocation', {
        url: '/admin/addlocation',
        templateUrl: 'views/admin_edit_location.html',
        controller: 'AddLocationCtrl',
        resolve: {
          me: ['api',
            function(api) {
              return api.getMe(true);
            }
          ],
          groups: ['$q', 'api', 'me',
            function($q, api, me) {
              var defer = $q.defer();
              api.getGroups(function(result) {
                return defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          shippingRates: ['$q', 'api', 'me',
            function($q, api, me) {
              return api.getShippingRates().then(function(results) {
                return results;
              }, function(err) {
                console.error('Error in getShippingRates while routing /admin/addlocation', err)
                return { shippingRates: [] };
              });
            }
          ],
          companyStations: ['api', 'me',
            function (api, me) {
              return api.getCompanyStations(me);
            }
          ],
        }
      })
      .state('account.admin.edituser', {
        url: '/admin/locations/:locationid/edit',
        templateUrl: 'views/admin_edit_location.html',
        controller: 'EditLocationCtrl',
        resolve: {
          me: ['api',
            function(api) {
              return api.getMe(true);
            }
          ],
          companyStations: ['api', 'me',
            function (api, me) {
              return api.getCompanyStations(me);
            }
          ],
          user: ['$q', 'api', '$stateParams', 'me',
            function($q, api, $stateParams, me) {
              var defer = $q.defer();
              api.getUserDetails($stateParams.locationid, function(result) {
                return defer.resolve(result);
              }, function(err) {
                console.error("Error in getMe while routing /admin/locations/id/edit.", err);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.orderdevice', {
        url: '/admin/orderdevice',
        templateUrl: 'views/admin_order_device.html',
        controller: 'OrderDeviceCtrl',
        resolve: {
          users: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getUsers(1, function(result) {
                  return defer.resolve(result);
                },function(err){
                  console.error("Error in getUsers while routing /admin/orderdevice.",err);
                });
              });
              return defer.promise;
            }
          ],
          account: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getAccount(api.userObject.user.custid, function(result) {
                  return defer.resolve(result);
                });
              });
              return defer.promise;
            }
          ],
          subscription: ['$q', 'api', 'subscriptionInfo',
            function($q, api, subscriptionInfo) {
              var deferred = $q.defer();

              api.getMe()
                .then(api.getSubscription.bind(api))
                .then(function (subscription) {
                  subscriptionInfo.calculateAddonStreams(subscription)
                    .then(function (addonStreams) {
                      subscription.addonStreams = addonStreams;

                      if (!api.userObject.account.recurly) {
                        subscriptionInfo.setPaymentStatus(false);

                        return deferred.resolve(subscription);
                      }

                      api.getPayment()
                        .then(function (payment) {
                          var hasPayment = payment.last_four || api.userObject.recurly.collection_method === 'manual';
                          if (hasPayment) {
                            subscription.paymentInfo = payment;
                          }

                          subscriptionInfo.setPaymentStatus(hasPayment);
                          deferred.resolve(subscription);
                        });
                    });
                });

              return deferred.promise;
            }
          ],
          shippingRates: ['$q', 'api',
            function($q, api) {
              return api.getShippingRates().then(function(results) {
                return results;
              }, function(err) {
                console.error('Error in getShippingRates while routing /admin/orderdevice', err)
                return { shippingRates: [] };
              });
            }
          ]
        }
      })
      .state('account.admin.editadmin', {
        url: '/admin/admins/:adminid/edit',
        templateUrl: 'views/admin_edit_admin.html',
        controller: 'EditAdminCtrl',
        resolve: {
          user: ['$q', 'api', '$stateParams',
            function($q, api, $stateParams) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getUserDetails($stateParams.adminid, function(result) {
                  return defer.resolve(result);
                },function(err){
                  console.error("Error in getMe while routing /admin/admins/id/edit.",err);
                });
              });

              return defer.promise;
            }
          ],
          groups: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getGroups(function(result) {
                  return defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.addadmin', {
        url: '/admin/addadmin',
        templateUrl: 'views/admin_edit_admin.html',
        controller: 'AddAdminCtrl',
        resolve: {
          groups: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMe().then(function() {
                api.getGroups(function(result) {
                  return defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.createMixStation', {
        url: '/admin/mix/create',
        templateUrl: 'views/admin_edit_mix_station.html',
        controller: 'EditMixStationController',
        controllerAs: 'vm',
        resolve: {
          contentRatings: ['contentRatingService',
            function (contentRatingService) {
              return contentRatingService.refreshContentRatings();
            }
          ],
          mixStation: function () {
            return null;
          },
          playlistCategories: ['$q', 'api',
            function ($q, api) {
              var deferred = $q.defer();

              api.getMusicSelectionCategories()
                .then(function (data) {
                  deferred.resolve(data.category);
                })
                .catch(function (data) {
                  deferred.reject(data);
                });

              return deferred.promise;
            }
          ],
          playlists: ['api',
            function (api) {
              return api.getMe()
                .then(function () {
                  return api.getMusic();
                });
            }
          ],
          userPermissions: ['$q', 'userInfo',
            function ($q, userInfo) {
              var deferred = $q.defer();

              userInfo.getUserPerms(function (userPerms) {
                deferred.resolve(userPerms);
              });

              return deferred.promise;
            }
          ]
        }
      })
      .state('account.admin.editMixStation', {
        url: '/admin/mix/:id/edit',
        templateUrl: 'views/admin_edit_mix_station.html',
        controller: 'EditMixStationController',
        controllerAs: 'vm',
        resolve: {
          contentRatings: ['contentRatingService',
            function (contentRatingService) {
              return contentRatingService.refreshContentRatings();
            }
          ],
          mixStation: ['$q', '$stateParams', 'api',
            function ($q, $stateParams, api) {
              var deferred = $q.defer();
              var mixStationId = $stateParams.id;

              api.getMe()
                .then(function () {
                  return api.getMixDetails(mixStationId);
                })
                .then(function (data) {
                  deferred.resolve(data.mix_playlist);
                })
                .catch(function (result) {
                  deferred.reject(result);
                });

              return deferred.promise;
            }
          ],
          playlistCategories: ['$q', 'api',
            function ($q, api) {
              var deferred = $q.defer();

              api.getMusicSelectionCategories()
                .then(function (data) {
                  deferred.resolve(data.category);
                })
                .catch(function (data) {
                  deferred.reject(data);
                });

              return deferred.promise;
            }
          ],
          playlists: ['$q', 'api',
            function ($q, api) {
              var deferred = $q.defer();

              api.getMe()
                .then(function () {
                  return api.getMusic();
                })
                .then(function (result) {
                  deferred.resolve(result);
                })
                .catch(function (result) {
                  deferred.reject(result);
                });

              return deferred.promise;
            }
          ],
          userPermissions: ['$q', 'userInfo',
            function ($q, userInfo) {
              var deferred = $q.defer();

              userInfo.getUserPerms(function (userPerms) {
                deferred.resolve(userPerms);
              });

              return deferred.promise;
            }
          ]
        }
      })
      .state('account.admin.createpreset', {
        url: '/admin/createpreset',
        templateUrl: 'views/admin_edit_daypart.html',
        controller: 'EditDaypartCtrl',
        controllerAs: 'vm',
        resolve: {
          playlists: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(function() {
                api.getMusic().then(function(result) {
                  return defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ],
          preset: function() {
            return null;
          }
        }
      })
      .state('account.admin.editpreset', {
        url: '/admin/dayparting/:daypartingid/edit',
        templateUrl: 'views/admin_edit_daypart.html',
        controller: 'EditDaypartCtrl',
        controllerAs: 'vm',
        resolve: {
          playlists: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();
              api.getMeRequest = null;
              api.getMe(1).then(function() {
                api.getMusic().then(function(result) {
                  return defer.resolve(result);
                });
              });

              return defer.promise;
            }
          ],
          preset: ['$q', 'api', '$stateParams',
            function($q, api, $stateParams) {
              var defer = $q.defer();

              api.getMe(1).then(function() {
                api.getDayPartingDetails($stateParams.daypartingid).then(function(result) {
                  return defer.resolve(result.day_parting);
                });
              });

              return defer.promise;
            }
          ]
        }
      })
      .state('loggedout.login', {
        url: '/login',
        templateUrl: 'views/login.html',
        controller: 'LoginCtrl',
        params: {
          returnPath: null
        }
      })
      .state('sonos', {
        abstract: true,
        templateUrl: 'views/sonos.html'
      })
      .state('sonos.login', {
        url: '/sonos/login?linkcode',
        templateUrl: 'views/sonos_login.html',
        controller: 'SonosLoginController',
        controllerAs: 'vm',
        resolve: {
          linkCode: ['$stateParams',
            function ($stateParams) {
              return $stateParams.linkcode;
            }
          ]
        }
      })
      .state('sonos.registration', {
        url: '/sonos/register?linkcode',
        templateUrl: 'views/sonos_registration.html',
        controller: 'SonosRegistrationCtrl',
        controllerAs: 'vm',
        resolve: {
          linkCode: ['$stateParams',
            function ($stateParams) {
              return $stateParams.linkcode;
            }
          ],
          me: ['api',
            function (api) {
              return api.getMe(true);
            }
          ],
          streams: ['$q', 'api', 'userInfo',
            function ($q, api, userInfo) {
              var defer = $q.defer();

              userInfo.getUserPerms(function (userPerms) {
                if (userPerms.canManageDevices || userPerms.canManageMessages || userPerms.canManageMusic || userPerms.canSelectMessages || userPerms.canSelectMusic || userPerms.isAccountOwner) {
                  api.getMe()
                    .then(function () {
                      api.getStreamsForUser(api.userObject.user.userid, function (userStreams) {
                        defer.resolve(userStreams);
                      });
                    });
                } else {
                  defer.resolve({});
                }
              });

              return defer.promise;
            }
          ]
        }
      })
      .state('account.playlistsPublicStations', {
        url: '/playlists/public?reg',
        templateUrl: 'views/playlists_public.html',
        controller: 'PlaylistCtrl',
        resolve: {
          category: [ function() { return 'public'; } ],
          music: ['api',
            function (api) {
              return api.getMusicIfUser();
            }
          ],
          companyStations: ['$q', 'api',
            function ($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getCompanyStations.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          contentRatings: ['contentRatingService',
            function(contentRatingService) {
              return contentRatingService.refreshContentRatings();
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.playlistsDayparting', {
        url: '/playlists/dayparting?reg',
        templateUrl: 'views/playlists_dayparting_and_mix.html',
        controller: 'PlaylistCtrl',
        resolve: {
          // Perhaps we should have one route for listview
          // and a separate route for the icon view (CCM stations)
          category: [ function() { return 'dayparting'; } ],
          music: ['api',
            function (api) {
              return api.getMusicIfUser();
            }
          ],
          companyStations: ['$q', 'api',
            function ($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getCompanyStations.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]}
      })
      .state('account.playlistsMixStations', {
        url: '/playlists/mix?reg',
        templateUrl: 'views/playlists_dayparting_and_mix.html',
        controller: 'PlaylistCtrl',
        resolve: {
          category: [ function() { return 'mix'; } ],
          music: ['api',
            function (api) {
              return api.getMusicIfUser();
            }
          ],
          companyStations: ['$q', 'api',
            function ($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getCompanyStations.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.playlistsMessageUpgrade', {
        url: '/playlists/messageUpgrade',
        templateUrl: 'views/message_upgrade.html',
        controller: 'PlaylistMessageUpgradeCtrl'
      })
      .state('account.playlistsMessaging', {
        url: '/playlists/messaging?reg',
        templateUrl: 'views/playlists_messaging.html',
        controller: 'PlaylistMessagingCtrl',
        resolve: {
          messages: ['$q', 'api', '$location',
            function($q, api, $location) {
              return api.getMessagesIfUser();
            }
          ],
          companyStations: ['$q', 'api',
            function ($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getCompanyStations.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.playlistsMessageScheduling', {
        url: '/playlists/messageschedules?reg',
        templateUrl: 'views/playlists_message_scheduling.html',
        controller: 'PlaylistMessageScheduleCtrl',
        resolve: {
          schedules: ['$q', 'api',
            function($q, api) {
              var defer = $q.defer();

              api.getMe().then(api.getMessageSchedules.bind(api)).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ],
          userPerms: ['$q', 'userInfo',
            function($q, userInfo) {
              var defer = $q.defer();
              userInfo.getUserPerms(function(userPerms) {
                defer.resolve(userPerms);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('account.admin.messageUpsell', {
        url: '/admin/messageUpgrade',
        templateUrl: 'views/message_upgrade.html',
        controller: 'AdminMessageUpgradeCtrl'
      })
      .state('account.password', {
        url: '/password',
        templateUrl: 'views/edit_password.html',
        controller: 'EditPasswordCtrl'
      })
      .state('account.admin.editContact', {
        url: '/admin/account/edit',
        templateUrl: 'views/edit_account_contact.html',
        controller: 'EditAdminContactCtrl'
      })
      .state('account.admin.cancelSubscription', {
        url: '/admin/billing/cancel',
        templateUrl: 'views/admin_cancel_billing.html',
        controller: 'AdminCancelBillingCtrl'
      })
      .state('account.admin.upgradeSubscription', {
        url: '/admin/billing/upgrade',
        templateUrl: 'views/admin_upgrade_billing.html',
        controller: 'AdminUpgradeBillingCtrl',
        resolve: {
          plansInfo: ['api',
            function (api) {
              return api.getPlans();
            }
          ],
          enterprisePlansInfo: ['api',
            function (api) {
              return api.getEnterprisePlans();
            }
          ],
          subscription: ['$q', 'api', 'subscriptionInfo',
            function($q, api, subscriptionInfo) {
              var defer = $q.defer();
              api.getMe().then(api.getSubscription.bind(api)).then(function(subscription) {
                subscriptionInfo.calculateAddonStreams(subscription).then(function(addonStreams) {
                  subscription.addonStreams = addonStreams;
                  defer.resolve(subscription);
                });
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('loggedout.apiautologin', {
        url: '/apiautologin/:accesskey',
        controller: 'ApiAutologinCtrl',
        resolve: {
          me: ['$q', 'api', '$stateParams',
            function($q, api, $stateParams) {
              var defer = $q.defer();
              var param = {
                token: $stateParams.accesskey
              };
              api.getAutoLoginMe(param).then(function(result) {
                defer.resolve(result);
              });
              return defer.promise;
            }
          ]
        }
      })
      .state('loggedout.webautologin', {
        url: '/webautologin/:accesskey',
        templateUrl: 'views/webautologin.html',
        controller: 'WebAutoLoginController',
        resolve: {
          me: ['$stateParams', 'api',
            function ($stateParams, api) {
              var params = {
                token: $stateParams.accesskey
              };

              return api.getAutoLoginMe(params);
            }
          ]
        }
      })
      .state('loggedout.selfserveautologin', {
        url: '/selfserveautologin/:apikey/:uuid',
        templateUrl: 'views/selfserveautologin.html',
        controller: 'SelfServeAutologinCtrl'
      })
      .state('account.admin.editCorporateAddress', {
        url: '/admin/corporateaddress/edit',
        templateUrl: 'views/edit_account_corporateaddress.html',
        controller: 'EditAdminCorporateAddressCtrl'
      })
      .state('account.admin.enterpriseReports', {
        url: '/admin/enterprise/reports',
        templateUrl: 'views/admin_reports.html',
        controller: 'AdminReportsController',
        controllerAs: 'vm',
        resolve: {
          recurringReports: ['$q', 'api', 'reportingService',
            function ($q, api, reportingService) {
              var deferred = $q.defer();

              api.getMe()
                .then(function () {
                  return reportingService.getRecurringReports(api.userObject.user.userid);
                })
                .then(function (data) {
                  deferred.resolve(data.recurringReports);
                })
                .catch(deferred.reject);

              return deferred.promise;
            }
          ]
        }
      });

    if (ENV.featureFlags.artistRadio) {
      $stateProvider.state('account.artistRadio', {
        url: '/playlists/artistradio',
        templateUrl: 'views/artist_radio.html',
        controller: 'ArtistRadioController',
        resolve: {
          me: ['api',
            function (api) {
              return api.getMe();
            }
          ]
        }
      });
    }
  }
]);

app.factory('authorizationInjector', ['ENV', '$cookies', function (ENV, $cookies) {
  var authorizationInjector = {
    request: function (config) {
      // 2019-11-15 rporczak -- When the Device State API was served from our API Gateway
      // URL, we never had to be worried about the Authorization header being overwritten,
      // because the base of the URL was different than any of our APIs. However, in
      // transitioning to the Device State API being on the same API as the rest of the
      // app, this condition is now true for Device State requests. In order to maintain
      // application behavior consistency, we're adding another condition to specifically
      // check for the more specific Device State URL. In the case where we're making
      // Device State requests, we don't (re)set the Authorization header (i.e., we match
      // previous behavior.)
      var url = config.url;
      if (url.indexOf(ENV.apiUrl) === 0 && url.indexOf(ENV.deviceStateUrl) !== 0) {
        if ($cookies.get('Authorization') && $cookies.get('Token')) {
          config.headers.Authorization = $cookies.get('Authorization');
        }
      }

      return config;
    }
  };

  return authorizationInjector;
}]);

app.config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push('authorizationInjector');

  if (!$httpProvider.defaults.headers.get) {
    $httpProvider.defaults.headers.get = {};
  }

  $httpProvider.defaults.headers.get['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';
  $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';
  $httpProvider.defaults.headers.get['Pragma'] = 'no-cache';

  delete $httpProvider.defaults.headers.common['X-Requested-With'];
}]);

/* global app*/
/*jshint indent:2, white:false, strict:false, camelcase: false */

app.controller('EditPasswordCtrl', ['$scope', 'api', '$location', function($scope, api, $location) {
  $scope.dataReady = true;
  $scope.confirmedPassword = '';
  $scope.formdata = {
    'old_password': '',
    'password': '',
    userid: api.userObject.user.userid
  };

  $scope.submit = function () {

    if ($scope.confirmedPassword !== $scope.formdata.password) {
      return $scope.showError('Your Confirmation password did not match your new password');
    }

    if ($scope.formdata.old_password === '') {
      return $scope.showError('Please fill out your old password');
    }

    api.editUser($scope.formdata, function (result) {
      $scope.showSuccess('Your password has been updated');
      $location.path('/');
    }, function(result) {
      $scope.showError(result.message);
    });
  };
}]);

app.filter('filterAdminCompanyStation', function() {
  return function(stations, query) {
    var results = [];
    if (!query || query.length === 0) return stations;
    for (var i=0; i<stations.length; i++) {
      if (stations[i].name.toLowerCase().indexOf(query.toLowerCase()) != -1) {
        results.push(stations[i]);
      }
    }
    return results;
  }
});

app.controller('AdminCompanyStationsCtrl', AdminCompanyStationsCtrl);

AdminCompanyStationsCtrl.$inject = ['$scope', 'api', 'me', 'playlists', '$location', '$rootScope', 'subscription', 'locations', 'companyStations', 'userInfo', 'ENV', '$timeout', '$anchorScroll', 'playlistCategoryService'];

function AdminCompanyStationsCtrl ($scope, api, me, playlists, $location, $rootScope, subscription, locations, companyStations, userInfo, ENV, $timeout, $anchorScroll, playlistCategoryService) {
  var vm = this;

  // private vars
  var confirmLocationSwitchMessage = 'Are you sure? Your updates to Company Selections have not been saved. Do you wish to proceed?';
  var TrueFlag = 1;
  var FalseFlag = 0;
  var OffFlag = -1;

  // public vars
  vm.userPerms = {};
  vm.query = '';
  vm.orderBy = 'username';
  vm.pageSize = 50;
  vm.subscription = subscription;
  vm.companyStationDetails = [];
  vm.companyStation = undefined;
  vm.companyStationPlaylistCount = 0;
  vm.companyStationMixCount = 0;
  vm.companyStationDaypartCount = 0;
  vm.dayparting = playlists.dayparting;
  vm.guardTruthMessage = 'This will limit <b>ALL</b> locations to the Company Selections immediately.';
  vm.guardFalseMessage = 'This will REMOVE the limit on <b>ALL</b> locations to the Company Selections immediately.';
  vm.isOrganizationCompanyStationsEnabled = false;
  vm.mixes = playlists.mix.map(function(mx) {
    mx.ratingList = JSON.parse(mx.content_ratings);
    return mx;
  });
  vm.isSaving = false;

  vm.playlists = playlists.public;
  vm.activeTab = 1;
  vm.locations = locations;
  vm.toggleAllForCompanyStationsFlag = TrueFlag;
  vm.canLimitLocations = subscription.remote && (me.permissions.account.owner || me.permissions.account.music);
  vm.stationArtUrl = ENV.stationArtUrl;
  vm.formData = {
    companyStationDetails: [],
    is_active: 0,
    franchisee_lock: undefined
  };
  vm.locationDefault = (parseInt(me.account.default_company_stations) == 1) ? 1 : 0;
  vm.showIsActiveSubmitBtn = false;

  $scope.$parent.currentTab = 'companystations';
  $scope.$parent.hideLoader();
  $scope.$parent.topTitle = 'Company Selections';
  $scope.playlistStationFilter = {};

  // public methods declarations
  //----------------------------------------
  vm.addPlaylist = addPlaylist;
  vm.checkNotMe = checkNotMe;
  vm.checkPlaylist = checkPlaylist;
  vm.filterDataset = filterDataset;
  vm.locationSearch = locationSearch;
  vm.onCompanyStationsActiveChange = onCompanyStationsActiveChange;
  vm.orderLocations = orderLocations;
  vm.removePlaylist = removePlaylist;
  vm.removePlaylistFilter = removePlaylistFilter;
  vm.shouldDisableSubmitButton = shouldDisableSubmitButton;
  vm.scrollTo = $anchorScroll;
  vm.submit = submit;
  vm.toggleCompanyStationsOnAllLocations = toggleCompanyStationsOnAllLocations;
  vm.toggleCompanyStationsOnLocation = toggleCompanyStationsOnLocation;
  vm.updateDefaultCompanySelections = updateDefaultCompanySelections;
  vm.updateFranchiseeLock = updateFranchiseeLock;

  // private methods list
  //----------------------------------------
  // getLocations()
  // decrementCompanyStationCounts(type)
  // incrementCompanyStationCounts(type)
  // init()
  // updateMasterLocationSwitch()

  init();

  // public method definitions
  //------------------------------------

  function addPlaylist (playlist) {
    vm.playlistAddedId = playlist.musicid;

    var newPlaylist = {
      musicid: playlist.musicid,
      name: playlist.name,
      subname: playlist.subname,
      thumb_url: playlist.thumb_url,
      content_rating_id: playlist.content_rating_id,
      ratingList: playlist.ratingList,
      type: playlist.type,
      username: playlist.username,
    };
    $rootScope.confirmLocationSwitch = confirmLocationSwitchMessage;
    vm.formData.companyStationDetails.push(newPlaylist);
    incrementCompanyStationCounts(newPlaylist.type);

    $timeout(function () {
      vm.playlistAddedId = null;
      vm.formController.$setDirty();
    })
  };

  function checkCompanyStationCounts() {
    return vm.companyStationPlaylistCount || vm.companyStationDaypartCount || vm.companyStationMixCount;
  }

  function checkNotMe(userid) {
    return me.user.userid !== userid;
  }

  function checkPlaylist (musicid) {
    var isThere = false;

    if (vm.formData.companyStationDetails.length > 0) {
      vm.formData.companyStationDetails.forEach(function(item) {
        if (item.musicid === musicid) {
          isThere = true;
        }
      });
    }
    return isThere;
  };

  function customLocationSort(locations) {
    var result = [];
    if (vm.reverse) {
      result = locations.sort(function (a, b) {
        var x = (a[vm.orderBy]) ? a[vm.orderBy].toString().toLowerCase() : '',
            y = (b[vm.orderBy]) ? b[vm.orderBy].toString().toLowerCase() : '';
        return x > y ? -1 : x < y ? 1 : 0;
      });
      return result;
    }
    else {
      result = locations.sort(function (a, b) {
        var x = (a[vm.orderBy]) ? a[vm.orderBy].toString().toLowerCase() : '',
            y = (b[vm.orderBy]) ? b[vm.orderBy].toString().toLowerCase() : '';
        return x > y ? 1 : x < y ? -1 : 0;
      });
      return result;
    }
  }

  // filterDataset:
  //   filterStatus and filterList:
  //      business, genre, and mood are lumped together
  //      content rating is applied after the other filters
  //      newest releases and most popular are mutually exclusive to the other groupings
  //
  //   traverse dataset and
  //      check general filters against playlist.categoryids
  //      check content rating filter against playlist.content_rating_id
  //      if search field is populated, then check
  //        { name, subname, featured_artists }
  //        against search field content
  //
  // - fmadden 10/22/19
  //
  function filterDataset (filterStatus, filterList, searchQuery) {
    var intermediateList = [];
    vm.selectedStationCategories = [];

    if (filterStatus) {

      if (filterStatus.popular) {
        vm.ccmStationQuery = '';
        intermediateList = playlistCategoryService.filterPlaylistsByMostPopularCategory(vm.playlists);
      }
      else if (filterStatus.newest) {
        vm.ccmStationQuery = '';
        intermediateList = playlistCategoryService.filterPlaylistsByNewestReleasesCategory(vm.playlists);
      }
      else if (filterStatus.pandora) {
        vm.ccmStationQuery = '';
        intermediateList = playlistCategoryService.filterPlaylistsByPandoraCategory(vm.playlists)
          .sort(function (a, b) { return a.name.localeCompare(b.name); });
      }
      else if (filterStatus.recent) {
        vm.ccmStationQuery = '';
        intermediateList = playlistCategoryService.filterPlaylistsByRecentCategory(vm.playlists);
      }
      else if (filterStatus.favorites) {
        vm.ccmStationQuery = '';
        vm.searchResultsLoading = true;
        playlistCategoryService.filterPlaylistsByFavoritesCategory(vm.playlists)
          .then(function (favoritesPlaylist) {
            if(filterStatus.favorites) {
              vm.filteredPlaylists = favoritesPlaylist
                .sort(function (a, b) { return a.name.localeCompare(b.name); });
            }
          })
          .finally(function () {
            vm.searchResultsLoading = false;
          });
      }
      else {
        var filterIds = [].concat(filterStatus.business, filterStatus.genre, filterStatus.mood);
        if ((filterIds.length > 0) || (filterStatus.rating.length > 0)) {
          intermediateList = vm.playlists.filter(function (station) {
            var isFilteredByCategories = false;
            var isFilteredByRatings = false;

            if (filterStatus.rating.length) {
              isFilteredByRatings = filterStatus.rating.indexOf(station.content_rating_id) !== -1;
            } else {
              isFilteredByRatings = true;
            }

            if (filterIds.length && station.categoryids) {
              var isStationInAllCategories = true;
              for (var i = 0; i < filterIds.length; i++) {
                if (station.categoryids.indexOf(filterIds[i]) === -1) {
                  isStationInAllCategories = false;
                  break;
                }
              }

              isFilteredByCategories = isStationInAllCategories;
            } else if (!filterIds.length) {
              isFilteredByCategories = true;
            }

            return isFilteredByCategories && isFilteredByRatings;
          })

          // setup selectedStationCategories for visual feedback

          filterList.genre.forEach(function (cat) {filterStationCategories(filterIds, 'genre', cat)});
          filterList.mood.forEach(function (cat) {filterStationCategories(filterIds, 'mood', cat)});
          filterList.business.forEach(function (cat) {filterStationCategories(filterIds, 'business', cat)});

        } else {
          intermediateList = vm.playlists;
        }
        if (filterStatus.rating.length > 0) {
          filterList.rating.forEach(function (cat) {filterStationCategories(filterStatus.rating, 'rating', cat)});
        }
      }

      if (searchQuery && searchQuery.length > 0) {
        var testString = searchQuery.toLowerCase();
        vm.filteredPlaylists = intermediateList.filter(function (station) {
          var subject = [station.name, station.subname, station.featuredPlaylists].join(' ').toLowerCase();
          return subject.match(testString);
        });
      } else {
        vm.filteredPlaylists = intermediateList;
      }
    }
    else {
      vm.filteredPlaylists = vm.playlists;
    }
    vm.filterStatus = filterStatus;
  }

  function filterStationCategories (filterIds, filterType, cat) {
    if (filterIds.indexOf(cat.id) !== -1) {
      vm.selectedStationCategories.push({
        id: cat.id,
        name: cat.name,
        type: filterType
      });
    }
  }

  function locationSearch() {
    return function (item) {
      return vm.query === ''
        || (item.username && item.username.toLowerCase().indexOf(vm.query.toLowerCase()) > -1)
        || (item.city && item.city.toLowerCase().indexOf(vm.query.toLowerCase()) > -1)
        || (item.state && item.state.toLowerCase().indexOf(vm.query.toLowerCase()) > -1)
        || (item.timezone && item.timezone.toLowerCase().indexOf(vm.query.toLowerCase()) > -1)
        || (item.street && item.street.toLowerCase().indexOf(vm.query.toLowerCase()) > -1)
        || (item.street2 && item.street2.toLowerCase().indexOf(vm.query.toLowerCase()) > -1)
        || (item.zipcode && item.zipcode.toLowerCase().indexOf(vm.query.toLowerCase()) > -1);
    };
  }

  function onCompanyStationsActiveChange() {
    updateShowIsActiveSubmitBtn();

    $rootScope.confirmLocationSwitch = confirmLocationSwitchMessage;
    $timeout(function () {
      vm.formController.$setDirty();
    });
  }

  function orderLocations (orderBy) {
    vm.reverse = (vm.orderBy === orderBy) ? !vm.reverse : false;
    vm.orderBy = orderBy;
    vm.sortDirection = (vm.reverse) ? 'down' : 'up';
    vm.locations = customLocationSort(vm.locations);
  }

  function shouldDisableSubmitButton () {
    return vm.formController.$invalid || vm.formController.$pristine || !checkCompanyStationCounts() || vm.isSaving;
  }

  function removePlaylist (playlist) {
    $rootScope.confirmLocationSwitch = confirmLocationSwitchMessage;
    vm.formData.companyStationDetails.splice(vm.formData.companyStationDetails.indexOf(playlist), 1);
    decrementCompanyStationCounts(playlist.type);
    vm.formController.$setDirty();
  };

  function removePlaylistFilter (filter) {
    $rootScope.$broadcast('remove-filter', filter, function (status, filterStatus, filterList, searchQuery) {
      if (status) {
        var index = -1;
        for(i = 0; i < vm.selectedStationCategories.length; i++) {
          if (vm.selectedStationCategories[i].id === filter.id) {
            index = i;
            break;
          }
        }
        if (index > -1) {
          vm.selectedStationCategories.splice(index, 1);
          filterDataset(filterStatus, filterList, searchQuery)
        }
      }
    });
  }

  function submit() {

    // sanitize data to prevent duplicates due to bug discovered on 11/25/19 - fmadden
    purgeDuplicates();

    vm.isSaving = true;
    vm.formController.$setPristine();

    if (vm.companyStation) {
      api.editCompanyStation(vm.formData)
        .then(function (result) {
          if (result.error) {
            $scope.showError(result.error);
            vm.isSaving = false;
            return;
          } else {
            vm.companyStation.is_active = vm.formData.is_active;

            $rootScope.confirmLocationSwitch = false;
            $scope.showSuccess('Your Company Selections have been saved!');
            vm.isSaving = false;
            updateShowIsActiveSubmitBtn();
          }
        })
        .catch(function () {
          $rootScope.confirmLocationSwitch = false;
          $scope.showError('Could not update the Company Selections');
        });
    } else {
      vm.formData.limit_all_users = 0;
      vm.formData.is_active = 1;
      api.createCompanyStation(vm.formData)
        .then(function (result) {
          if (result.error) {
            $scope.showError(result.error);
            vm.isSaving = false;
            return;
          } else {
            $rootScope.confirmLocationSwitch = false;
            $scope.showSuccess('Your Company Selections have been saved!');
            api.getCompanyStations(me)
              .then(function (companyStationsResults) {
                vm.companyStation = companyStations.companyStation[0];
                initCompanyStations();
                vm.isSaving = false;
              })
              .catch(angular.noop);
          }
        })
        .catch(function () {
          $rootScope.confirmLocationSwitch = false;
          $scope.showError('Could not create the Company Selections');
        });
    }
  };

  function toggleCompanyStationsOnAllLocations(value) {
    if (vm.formData.companyStationDetails.length > 0 && vm.canLimitLocations) {
      if (value === TrueFlag) {
        api.limitAllLocations(me)
          .then(function(result) {
              if (result.error) {
                $scope.showError(result.error);
                return
              } else {
                $scope.showSuccess('All locations are now limited to your Company Selections!');
                vm.toggleAllForCompanyStationsFlag = TrueFlag;
                getLocations();
              }
            })
          .catch(function(err) {
              if (err.code === 'ConflictError') {
                $scope.showError('Error: ' + err.message);
              } else {
                $scope.showError("Error: We could not complete the update at this time.");
              }
              console.error("Error: Failed to remove limits on all locations from the Company Selections screen.",err);
          });
      }
      else if (value === FalseFlag) {
        api.undoLimitAllLocations(me)
          .then(function(result) {
              if (result.error) {
                $scope.showError(result.error);
                return
              } else {
                $scope.showSuccess('Locations are no longer limited to your Company Selections.');
                vm.toggleAllForCompanyStationsFlag = FalseFlag;
                getLocations();
              }
            })
          .catch(function(err) {
              if (err.code === 'ConflictError') {
                $scope.showError('Error: ' + err.message);
              } else {
                $scope.showError("Error: We could not complete the update at this time.");
              }
              console.error("Error: Failed to limit all locations from the Company Selections screen.",err);
            });
      }
    } else {
      if (vm.canLimitLocations) {
        $scope.showError("You cannot apply this permission until there is music assigned in your Company Selections above.");
      } else {
        $scope.showError("You don't have permission to change this setting.  You must be an account owner or music administrator.");
      }
    }
  }

  function toggleCompanyStationsOnLocation(userid) {
    if (userid) {
      if (vm.formData.companyStationDetails.length > 0 && vm.canLimitLocations) {
        api.toggleLimitLocation(api.userObject.account.custid, userid)
          .then( function (result) {
              if (result.err) {
                $scope.showError("Error: We could not complete the update at this time.");
                console.error("Error: Failed to toggle company selections for location.", err);
              }
              else {
                getLocations();
              }
            })
          .catch( function (err) {
              if (err.code === 'ConflictError') {
                $scope.showError('Error: ' + err.message);
              } else {
                $scope.showError("Error: We could not complete the update at this time.");
              }
              console.error("Error: Failed to toggle company selections for location.", err);
            });
      } else {
        if (vm.canLimitLocations) {
          $scope.showError("You cannot apply this permission until there is music assigned in your Company Selections above.");
        } else {
          $scope.showError("You don't have permission to change this setting.  You must be an account owner or music administrator.");
        }
      }
    }
  }

  function updateDefaultCompanySelections() {
    if (vm.userPerms.isAccountOwner) {
      var params = {
        skipBilling: 1,
        default_company_stations: parseInt(vm.locationDefault)
      };

      if (vm.formData.companyStationDetails.length > 0 && vm.canLimitLocations) {
        api.editAccount(me.account.custid, params, function(results) {
          // noop
        }, function(err) {
          vm.locationDefault = (parseInt(me.account.default_company_stations) === 1) ? 1 : 0;
          $scope.showError("Error: Location default could not be updated at this time.");
          console.error(err);
        });
      } else {
        $timeout(function () {
          vm.locationDefault = (parseInt(me.account.default_company_stations) === 1) ? 1 : 0;
        }, 100);
        if (vm.canLimitLocations) {
          $scope.showError("You cannot apply this permission until there is music assigned in your Company Selections above.");
        } else {
          $scope.showError("You don't have permission to change this setting.  You must be an account owner.");
        }
      }
    }
  }

  function updateFranchiseeLock() {
    api.editCompanyStation({
      companyStationid: vm.formData.companyStationid,
      franchisee_lock: vm.formData.franchisee_lock
    })
      .then(function (result) {
        if (result.error) {
          $scope.showError(result.error);
          return;
        }
      })
      .catch(function () {
        $rootScope.confirmLocationSwitch = false;
        $scope.showError('Could not update the Franchisee Lock setting.');
      });
  }

  // private methods

  function decrementCompanyStationCounts(type) {
    if (type === 'playlist' && vm.companyStationPlaylistCount > 0) {
      vm.companyStationPlaylistCount--;
    }
    else if (type === 'dayparting' && vm.companyStationDaypartCount > 0) {
      vm.companyStationDaypartCount--;
    }
    else if (type === 'mix' && vm.companyStationMixCount > 0) {
      vm.companyStationMixCount--;
    }
  }

  function incrementCompanyStationCounts(type) {
    if (type === 'playlist') vm.companyStationPlaylistCount++;
    else if (type === 'dayparting') vm.companyStationDaypartCount++;
    else if (type === 'mix') vm.companyStationMixCount++;
  }

  function init() {
    initCompanyStations();

    $scope.$on('playlistFiltersInitialized', function () {
      filterDataset();
    });
  }

  function initCompanyStations() {
    vm.companyStation = companyStations.companyStation[0];
    vm.isOrganizationCompanyStationsEnabled = vm.companyStation && vm.companyStation.custid !== me.account.custid;

    userInfo.getUserPerms(function(perms) {
      vm.userPerms = perms;
    });

    if (companyStations.companyStationDetails) {
      vm.companyStationDetails = companyStations.companyStationDetails.map(function (p){
        if (p.content_ratings) {
          p.ratingList = JSON.parse(p.content_ratings);
        }
        return p;
      });
    }

    if (vm.companyStation) {
      vm.formData = {
        companyStationid: vm.companyStation.companystationid,
        companyStationDetails: vm.companyStationDetails,
        is_active: vm.companyStation.is_active,
        franchisee_lock: vm.companyStation.franchisee_lock
      };

      for (var i = 0, c = vm.companyStationDetails; i < c.length; i++) {
        incrementCompanyStationCounts(c[i].type);
      }
    }

    updateShowIsActiveSubmitBtn();
    updateMasterLocationSwitch();
  }

  function getLocations () {
    api.getLocsWithStreamCounts(api.userObject.account.custid)
      .then(function (locationData) {
          if (locationData && locationData.locations) {
            vm.locations = locations = locationData.locations;
            updateMasterLocationSwitch();
          }
        })
      .catch(function (err) {
          console.error("Error: Failed to fetch locations.",err);
        });
  }

  // this function will go through and purge any station duplicates before submitting the data to API.
  function purgeDuplicates () {
    var checkList = [],
        newList = [],
        dataLength = 0,
        station = {};

    dataLength = vm.formData.companyStationDetails.length;

    for(var i=0; i < dataLength; i++) {
      station = vm.formData.companyStationDetails[i];
      if (checkList.indexOf(station.musicid) === -1) {
        checkList.push(station.musicid);
        newList.push(station);
      }
    }
    vm.formData.companyStationDetails = newList;
  }

  function updateMasterLocationSwitch () {
    var flag = OffFlag;

    // if we have locations then set initial value to value of first location in list
    if (vm.locations.length > 0) {
      flag = vm.locations[0].has_company_stations;
    }

    for (var i = 0; i < vm.locations.length; i++) {
      if (flag !== vm.locations[i].has_company_stations) {
        flag = OffFlag;
      }
      if (!vm.locations[i].address) {
        vm.locations[i].address = userInfo.buildAddress(vm.locations[i]);
      }
    }
    vm.toggleAllForCompanyStationsFlag = flag;
  }

  function updateShowIsActiveSubmitBtn() {
    vm.showIsActiveSubmitBtn = vm.companyStation && vm.companyStation.is_active && !vm.formData.is_active;
  }

}


app.controller('AdminDeviceApisCtrl', AdminDeviceApisCtrl);

AdminDeviceApisCtrl.$inject = ['$scope', 'api', 'apiKeys', 'userPerms', 'me', '$location'];

function AdminDeviceApisCtrl($scope, api, apiKeys, userPerms, me, $location) {
  $scope.apiKeyList = apiKeys;
  $scope.pageSize = 50;

  $scope.order = function (orderBy) {
    $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
    $scope.orderBy = orderBy;
  };

  $scope.clickBackButton = function () {
    $location.path('/admin/devices');
  };

  $scope.revokeKeys = function () {
    var checkboxen = $('.checkboxen input[type="checkbox"]');
    if (checkboxen) {
      for (var i=0; i < checkboxen.length; i++) {
        if (checkboxen[i].checked) {
          api.revokeSelfServeAPIKey({
            custid: me.account.custid,
            apikey: checkboxen[i].value
          }, function(result) {
            console.log(result);
            $location.path('/admin/devices');
          }, function(error) {
            console.log(error);
          });
        }
      }
    }
  };

}
app.controller('AdminDevicesCtrl', AdminDevicesCtrl);

AdminDevicesCtrl.$inject = ['$modal', '$scope', 'api', 'userPerms', 'me', '$location', 'selfServeStreamModal', 'selfServeAPIKeyModal'];

function AdminDevicesCtrl($modal, $scope, api, userPerms, me, $location, selfServeStreamModal, selfServeAPIKeyModal) {
  $scope.$parent.currentTab = 'devices';
  if (!userPerms.isAccountOwner) {
    return true;
  }
  $scope.locations = {};
  $scope.streams = {};
  $scope.pageSize = 50;
  $scope.form = { query: '' };

  $scope.order = function (orderBy) {
    $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
    $scope.orderBy = orderBy;
  };

  api.getLocsWithStreamCounts(me.user.custid).then(function(locationData) {
    for (idx in locationData.locations) {
      loc = locationData.locations[idx];
      $scope.locations[loc.userid] = loc.username + " - " + loc.street + ', ' + loc.state;
    }
  });

  api.getStreamsForAccount(function(result) {
    var stream = {};
    for (var i=0; i<result.streams.length; i++) {
      stream = result.streams[i];
      if (!$scope.streams[stream.userid]) {
        $scope.streams[stream.userid] = {};
      }
      $scope.streams[stream.userid][stream.streamid] = stream.streamname;
    }
  }, function(error) {
  });

  updateDeviceList = function() {
    api.getSelfServeDevices().then(function(devices) {
      $scope.deviceList = devices;
    });
  }

  updateDeviceList();

  $scope.showAPIDialog = function() {
    selfServeAPIKeyModal.show(me.account.custid).catch(angular.noop);
  }

  $scope.manageAPIKeys = function() {
    $location.path('/admin/deviceapikeys');
  }

  $scope.editDevice = function(device) {
    selfServeStreamModal.setOptions({
      deviceid: device.deviceid,
      uuid: device.uuid,
      name: device.name
    });
    selfServeStreamModal.setModel({
      userid: device.userid,
      streamid: device.streamid
    });
    selfServeStreamModal.show()
      .then(function(result) {
        if (result.status && result.status !== 200) {
          $scope.showWarning("There was a problem updating this device, please try again.  If the issue persists, please contact support");
        }
        else {
          updateDeviceList();
          $scope.showSuccess('The Device "'+ device.name + '" has been successfully updated');
        }
      })
      .catch(angular.noop);
  }

  $scope.search = function () {
    var query = $scope.form.query.toLowerCase();
    return function (item) {
      return query == ''
        || (item.name && item.name.toLowerCase().indexOf(query) > -1);
    }
  }

}

app.controller('LocationsCtrl', LocationsCtrl);

LocationsCtrl.$inject = ['$scope', 'subscriptionInfo', 'userInfo', 'locations', 'requirements'];

function LocationsCtrl ($scope, subscriptionInfo, userInfo, locations, requirements) {
  $scope.$parent.hideLoader();
  $scope.$parent.currentTab = 'locations';
  $scope.query = '';
  $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
  $scope.locations = locations;
  $scope.orderBy = 'username';
  $scope.order = function (orderBy) {
    $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
    $scope.orderBy = orderBy;
  };
  $scope.pageSize = 50;

  // public methods
  $scope.search = search;

  if (requirements.showNotification) {
    var missingAddress = locations.reduce(function(acc,item) {
      if (!item.street || !item.city || !item.state || !item.zipcode) {
        acc.push(item.username);
      }
      return acc;
    }, []).join(', ');
    $scope.showWarning("The addresses of all locations are needed for license reporting. Click the pencil icon to enter the address(es) for these locations to continue: " + missingAddress, { ttl: -1 });
  }

  for (var i = 0; i < $scope.locations.length; i++) {
    $scope.locations[i].address = userInfo.buildAddress($scope.locations[i]);
  }

  function search() {
    return function (item) {
      return $scope.query === ''
        || (item.username && item.username.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
        || (item.city && item.city.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
        || (item.state && item.state.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
        || (item.timezone && item.timezone.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
        || (item.street && item.street.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
        || (item.street2 && item.street2.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
        || (item.zipcode && item.zipcode.toLowerCase().indexOf($scope.query.toLowerCase()) > -1);
    };
  }

}

app.directive('phoneValidator', function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      scope.$watch(function () {
        return ctrl.$modelValue;
      }, function (newVal, oldVal) {
        var phoneFormat = /\d+/g;
        if (newVal) {
          var matchedValue = newVal.match(phoneFormat);
          if (matchedValue) {
            // strip of non numeric characters
            var formattedPhone = matchedValue.join([]);
            if (formattedPhone) {
              scope.formdata.phone = formattedPhone;
              // validate length, expected 10 digit
              if (formattedPhone.length !== 10) {
                ctrl.$setValidity("phoneValidator", false);
                return newVal;
              }
            }
          } else {
            scope.formdata.phone = "";
          }
        }
        ctrl.$setValidity("phoneValidator", true);
        return newVal;
      });
    }
  };
});

app.controller('EditLocationCtrl', EditLocationCtrl);

EditLocationCtrl.$inject = ['$scope', 'api', '$state', '$modal', 'user', '$rootScope', '$timeout', 'companyStations', 'requirements', 'formEditService'];

function EditLocationCtrl($scope, api, $state, $modal, user, $rootScope, $timeout, companyStations, requirements, formEditService) {
  $scope.isEditing = true;
  $scope.$parent.hideLoader();
  $scope.$parent.currentTab = 'locations';
  $scope.timezones = window.timeZones;
  $scope.statesProvinces = window.statesProvinces;
  $scope.formdata = user.user;
  $scope.formdata.permissions = user.permissions;
  $scope.formdata.has_company_stations = user.user.has_company_stations;
  $scope.permissionHistory = JSON.stringify(user.permissions);
  $scope.guardCompanySelections = guardCompanySelections;
  var confirmLocationSwitch = 'Are you sure? Your changes have not been saved. Do you wish to proceed?';
  $rootScope.confirmLocationSwitch = confirmLocationSwitch;

  $scope.clickBackButton = function () {
    formEditService.confirmNavigation($scope, true, '/admin/locations', confirmLocationSwitch);
  };

  $scope.submit = function () {
    if (!api.userObject.permissions.admin.superadmin && $scope.formdata.password) {
      openReauthenticateModal($scope.formdata)
        .then(function (result) {
          if (result) {
            if (result.status == "ok") {
              $scope.onEditUserSuccess(result.data);
            } else {
              $scope.onEditUserError(result.data);
            }
          }
        })
        .catch(angular.noop);
    } else {
      api.editUser($scope.formdata, $scope.onEditUserSuccess, $scope.onEditUserError);
    }
  };

  $scope.onEditUserSuccess = function(data) {
    // 2021-01-14 rporczak -- HACK. Previously, the Time Zone in the Trial Conversion popup would either be
    //  blank, or hidden if the current user already had a time zone. Now, we want to load it with whatever
    //  the current user's timezone is, as that may be updated when the form is submitted. However, this call
    //  doesn't update the user data in the scope/cache, so we must do that manually. Only updating the
    //  timezone (and not the entire user object), because there are some key/values missing in the response.
    if (data.user.custid === api.userObject.user.custid && data.user.userid === api.userObject.user.userid) {
      api.userObject.user.timezone = $scope.me.user.timezone = data.user.timezone;
    }

    $scope.$emit('refreshAccountInfo');
    $rootScope.confirmLocationSwitch = false;
    $scope.showSuccess( 'The Location has been updated!');
    // refresh the account requirements so that they're not outdated
    if (!requirements.loaded || !requirements.cache.AllLocationsWithAddress) {
      api.checkAccountRequirements($scope.me.account.custid, function (result) {
        requirements.save(result);
        requirements.process(function () {
          $state.go('account.admin.locations');
        }, api.userObject);
      });
    } else {
      $state.go('account.admin.locations');
    }
  };

  $scope.onEditUserError = function(err) {
    $scope.showError('We were unable to save your changes');
    console.error('Unable to save location details', err);
  };

  function openReauthenticateModal(locationData) {
    return $modal
      .open({
        templateUrl: 'partials/reauthenticate_modal.html',
        windowClass: 'reauthenticate-modal',
        controller: ['$modalInstance', 'api', 'locationData',
          function ($modalInstance, api, locationData) {
            var vm = this;

            // Properties
            vm.returnResponse = {};
            locationData.userpassword = "";
            locationData.user_username = api.userObject.user.username;
            vm.locationData = locationData;

            // Methods
            vm.dismiss = dismiss;
            vm.confirmPassword = confirmPassword;
            vm.clearStatus = clearStatus;

            function confirmPassword() {
              api.editUser(vm.locationData, function (data) {
                vm.returnResponse.status = 'ok';
                vm.returnResponse.data = data;
                $modalInstance.close(vm.returnResponse);
              }, function (err) {
                if (err.message.includes("Invalid user password")) {
                  vm.returnResponse.status = "error";
                } else {
                  vm.returnResponse.status = "error";
                  vm.returnResponse.data = err;
                  $modalInstance.close(vm.returnResponse);
                }
              });
            }
            function clearStatus() {
              vm.returnResponse.status = "";
            }
            function dismiss() {
              $modalInstance.close();
            }
          }
        ],
        controllerAs: 'vm',
        resolve: {
          locationData: function () {
            return locationData;
          }
        }
      })
      .result;
  }

  function guardCompanySelections() {
    if (
        $scope.formdata.has_company_stations === 1 &&
        (
          !companyStations ||
          !companyStations.companyStationDetails ||
          companyStations.companyStationDetails.length < 1
        )
    ) {
      $scope.showError('You must first add a Station, Mix, or Daypart to your Company Selections before you can enable this restriction.');
      $timeout(function() {
        $scope.formdata.has_company_stations = 0;
      }, 100);
    }
  }

  $scope.$parent.topTitle = 'Edit Region: ' + $scope.formdata.username;
}


Date.prototype.getWeek = function() {
  var date = new Date(this.getTime());
  date.setHours(0, 0, 0, 0);
  // Thursday in current week decides the year.
  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
  // January 4 is always in week 1.
  var week1 = new Date(date.getFullYear(), 0, 4);
  // Adjust to Thursday in week 1 and count number of weeks from date to week1.
  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000
                        - 3 + (week1.getDay() + 6) % 7) / 7);
}

app.factory('editMessageScheduleService', ['$location',
  function($location) {
    var service = this;

    service.dow = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    service.dowabrev = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    service.months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    service.pad = function(n, width) {
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
    }

    service.generateId = function() {
      return Math.random().toString(36).substr(2, 12);
    }
    service.getFormattedDate = function(date) {
      return service.months[date.getMonth()] + ' ' + date.getDate() + ', ' + date.getFullYear();
    }

    service.getWeekList = function() {
      var date = new Date();
      var startDate = new Date();
      var endDate = new Date();
      var dow = startDate.getDay();
      var dateList = [];
      //startDate.setDate(date.getDate() - dow + 1);
      startDate.setDate(date.getDate() - dow - (25*7) + 1);
      startDate.setHours(0,0,0,0);
      //endDate.setDate(date.getDate() - dow + 7);
      endDate.setDate(date.getDate() - dow - (24*7));
      endDate.setHours(23,59,59,000);

      for(var i=0; i<52; i++) {
        dateList.push({
          start: {
            date: service.getFormattedDate(startDate),
            ymd: startDate.getFullYear() + '-' + service.pad(startDate.getMonth() + 1, 2) + '-' + service.pad(startDate.getDate(),2),
            timestamp: startDate.getTime() / 1000
          },
          end: {
            date: service.getFormattedDate(endDate),
            ymd: endDate.getFullYear() + '-' + service.pad(endDate.getMonth() + 1,2) + '-' + service.pad(endDate.getDate(),2),
            timestamp: (endDate.getTime() / 1000)
          }
        });
        startDate.setDate(startDate.getDate() + 7);
        endDate.setDate(endDate.getDate() + 7);
      }
      return dateList;
    }

    service.getWeekDays = function(startDate) {
      var weekDays = [];
      var time = 0;
      var dayName = '';
      var month = '';
      var dateStamp;
      for(var i=0; i < 7; i++) {
        time = startDate + (i * 86400);
        dateStamp = new Date(time * 1000);
        dayName = service.dowabrev[i];
        month = service.months[dateStamp.getMonth()];

        weekDays.push({
          dateStamp: time,
          dateString: dayName + ' ' + month + ' ' + dateStamp.getDate() + ', ' + dateStamp.getFullYear(),
          month: dateStamp.getMonth(),
          day: i,
          date: dateStamp.getDate(),
          year: dateStamp.getFullYear(),
        });
      }
      return weekDays;
    }

    service.getMessageList = function(messages) {
      var modalMessageList = [];
      for (var i=0; i<messages.length; i++) {
        if (messages[i].messageid > 0)
          modalMessageList.push({id: messages[i].messageid, name: messages[i].message_name});
      }
      return modalMessageList;
    }

    service.getMessagesById = function(messages) {
      var result = {};
      for(var i=0; i<messages.length; i++) {
        result[messages[i].messageid] = messages[i];
      }
      return result;
    }

    service.localTimeStringToDateTime = function(localDateTimeString) {
      var hour = parseInt(localDateTimeString.substr(9,2));
      var ampm = 'am';
      if (hour > 12) {
        ampm = 'pm'
        hour -= 12;
      } else if (hour == 0) {
        hour = 12;
      } else if (hour == 12) {
        ampm = 'pm';
      }
      return {
        year: localDateTimeString.substr(0,4),
        month: localDateTimeString.substr(4,2),
        day: localDateTimeString.substr(6,2),
        hour: hour,
        minute: localDateTimeString.substr(11,2),
        ampm: ampm
      }
    }

    service.getHourMinuteAmpm = function(input) {
      var hours = Math.floor(input / 60);
      // Let's make this 1 hour incr, with am/pm 12hour time.
      var ampm = '';
      if (hours == 0 || hours == 24) {
        hours = '12';
        ampm = 'am';
      }
      else if (hours < 12) {
        ampm = 'am';
      }
      else if (hours == 12) {
        ampm = 'pm';
      }
      else {
        hours = (hours - 12);
        ampm = 'pm';
      }
      var minutes = input % 60;
      return {
        hour: hours,
        minute: minutes,
        ampm: ampm
      }
    }

    service.getTimeLabel = function(input){
      var timeInfo = service.getHourMinuteAmpm(input);
      return service.pad(timeInfo.hour, 2)+':'+service.pad(timeInfo.minute, 2) + timeInfo.ampm;
    }

    service.getMessageScheduleEvents = function(scheduleItems, messagesById, start, end, callback) {
      var schedData = [];
      var startDate = new Date(start*1000);
      var endDate = new Date(end*1000);

      for (var i=0; i<scheduleItems.length; i++) {
        var itemDef = scheduleItems[i];
        if (!messagesById[itemDef.messageid]) {
          // 2017-11-13 RK: Protect against trying to get details for deleted messages in a schedule
          continue;
        }
        var localStartTime = moment(itemDef.start_at).toDate();
        var utcStartTime = moment.utc(localStartTime).format('YYYYMMDDTHHmmss');
        var dtstart = ';DTSTART=' + utcStartTime + 'Z';
        var until = itemDef.end_at ? ';UNTIL=' + itemDef.end_at + 'Z' : '';
        var recurInfo = itemDef.recurInfo || 'COUNT=1;FREQ=DAILY';
        var recur = 'RRULE:' + recurInfo + dtstart + until;
        var ruleOrSet = rrulestr(recur);

        var instanceDates = ruleOrSet.between(startDate, endDate, true); // between start and end inclusive
        for (var j=0; j<instanceDates.length; j++) {
          var schedItem = {
            play_at: instanceDates[j],
            message_uri: '/' + messagesById[itemDef.messageid].message_file,
            name: messagesById[itemDef.messageid].message_name,
            scheduleid: itemDef.scheduleid,
            itemid: itemDef.itemid
          }
          schedData.push(schedItem);
        }
      }
      callback(schedData);
    }

    /*******************************************************
     * getAgendaList()
     *
     * Given a series of events, create a series of slots for chart.
     *
     * If event does repeat, and ends on a date within the week, return
     * only number of repeat slots set for current week, less than endDate.
     *
     * If event repeats, and ends after a number of times, then if number
     * of times is less than the number of days of repeat, then return slot
     * for each day that event is set for.
     *
     * If event repeats and ends on a date, then if end date is durring
     * current week, then repeat the number of days set for the event, as
     * long as date is less than end date.
     *
     * If event repeats and ends on a date, after current week, then return
     * slot for each set day of current week (after start date).
     *
     * for each event we'll need to get
     *    - message name
     *    - determine start time from start date.  Date in formation YYYY-MM-DDTHH:MM:SS.XXXZ
     *    - repeat frequency from recurInfo
     *    - repeat days from recurInfo
     *
     *
     * New format looks like the following:
     *   scheduleid: 8
     *   itemid: 8
     *   messageid: 2544
     *   recurInfo: "FREQ=DAILY;BYDAY=SU,MO,WE,TH,FR"
     *   start_at: "2017-07-24T00:00:00.000Z"
     *   end_at: "2017-08-31T00:00:00.000Z"
     *   created_at: "2017-08-16T13:23:58.000Z"
     *   modified_at: "2017-08-16T13:23:58.000Z"
     *
     *******************************************************/
    service.getAgendaList = function(events, schedule) {
      var day = 0;
      var start = 0;
      var dateLabel = '';
      var timeLabel = '';
      var agendaList = [];
      var recurring = [];
      var repeating = false;
      var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      var days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

      function compare(a, b) {
        if (a.day > b.day) return 1;
        else if (a.day < b.day) return -1;
        else {
          if (a.start > b.start) return 1;
          else if (a.start < b.start) return -1;
          else return 0;
        }
      }

      for (var i=0; i<schedule.scheduleitems.length; i++) {
        if (schedule.scheduleitems[i].recurInfo.match('FREQ')) {
          recurring.push(schedule.scheduleitems[i].itemid);
        }
      }

      for (var i=0; i<events.length; i++) {
        start = (events[i].play_at.getHours() * 60) + events[i].play_at.getMinutes();
        timeLabel = service.getTimeLabel(start);
        // our dates are 0-based from Mon - Sun.  JS Date gives Day of week 0-based from Sun to Sat.
        day = events[i].play_at.getDay()-1;
        if (day == -1) day = 6;
        dateLabel = days[day]+', '+months[events[i].play_at.getMonth()]+' '+events[i].play_at.getDate()+', '+events[i].play_at.getFullYear();
        repeating = (recurring.indexOf(events[i].itemid) > -1);

        agendaList.push({
          start: start,
          stop: start + 1,
          day: day,
          scheduleid: events[i].scheduleid,
          itemid: events[i].itemid,
          name: events[i].name,
          timeLabel: timeLabel,
          dateLabel: dateLabel,
          repeating: repeating
        });
      }
      return agendaList.sort(compare);
    }

    service.addNewSchedule = function (username, callback) {
      var now = new Date();
      var name =
        username + '-' + now.getFullYear() +
        service.pad(now.getMonth() + 1, 2) +
        service.pad(now.getDate(), 2) + '-' +
        service.pad(now.getHours(), 2) +
        service.pad(now.getMinutes(), 2) +
        service.pad(now.getSeconds(), 2);

      callback(name);
    };

    return service;
  }
]);

app.controller('AdminMessagePresetCtrl', ['$scope', 'confirmationDialog', 'api', '$location', 'presets', 'messageSelection', 'subscription', 'userPerms', 'me',
  function($scope, confirmationDialog, api, $location, presets, messageSelection, subscription, userPerms, me) {
    $scope.$parent.currentTab = 'message_presets';
    $scope.$parent.hideLoader();
    $scope.presetPage = presets.meta.page;
    $scope.presetTotal = presets.meta.total;
    $scope.presetLimit = presets.meta.limit;
    $scope.me = me;
    $scope.userPerms = userPerms;
    $scope.subscription = subscription;
    $scope.presets = presets.presets.filter(function(item) {
      if (
        item.isGlobal                         ||
        $scope.userPerms.isMessageAdmin       ||
        item.userid === $scope.me.user.userid ||
        $scope.me.message_preset === item.presetid
      ) {
        return true;
      }
    });

    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'name';
    $scope.reverse = false;
    $scope.search = function () {
      return function (item) {
        return $scope.query == ''
          || (item.name && item.name.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.username && item.username.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.messages && item.messages.toLowerCase().indexOf($scope.query.toLowerCase()) > -1);
      };
    };

    $scope.order = function (orderBy) {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
      $scope.orderBy = orderBy;
    };

    $scope.customSort = function () {
      if ($scope.orderBy == 'isActive' || $scope.orderBy == 'isGlobal') {
        if ($scope.reverse) {
          return $scope.presets.sort(function (a, b) {
            return a[$scope.orderBy] > b[$scope.orderBy] ? 1 : a[$scope.orderBy] < b[$scope.orderBy] ? -1 : 0;
          });
        }
        else {
          return $scope.presets.sort(function (a, b) {
            return a[$scope.orderBy] > b[$scope.orderBy] ? -1 : a[$scope.orderBy] < b[$scope.orderBy] ? 1 : 0;
          });
        }
      }

      if ($scope.reverse) {
        return $scope.presets.sort(function (a, b) {
          var x = a[$scope.orderBy].toString().toLowerCase(),
              y = b[$scope.orderBy].toString().toLowerCase();
          return x > y ? -1 : x < y ? 1 : 0;
        });
      }
      else {
        return $scope.presets.sort(function (a, b) {
          var x = a[$scope.orderBy].toString().toLowerCase(),
              y = b[$scope.orderBy].toString().toLowerCase();
          return x > y ? 1 : x < y ? -1 : 0;
        });
      }
    };

    $scope.getPresetPage = function(page) {
      api.getPresets(page).then(function(result) {
        $scope.presetPage = result.meta.page;
        $scope.presetTotal = result.meta.total;
        $scope.presetLimit = result.meta.limit;
        $scope.presets = result.presets.filter(function(item) {
          if (
            item.isGlobal                         ||
            $scope.userPerms.isMessageAdmin       ||
            item.userid === $scope.me.user.userid ||
            $scope.me.message_preset === item.presetid
          ) {
            return true;
          }
        });
      });
    };

    $scope.removePreset = function(preset) {
      if (preset.isActive) {
        return $scope.showError('You cannot delete the Message Preset: ' + preset.name + ', because it is currently in use.');
      }
      confirmationDialog($scope,
        'Are you sure you want to delete message preset ' + preset.name + '?',
        function(){
          api.removeMessagePresetById(preset.presetid, function() {
            $scope.showSuccess( 'Your preset <b>"' + preset.name + '"</b> has been removed');
            $scope.getPresetPage($scope.presetPage);
            messageSelection.loadPresets();
          },function(err){
            console.error("Error in removeMessagePresetById", err);
            $scope.showError('Could not remove the message preset');
            $location.path('/admin/messages/presets');
          });
        }).catch(angular.noop);
    };
  }
]);

/******************************************************\
 * AdminMessagesCtrl Controller for Message Library
 * route: /admin/messages
\******************************************************/
app.controller('AdminMessagesCtrl', ['$scope', 'api', '$location', 'requests', 'messages', 'subscription', 'confirmationDialog', 'messageUploadModal', 'userInfo', 'subscriptionInfo',
  function($scope, api, $location, requests, messages, subscription, confirmationDialog, messageUploadModal, userInfo, subscriptionInfo) {

    var isEditingMessage = false;
    $scope.$parent.currentTab = 'message_library';
    $scope.$parent.hideLoader();

    $scope.requests = requests.requests;
    $scope.statusArray = requests.statuslist;

    userInfo.getUserPerms(function(userPerms) {
      if (
        (!subscriptionInfo.messageQuantityAllowedPerPreset()) ||
        (!userPerms.isMessageAdmin && !userPerms.canManageMessages)
      ) {
        $location.path('/admin/zones');
      }
      if (userPerms.isPaymentAdmin) {
        $scope.isPaymentAdmin = userPerms.isPaymentAdmin;
      }
    });


    $scope.subscription = subscription;

    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'created_at';
    $scope.reverse = true;
    $scope.sortDirection = 'up';

    $scope.order = function (orderBy) {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
      $scope.orderBy = orderBy;
      $scope.sortDirection = ($scope.reverse) ? 'down' : 'up';
      $scope.messages = customSort($scope.messages);
    };

    $scope.searchMessages = function() {
      $scope.messages = customSort(messages.messages);
    }

    var customMessageSearch = function(messages) {
      var results = [];
      if ($scope.search && $scope.search.length > 0) {
        for (var i=0; i<messages.length; i++) {
          if (messages[i].message_name.toLowerCase().indexOf($scope.search.toLowerCase()) !== -1) {
            results.push(messages[i]);
          }
        }
      } else {
        return messages;
      }
      return results;
    }

    var customSort = function(messages) {
      var result = [];
      messages = customMessageSearch(messages);
      if ($scope.reverse) {
        result = messages.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? -1 : x < y ? 1 : 0;
        });
        return result;
      }
      else {
        result = messages.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? 1 : x < y ? -1 : 0;
        });
        return result;
      }
    }
    $scope.messages = customSort(messages.messages);

    $scope.canDelete = function(message) {
      return (message.preset_count === 0 && message.schedule_count === 0);
    }

    $scope.deleteTitle = function(message) {
      if ($scope.canDelete(message)) {
        return "Delete Message";
      }
      else {
        return "This message is in use and cannot be deleted";
      }
    }

    $scope.playMessage = function($event, message, checkMessage) {
      if (checkMessage) {
        if ($scope.isEditing(message)) return;
      }
      if ($scope.messagePlaying == message.message_uuid) $scope.messagePlaying = null;
      else $scope.messagePlaying = message.message_uuid;

      $scope.pushMedia({
        id: message.message_uuid,
        name: message.message_name,
        description: 'testing message',
        mediaType: 'message',
        mediaUrl: message.url
      });
    };

    $scope.$on('playFinished', function(details, data) {
      if ($scope.messagePlaying == data.id && data.mediaType == 'message') {
        $scope.messagePlaying = null;
      }
    });

    $scope.$on('$locationChangeSuccess', function() {
      if ($scope.interruptMedia && $scope.interruptMedia.description === "testing message") {
        $scope.interruptMedia.scope.playNextMedia();
      }
    });

    $scope.isEditing = function(message) {
      return (isEditingMessage == message.messageid);
    }

    $scope.editMessage = function(message) {
      if (isEditingMessage != message.messageid) {
        isEditingMessage = message.messageid;
        $scope.messageName = {value: message.message_name};
      }
    }

    $scope.cancelMessage = function(message) {
      isEditingMessage = null;
      $scope.messageName = {value: message.message_name};
    }

    $scope.saveMessage = function(message) {
      var messageName = $scope.messageName.value;
      api.editMessage({
        messageid: message.messageid,
        message_name: messageName
      }, function() {
        console.log('edit success');
        $scope.showSuccess( 'Message <b>"' + messageName + '"</b> successfully updated');
        message.message_name = messageName;
      }, function(err) {
        $scope.showError( 'Changes to message <b>"' + messageName + '"</b> could not be saved');
        if (err) { console.error(err); }
      });
      isEditingMessage = false;
      $scope.messageName.value = '';
    }

    $scope.getMessagePage = function(page) {
      api.getMessagesWithStatus().then(function(result) {
        $scope.messagePage = result.meta.page;
        $scope.messageTotal = result.meta.count;
        $scope.messageLimit = result.meta.limit;
        $scope.messages = customSort(result.messages);
      });
    };

    $scope.removeMessage = function(message) {
      if ($scope.canDelete(message)) {
        confirmationDialog($scope,
          'Are you sure you want to delete the message ' + message.message_name + '?',
          function(){
            api.deleteMessage(message.messageid, function() {
              $scope.showSuccess( 'Your message <b>"' + message.message_name + '"</b> has been removed');
              $scope.getMessagePage($scope.messagePage);
            },function(err){
              console.error("Error in deleteMessage", err);
              $scope.showError('Could not remove the message');
              $location.path('/admin/messages');
            })
          }).catch(angular.noop);
      }
    }

    $scope.uploadMessage = function() {
      messageUploadModal.show()
        .then(function (result) {
          if (result.status == 'error') {
            $scope.showError(result.resultMessage);
          } else if (result.status == 'ok') {
            $scope.getMessagePage($scope.messagePage);
            $scope.showSuccess(result.resultMessage);
          }
        })
        .catch(angular.noop);
    }
  }
]);

app.controller('AdminMessageRequestCtrl', ['$scope', 'api', '$location', '$rootScope',
  function($scope, api, $location, $rootScope) {

    $scope.dataReady = true;
    $scope.$parent.hideLoader();
    $scope.$parent.currentTab = 'message_library';
    $scope.agreement = false;

    $rootScope.confirmLocationSwitch = 'Are you sure? Your request will not be saved!';

    $scope.genders = [
      { name: 'No Preference', value: 'No Preference' },
      { name: 'Talent Preference', value: 'Talent Preference' },
      { name: 'Male Generic', value: 'Male Generic' },
      { name: 'Female Generic', value: 'Female Generic' },
      { name: 'Male Young Energetic', value: 'Male Young Energetic' },
      { name: 'Female Young Energetic', value: 'Female Young Energetic' },
      { name: 'Male Hispanic', value: 'Male Hispanic' },
      { name: 'Female Hispanic', value: 'Female Hispanic' },
      { name: 'Male African American', value: 'Male African American' },
      { name: 'Female African American', value: 'Female African American' },
    ];

    $scope.energies = ['No Preference', 'Low', 'Medium', 'High'];
    $scope.chimes = ['No Preference', 'Yes', 'No'];

    $scope.backgroundMusic = [
      { name: 'No Preference', value: 'No Preference' },
      { name: 'None', value: 'None' },
      { name: 'Acoustic', value: 'Acoustic', sample: 'Acoustic.mp3' },
      { name: 'Beats', value: 'Beats', sample: 'Beats.mp3' },
      { name: 'Big Band', value: 'Big Band', sample: 'BigBand.mp3' },
      { name: 'Country', value: 'Country', sample: 'Country.mp3' },
      { name: 'Dance', value: 'Dance', sample: 'Dance.mp3' },
      { name: 'Dance Piano', value: 'Dance Piano', sample: 'DancePiano.mp3' },
      { name: 'Dance Synth', value: 'Dance Synth', sample: 'DanceSynth.mp3' },
      { name: 'Downtown City Beat', value: 'Downtown City Beat', sample: 'DowntownCityBeat.mp3' },
      { name: 'Guitar/Rock', value: 'Guitar/Rock', sample: 'GuitarRock.mp3' },
      { name: 'Jazz', value: 'Jazz', sample: 'Jazz.mp3' },
      { name: 'Latin Rock', value: 'Latin Rock', sample: 'Latinrock.mp3' },
      { name: 'Mellow Rock', value: 'Mellow Rock', sample: 'MellowRock.mp3' },
      { name: 'Mexican Guitar', value: 'Mexican Guitar', sample: 'MexicanGuitar.mp3' },
      { name: 'Spanish Guitar', value: 'Spanish Guitar', sample: 'Spanishguitar.mp3' },
      { name: 'Steel Drum', value: 'Steel Drum', sample: 'SteelDrum.mp3' },
      { name: 'Strings/Bach', value: 'Strings/Bach', sample: 'StringsBach.mp3'},
      { name: 'Strings/Orchestra', value: 'Strings/Orchestra', sample: 'StringsOrch.mp3' },
      { name: 'Synth', value: 'Synth', sample: 'Synth.mp3' },
      { name: 'Techno', value: 'Techno', sample: 'Techno.mp3' }
    ];

    $scope.formdata = {
      request_email: api.userObject.user.email,
      message_name: '',
      request_script: '',
      request_gender: 'No Preference',
      request_chime: 'No Preference',
      request_background: 'No Preference',
      request_energy: 'No Preference'
    };

    $scope.error = '';
    $scope.wordCounter = function() {
      if (angular.isUndefined($scope.formdata.request_script)) {
        $scope.wordCount = '';
      } else {
        $scope.wordCount = $scope.formdata.request_script.split(' ').length;
      }

      if ($scope.wordCount > 75) {
        $scope.error = 'Your word count should stay below 75 words';
      } else {
        $scope.error = '';
      }
    }

    $scope.submit = function() {
      if ($scope.error === '' && $scope.agreement) {
        $scope.formdata.userid = api.userObject.user.userid;
        api.requestMessage($scope.formdata, function(result) {
          $rootScope.confirmLocationSwitch = false;
          $scope.showSuccess( 'Your message <b>"' + $scope.formdata.message_name + '"</b> has been submitted and you will receive an email copy. We will record and post your message within 5 business days. You will be notified in email once it is posted. There are no edits to submitted messages.');
          $location.path('/admin/messages');
        }, function(err) {
          console.error("Error while submitting new message request form.", err);
        })
      } else {
        $scope.showError('Your word count should stay below 75 words');
      }
    };

    $scope.currentBackgroundMusic = false;
  }
]);

app.filter('filterAdminMessages', function() {
  return function(messages, query) {
    var results = [];
    if (!query || query.length === 0) return messages;
    for (var i=0; i<messages.length; i++) {
      if (messages[i].message_name.toLowerCase().indexOf(query.toLowerCase()) != -1) {
        results.push(messages[i]);
      }
    }
    return results;
  }
});


/**********************************************************************\
 * Message Scheduling
\**********************************************************************/
app.controller('AdminMessageScheduleCtrl', ['$scope', 'api', 'me', 'schedules', '$location', 'messageSelection', 'editMessageScheduleService', 'confirmationDialog', 'userPerms', 'messageScheduleDuplicationService',
  function($scope, api, me, schedules, $location, messageSelection, editMessageScheduleService, confirmationDialog, userPerms, messageScheduleDuplicationService) {
    $scope.has_permission = (me.permissions.user.manage_messages || me.permissions.account.owner || me.permissions.account.messages);
    $scope.$parent.currentTab = 'message_schedules';
    $scope.$parent.topTitle = 'Message Schedules';
    $scope.me = me;
    $scope.userPerms = userPerms;
    var date;
    var hours = 0;
    var ampm = '';
    for (var i=0; i<schedules.schedules.length; i++) {
      //schedules.schedules[i].lastModified = (new Date(schedules.schedules[i].modified_at)).toString().replace(/\S+\s(\S+)\s(\d+)\s(\d+)\s.*/,'$1 $2, $3');
      date = new Date(schedules.schedules[i].modified_at);
      hours = date.getHours();
      ampm = 'AM';
      if (hours == 24) {
        hours = 0;
      }
      if (hours > 11) ampm = 'PM';
      if (hours > 12) hours -= 12;
      schedules.schedules[i].lastModified = editMessageScheduleService.pad(date.getMonth()+1,2)+'/'+
        editMessageScheduleService.pad(date.getDate(),2)+'/'+
        date.getFullYear()+' '+editMessageScheduleService.pad(hours,2)+':'+
        editMessageScheduleService.pad(date.getMinutes(),2)+' '+ ampm;
    }
    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'name';
    $scope.reverse = false;

    var customSearch = function(data) {
      var results = [];
      if ($scope.query && $scope.query.length > 0) {
        for (var i=0; i<data.length; i++) {
          if ((data[i].name && data[i].name.toLowerCase().indexOf($scope.query.toLowerCase()) !== -1) ||
              (data[i].username && data[i].username.toLowerCase().indexOf($scope.query.toLowerCase()) !== -1)) {
            results.push(data[i]);
          }
        }
      } else {
        return data;
      }
      return results;
    }

    var customSort = function (schedules) {
      var result = [];
      schedules = customSearch(schedules);
      if ($scope.reverse) {
        return schedules.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? -1 : x < y ? 1 : 0;
        });
      }
      else {
        return schedules.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? 1 : x < y ? -1 : 0;
        });
      }
    };
    $scope.order = function (orderBy) {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
      $scope.orderBy = orderBy;
      $scope.sortDirection = ($scope.reverse) ? 'down' : 'up';
      $scope.schedules = customSort($scope.schedules);
    };

    $scope.schedules = schedules.schedules.filter(function(item) {
      if (
        item.isGlobal                         ||
        $scope.userPerms.isMessageAdmin       ||
        item.userid === $scope.me.user.userid ||
        $scope.me.schedule_id === item.scheduleid
      ) {
        return true;
      }
    });

    $scope.schedules = customSort($scope.schedules);

    $scope.search = function() {
      $scope.schedules = customSort(schedules.schedules);
    }


    $scope.addNewSchedule = function() {
      if ($scope.has_permission) {
        editMessageScheduleService.addNewSchedule(me.user.username, function(newName) {
          $location.url('/admin/messages/schedule/add/'+newName);
        });
      }
    }

    $scope.deleteMessageSchedule = function(index,scheduleId) {
      if ($scope.has_permission) {
        if ($scope.schedules[index].isActive) {
          $scope.showError("You can not delete the schedule named "+$scope.schedules[index].name+" because it is currently in use.");
        }
        else {
          confirmationDialog($scope, "Are you sure you want to remove the message schedule named "+$scope.schedules[index].name+"?",
            function() {
              api.removeMessageScheduleById(scheduleId, function(result) {
                $scope.schedules.splice(index,1);
                $scope.showSuccess("Schedule successfully deleted.");
                messageSelection.loadSchedules();
              }, function(err) {
                $scope.showError("Failed to delete Message Schedule.");
                console.error("Failed to delete message schedule "+scheduleId, err);
              });
            }
          ).catch(angular.noop);
        }
      }

    }

    $scope.duplicateMessageSchedule = function(index, scheduleId) {
      if ($scope.has_permission) {

        $scope.schedules[index].isDuplicating = true;
        $scope.showSuccess('Duplicating the message schedule <b>"' + $scope.schedules[index].name + '"</b>.');

        messageScheduleDuplicationService.duplicate($scope.me.user.userid, scheduleId)
          .then(function (result) {
            delete $scope.schedules[index].isDuplicating;

            var oldSchedule = $scope.schedules[index];

            $scope.schedules.splice(index+1, 0, {
              created_at: oldSchedule.created_at,
              isActive: false,
              isGlobal: false,
              lastModified: oldSchedule.lastModified,
              modified_at: oldSchedule.modified_at,
              name: result.name,
              scheduleid: result.scheduleid,
              userid: $scope.me.user.userid,
              username: $scope.me.user.username
            });
          })
          .catch(function (err) {
            delete $scope.schedules[index].isDuplicating;
            $scope.showError('There was an error attempting to duplicate ' + err.name + '.');
          });
      }
    };
  }
]);

app.controller('AdminEditMessageScheduleCtrl', ['$scope', '$state', '$rootScope', '$modal', 'api', 'me', 'scheduleId', 'messageScheduleDetails', 'messageSelection', 'messages', 'messageSchedulerModal', 'editMessageScheduleService', 'confirmationDialog', 'subscriptionInfo', 'formEditService', 'dataCacher',
  function($scope, $state, $rootScope, $modal, api, me, scheduleId, messageScheduleDetails, messageSelection, messages, messageSchedulerModal, editMessageScheduleService, confirmationDialog, subscriptionInfo, formEditService, dataCacher) {
    var vm = this;
    $scope.has_permission = (me.permissions.user.manage_messages || me.permissions.account.owner || me.permissions.account.messages);
    if (!$scope.has_permission) return;
    $scope.scheduleId = scheduleId;
    $scope.isEditing = (scheduleId) ? true : false;
    $scope.isEdited = false;
    $scope.dow = editMessageScheduleService.dow;
    $scope.$parent.currentTab = 'message_schedules';
    $scope.$parent.topTitle = 'Modify Message Schedule';
    $scope.messages = messages;
    $scope.showCalendarView = false;
    $scope.canAutoselect = me.permissions.user.can_play_music && me.permissions.user.select_messages;
    $scope.formData = messageScheduleDetails.schedule;
    $scope.isSaving = false;

    var initFormData;
    var initializeData = function() {
      var cachedData = dataCacher.getData();
      if (cachedData && cachedData.type === 'messageSchedule') {
        $scope.formData.autoselect = cachedData.autoselect;
        $scope.formData.isGlobal = cachedData.isGlobal;
        dataCacher.clearData();
      } else {
        $scope.formData.autoselect = 0;
      }
      initFormData = angular.copy($scope.formData);
    };
    initializeData();
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.allowSetGlobal = $scope.entStatus.isEnterprise && (me.permissions.account.owner || me.permissions.account.messages);

    $scope.changeForm = function() {
      $scope.isSaved = false;
      $scope.isEdited = formEditService.checkEdited(initFormData, $scope.formData);
    };

    $scope.clickBackButton = function() {
      formEditService.confirmNavigation($scope, $scope.isEdited, '/admin/messages/schedules');
    };

    $scope.weekList = editMessageScheduleService.getWeekList()
      .map(function (week) {
        week.label = week.start.date + ' - ' + week.end.date;

        return week;
      });

    $scope.currentWeek = 25;
    $scope.agendaList = {};

    var messagesById = editMessageScheduleService.getMessagesById(messages.messages);
    // get a list of event items that recurr
    var recurringItems = [];
    var scheduleItems = messageScheduleDetails.schedule.scheduleitems;
    for (var i=0; i<scheduleItems.length; i++) {
      if (scheduleItems[i].recurInfo.length > 0) {
        recurringItems.push(scheduleItems[i].itemid);
      }
    }
    var dataContainer = null;
    var scrollWidth = 0;
    var scrollLeft = 0;
    $scope.scheduleZoom = 1;
    $scope.zoomIn = function() {
      if ($scope.scheduleZoom < 3) {
        $scope.scheduleZoom++;
        setDataAreaSize();
      }
    }
    $scope.zoomOut = function() {
      if ($scope.scheduleZoom > 0) {
        $scope.scheduleZoom--;
        setDataAreaSize();
      }
    }
    var setDataAreaSize = function() {
      $scope.dataAreaSize = 'zoom'+$scope.scheduleZoom;
    }
    setDataAreaSize();

    var updateData = function(initialize) {
      if (!initialize) {
        $scope.isEdited = true;
        $scope.isSaved = false;
        $rootScope.confirmLocationSwitch = 'Your changes have not been saved. Do you wish to proceed';
      }
      var dateStamp;
      $scope.agendaList = {};
      $scope.slots = [];
      $scope.daysOfWeek = editMessageScheduleService.getWeekDays($scope.weekList[$scope.currentWeek].start.timestamp);

      editMessageScheduleService.getMessageScheduleEvents(messageScheduleDetails.schedule.scheduleitems, messagesById, $scope.weekList[$scope.currentWeek].start.timestamp, $scope.weekList[$scope.currentWeek].end.timestamp, function(results) {
        $scope.events = results;

        var itemList = editMessageScheduleService.getAgendaList($scope.events, messageScheduleDetails.schedule);
        $scope.noEvents = (itemList.length == 0);
        $scope.slots = itemList;
        for(var i=0; i<itemList.length; i++) {
          itemList[i].is_recurring = recurringItems.indexOf(itemList[i].itemid) > -1;
          dateStamp = $scope.daysOfWeek[itemList[i].day].dateStamp;
          if (!$scope.agendaList[dateStamp]) {
            $scope.agendaList[dateStamp] = []
          }
          $scope.agendaList[dateStamp].push(itemList[i]);
        }
      }, function(err) {
        console.error("Error in getMessageScheduleEvents",err);
      });
    }
    updateData(true);

    $scope.eventsHaveLoaded = function() {
      return ($scope.events) ? true : false;
    }

    $scope.setSchedulerClass = function() {
      var result = '';
      if ($scope.dataAreaSize.length > 0) {
        result = $scope.dataAreaSize;
      }
      if ($scope.showLocations) {
        result += ' show-locations';
      }
      return result;
    }

    $scope.setAgendaClass = function() {
      var result = '';
      if ($scope.showLocations) {
        result = 'show-locations';
      }
      return result;
    }

    $scope.selectWeek = function() {
      updateData(true);
    };

    $scope.previousWeek = function() {
      if ($scope.currentWeek > 0) {
        $scope.currentWeek--;
        $scope.selectWeek();
      }
    }

    $scope.thisWeek = function() {
      $scope.currentWeek = 25;
      $scope.selectWeek();
    }

    $scope.nextWeek = function() {
      if ($scope.currentWeek < 51) {
        $scope.currentWeek++;
        $scope.selectWeek();
      }
    }

    $scope.calendarView = function() {
      $scope.showCalendarView = true;
    }

    $scope.agendaView = function() {
      $scope.showCalendarView = false;
    }

    $scope.$on('schedule-container-loaded', function(event,container) {
      dataContainer = container;
      scrollWidth = container.scrollWidth;
    });

    $scope.$watch(function() {
      if (dataContainer) {
        return scrollWidth != dataContainer.scrollWidth
      }
    }, function() {
      if (dataContainer) {
        if (scrollWidth > 0) {
          scrollWidth = dataContainer.scrollWidth;
          dataContainer.scrollLeft = scrollLeft;
        } else {
          scrollWidth = dataContainer.scrollWidth;
        }
      }
    });

    var modalMessageList = editMessageScheduleService.getMessageList(messages.messages);

    messageSchedulerModal.setOptions({
      headerText: 'Add Message Event',
      actionButtonText: 'Save',
      messageList: modalMessageList,
      templateUrl: 'partials/message_scheduler_modal.html',
    });

    $scope.addMessage = function() {
      messageSchedulerModal.setOptions({
        headerText: 'Add Message Event',
        selectScope: false,
        hideDelete: true
      });
      messageSchedulerModal.setModel({
        scheduleid: scheduleId,
      });

      messageSchedulerModal.show()
        .then(function (result) {
          if ($scope.has_permission) {
            messageScheduleDetails.schedule.scheduleitems.push(result.series);
            updateData();
          }
        })
        .catch(angular.noop);
    }

    $scope.onMobileFormSubmission = function () {
      if (vm.formController.$invalid) {
        angular.element('html, body').animate({ scrollTop: 0 }, 500);
      }

      // TODO: Update the target button to be a form submit button in order for the following to happen automatically
      vm.formController.$setSubmitted();
      $scope.submit();
    };

    $scope.$on('addNewEvent', function(event, data) {
      if ($scope.has_permission) {
        // does weeklist not already contain the date and time split out?
        var startDate = new Date($scope.weekList[$scope.currentWeek].start.timestamp * 1000);
        startDate.setDate(startDate.getDate() + data.day);
        startDate.setHours(0,0,0,0);
        var dateString = (startDate.getMonth()+1)+'/'+startDate.getDate()+'/'+startDate.getFullYear();
        var startHour = Math.floor(data.startTime / 60);
        var startMinute = ('00' + (data.startTime % 60)).substr(-2);
        var startAmpm = 'am';
        if (startHour === 12) {
          startAmpm = 'pm';
        }
        else if (startHour > 12) {
          startHour -= 12;
          startAmpm = 'pm';
        }
        else if (startHour === 0) {
          startHour = 12;
        }
        messageSchedulerModal.setOptions({
          headerText: 'Add Message Event',
          selectScope: false,
          hideDelete: true,
        });
        messageSchedulerModal.setModel({
          day: data.day,
          scheduleid: scheduleId,
          startDate: dateString,
          startHour: startHour,
          startMinute: startMinute,
          startAmpm: startAmpm,
        });

        messageSchedulerModal.show().then(function (result) {
          messageScheduleDetails.schedule.scheduleitems.push(result.series);
          updateData();
        });
      }
    });

    $scope.$on('editEvent', function(event, data) {
      editEvent(data);
    });

    $scope.editEvent = function(eventId, dateInfo, time) {
      if ($scope.has_permission) {
        var day = dateInfo.day;
        if (day < 0) day = 6;

        editEvent({
          scheduleid: scheduleId,
          itemid: eventId,
          startTime: time,
          day: day
        });
      }
    }

    var editEvent = function(data) {
      var exceptions;
      var eventDetails;
      var eventIndex;
      for(var i=0; i<scheduleItems.length; i++) {
        if (scheduleItems[i].itemid == data.itemid) {
          eventDetails = scheduleItems[i];
          eventIndex = i;
          break;
        }
      }
      var startDate = editMessageScheduleService.localTimeStringToDateTime(eventDetails.start_at);
      var startHour = startDate.hour;
      var startMinute = startDate.minute;
      var startAmpm = startDate.ampm;
      var endDate = editMessageScheduleService.localTimeStringToDateTime(eventDetails.end_at);
      var endDateString = (endDate.month) ? endDate.month+'/'+endDate.day+'/'+endDate.year : '';
      var recurInfo = {};
      var repeatType = 'none';
      var weekDays = [];
      var dow = $scope.daysOfWeek[data.day];
      var dateString = startDate.month+'/'+startDate.day+'/'+startDate.year;
      var exDateString = (dow.month+1)+'/'+dow.date+'/'+dow.year;
      var endType = '';
      if (eventDetails.recurInfo.length > 0) {
        var recurOptions = rrulestr(eventDetails.recurInfo);
        if (recurOptions._exrule) {
          // handle exceptions
          var exDate, exDay, exMonth, exYear, exHour, exMinute;
          recurInfo = recurOptions._rrule[0].origOptions;
          for (var i=0; i<recurOptions._exrule.length; i++) {
            if (recurOptions._exrule[i].origOptions.dtstart) {
              exDate = recurOptions._exrule[i].origOptions.dtstart;
              exDay = exDate.getDate();
              exMonth = exDate.getMonth();
              exYear = exDate.getFullYear();

              if (exYear == dow.year && exMonth == dow.month && exDay == dow.day) {
                exDateString = (exMonth+1)+'/'+exDay+'/'+exYear;
                startHour = exDate.getHours();
                startMinute = exDate.getMinutes();
                startAmpm = 'am';
                if (startHour === 12) {
                  startAmpm = 'pm';
                }
                else if (startHour > 12) {
                  startHour -= 12;
                  startAmpm = 'pm';
                }
                else if (startHour === 0) {
                  startHour = 12;
                }
                break;
              }
            }
          }
        } else if (recurOptions._rrule) {
          // setup recur options
          recurInfo = recurOptions._rrule[0].origOptions;
        } else if (recurOptions.origOptions) {
          // setup recur options
          recurInfo = recurOptions.origOptions;
        }
        if (recurInfo.freq) {
          if (recurInfo.freq == RRule.DAILY) {
            repeatType = 'DAILY';
          }
        }
        if (recurInfo.count) {
          endType = 'afterPlays';
        } else {
          endType = 'onDate';
        }
        if (recurInfo.byweekday) {
          for(var i=0; i<recurInfo.byweekday.length; i++) {
            weekDays.push(recurInfo.byweekday[i].weekday);
          }
        }
      }

      messageSchedulerModal.setOptions({
        headerText: 'Edit Message Event',
        selectScope: true,
        hideDelete: false,
      });
      messageSchedulerModal.setModel({
        message: eventDetails.messageid,
        day: data.day,
        scheduleid: parseInt(scheduleId),
        itemid: data.itemid,
        startDate: dateString,
        exStartDate: exDateString,
        startHour: startHour,
        startMinute: startMinute,
        startAmpm: startAmpm,
        repeatType: repeatType,
        daysOfWeek: weekDays,
        endRepeatType: endType,
        endDate: endDateString,
        playCount: (recurInfo.count) ? recurInfo.count : '',
      });
      messageSchedulerModal.show().then(function (result) {
        if (result.scope == 'series') {
          if (result.modalStatus == 'delete') {
            deleteEventSeries(eventDetails);
            return;
          }
          else {
            messageScheduleDetails.schedule.scheduleitems[eventIndex] = result.series;
            scheduleItems = messageScheduleDetails.schedule.scheduleitems;
            updateData();
          }
        } else {
          var rrule = rrulestr(messageScheduleDetails.schedule.scheduleitems[eventIndex].recurInfo);
          if (!rrule._rrule) {
            var rruleSet = new RRuleSet();
            rruleSet.rrule(rrule);
            rrule = rruleSet;
          }
          if (result.modalStatus == 'delete') {
            rrule.exdate(result.date);
          } else {
            rrule.rdate(result.date);
          }

          messageScheduleDetails.schedule.scheduleitems[eventIndex].recurInfo = rrule.valueOf().join('\n');
          scheduleItems = messageScheduleDetails.schedule.scheduleitems;
          updateData();
        }
      }, function(dismiss) {
        console.log(dismiss);
      });
    }

    $scope.$on('deleteEvent', function(event, data) {
      if ($scope.has_permission) {
        deleteEvent(data);
      }
    });

    $scope.deleteEvent = function(eventId, dateStamp) {
      if ($scope.has_permission) {
        var date = editMessageScheduleService(dateStamp);

        deleteEvent({
          scheduleid: scheduleId,
          itemid: eventId,
          startTime: time,
          day: date.day,
        });
      }
    }

    var deleteEventSeries = function(data) {
      for(var i=0; i<messageScheduleDetails.schedule.scheduleitems.length; i++) {
        if (data.itemid === messageScheduleDetails.schedule.scheduleitems[i].itemid) {
          messageScheduleDetails.schedule.scheduleitems.splice(i,1);
          break;
        }
      }
      scheduleItems = messageScheduleDetails.schedule.scheduleitems;
      updateData();
    }

    var deleteEvent = function(data) {
      confirmationDialog($scope, "Are you sure you want to remove this message from the schedule?",
        function() {
          // determine date of event
          var day0 = new Date($scope.weekList[$scope.currentWeek].start.timestamp * 1000);
          day0.setDate(day0.getDate() + data.day);
          day0.setHours(0,0,0,0);
          var date = day0.getTime() / 1000;

          //scope.slots.splice(scope.slots.indexOf(scope.model), 1);
          var eventDetails;
          for(var i=0; i<$scope.events.length; i++) {
            if ($scope.events[i].itemid == data.itemid) {
              eventDetails = $scope.events[i];
              break;
            }
          }
          if (!eventDetails.repeatType || eventDetails.repeatType == 'none') {
            delete eventDetails;
          }
          else {
            if (!eventDetails.exceptions[date]) {
              eventDetails.exceptions[date] = {};
            }
            eventDetails.exceptions[date].deletion = {
              date: date,
              day: data.day,
              startTime: data.startTime,
              action: 'delete',
            };
          }
          updateData();
        }
      );
    }

    function openCreateMessageScheduleSummaryModal(messageSchedule) {
      return $modal
        .open({
          templateUrl: 'partials/create_message_schedule_summary_modal.html',
          windowClass: 'create-message-schedule-summary-modal',
          controller: ['$modalInstance', 'api', 'me', 'messageSchedule',
            function ($modalInstance, api, me, messageSchedule) {
              var vm = this;

              // Properties
              vm.messageSchedule = messageSchedule;

              // Methods
              vm.activateMessageSchedule = activateMessageSchedule;
              vm.skipMessageScheduleActivation = skipMessageScheduleActivation;

              function activateMessageSchedule(playWhen) {
                api.selectMessageSchedule(messageSchedule.scheduleId, function(result) {
                  me.schedule_id = messageSchedule.scheduleId;
                  $modalInstance.close(true);
                }, function(err) {
                  console.error("Could not select the message schedule.", err);
                  $modalInstance.close(false);
                });
              }

              function skipMessageScheduleActivation() {
                $modalInstance.dismiss('cancel');
              }
            }
          ],
          controllerAs: 'vm',
          resolve: {
            me: function () {
              return api.getMe();
            },
            messageSchedule: function () {
              return messageSchedule;
            }
          }
        })
        .result;
    }

    $scope.submit = function() {
      if ($scope.has_permission) {
        var hasNotAddedMinScheduleItems = messageScheduleDetails.schedule.scheduleitems.length === 0;
        if (!vm.formController.$valid || hasNotAddedMinScheduleItems) {
          if (hasNotAddedMinScheduleItems) {
            $scope.showError('You must add at least one message to your Message Schedule');
          } else if ($scope.formData.name.length < 4) {
            $scope.showError('Please supply a schedule name greater than 4 characters');
          }

          return;
        }

        if (!$scope.entStatus.isEnterprise) {
          $scope.formData.isGlobal = 0;
        }
        messageScheduleDetails.schedule.isGlobal = $scope.formData.isGlobal;

        dataCacher.setData($scope.formData);
        messageScheduleDetails.schedule.name = $scope.formData.name;
        $scope.formData.type = 'messageSchedule';

        vm.isSaving = true;
        if (!scheduleId) {
          api.postMessageSchedule(messageScheduleDetails.schedule.name, function(result) {
            $scope.isEdited = false;
            $scope.isSaved = true;
            if (result.scheduleid) {
              scheduleId = result.scheduleid;
              messageSelection.loadSchedules();
            }
            else {
              console.error('Failed to create message schedule. No ID returned.',err);
              $scope.showError("Failed to create message schedule.");
            }
            api.putMessageSchedule(scheduleId, messageScheduleDetails.schedule, function(result) {
              initializeData();
              $rootScope.confirmLocationSwitch = null;
              messageScheduleDetails.schedule.scheduleId = scheduleId;
              vm.isSaving = false;
              if ($scope.canAutoselect) {
                openCreateMessageScheduleSummaryModal($scope.formData)
                  .then(
                    function (result) {
                      if (result === true) {
                        $scope.showSuccess('<b>"' + messageScheduleDetails.schedule.name + '"</b> has been saved and is now your selected Message Schedule');
                      } else {
                        $scope.showError("Failed to activate your new message schedule.");
                      }
                      $state.go('account.admin.messageschedules');
                    }, function () {
                      $state.go('account.admin.messageschedules');
                    }
                  )
                  .catch(angular.noop);
              } else {
                $scope.showSuccess('<b>"' + messageScheduleDetails.schedule.name + '"</b> has been saved');
                $state.go('account.admin.messageschedules');
              }
            }, function(err) {
              console.error('Failed to update message schedule.',err);
              $scope.showError("Failed to update message schedule.");
              vm.isSaving = false;
            });
          }, function(err) {
            console.error('Failed to create message schedule.',err);
            $scope.showError("Failed to create message schedule.");
            vm.isSaving = false;
          });
        } else {
          api.putMessageSchedule(scheduleId, messageScheduleDetails.schedule, function(result) {
            initializeData();
            $scope.isEdited = false;
            $scope.isSaved = true;

            api.getMessageScheduleDetails(scheduleId)
              .then(function(scheduleUpdate) {
                messageScheduleDetails = scheduleUpdate;
                scheduleItems = messageScheduleDetails.schedule.scheduleitems;
                updateData(true);
                $rootScope.confirmLocationSwitch = null;
                $scope.showSuccess('<b>"' + messageScheduleDetails.schedule.name + '"</b> has been saved');
                $state.go('account.admin.messageschedules');

                vm.isSaving = false;
              })
              .catch(function(err) {
                console.error("Error fetching schedule updates.", err);
                vm.isSaving = false;
              });
          }, function(err) {
            console.error('Failed to update message schedule.',err);
            $scope.showError("Failed to update message schedule.");
            vm.isSaving = false;
          });
        }
      }
    };

  }
]);

app.filter('filterUsedPlaylist', function() {
  return function(playlists, usedPlaylistIds) {
    var results = [];
    if (!usedPlaylistIds || usedPlaylistIds.length === 0) return playlists;
    for (var i=0; i<playlists.length; i++) {
      if (usedPlaylistIds.indexOf(playlists[i].playlistid) === -1) {
        results.push(playlists[i]);
      }
    }
    return results;
  }
});

app.filter('filterAdminPlaylist', function() {
  return function(playlists, query) {
    var results = [];
    if (!query || query.length < 1) return playlists;
    for (var i=0; i<playlists.length; i++) {
      if (playlists[i].name.toLowerCase().indexOf(query.toLowerCase()) != -1) {
        results.push(playlists[i]);
      }
    }
    return results;
  }
});
app.filter('filterAdminPlaylist2', function() {
  return function(playlists, filter) {
    var results = [];
    if ((!filter.query || filter.query.length < 1) && (!filter.selectedPlaylists || filter.selectedPlaylists.length < 1)) {
      return playlists;
    }
    for (var i=0; i<playlists.length; i++) {
      if (filter.selectedPlaylists.length > 0) {
        if (filter.selectedPlaylists.indexOf(playlists[i].playlistid) === -1) {
          if (filter.query && filter.query.length > 0) {
            if (playlists[i].name.toLowerCase().indexOf(filter.query.toLowerCase()) != -1) {
              results.push(playlists[i]);
            }
          } else {
            results.push(playlists[i]);
          }
        }
      } else if (filter.query && filter.query.length > 0) {
        if (playlists[i].name.toLowerCase().indexOf(filter.query.toLowerCase()) != -1) {
          results.push(playlists[i]);
        }
      }
    }
    return results;
  }
});

app.controller('EditDaypartCtrl', ['$scope', '$state', '$modal', 'confirmationDialog', 'api', 'me', 'playlists', 'preset', '$rootScope', 'subscription', 'daypartUpdateModal', 'editDaypartService', 'musicSelection', 'userInfo', 'subscriptionInfo', 'formEditService', 'dataCacher', 'daypartToolbarService',
  function($scope, $state, $modal, confirmationDialog, api, me, playlists, preset, $rootScope, subscription, daypartUpdateModal, editDaypartService, musicSelection, userInfo, subscriptionInfo, formEditService, dataCacher, daypartToolbarService) {
    var vm = this;
    var locationChangeMessage = '';
    var isUserLimitedToCompanySelections = null;

    $scope.$parent.hideLoader();
    $scope.$parent.currentTab = 'dayparting';
    if (preset) {
      $scope.isEditing = true;
      $scope.$parent.topTitle = 'Editing Dayparting Preset';
      $scope.formData = preset;
      var cachedData = dataCacher.getData();
      if (cachedData && cachedData.type === 'daypart') {
        $scope.formData.autoselect = cachedData.autoselect;
        $scope.isSaved = true;
        dataCacher.clearData();
      } else {
        $scope.isSaved = false;
        $scope.formData.autoselect = 0;
      }
      $scope.formData.userid = me.user.userid;
      locationChangeMessage = 'Your changes for "' + $scope.formData.name + '" have not been saved. Do you wish to proceed?';
    } else {
      $scope.isEditing = false;
      $scope.isSaved = false;
      $scope.$parent.topTitle = 'Creating Dayparting Preset';
      $scope.formData = {
        userid: me.user.userid,
        name: '',
        playlists: {},
        isGlobal: 0,
        autoselect: 0
      };
    }
    daypartToolbarService.setRatingsMap(createRatingsMap());

    $scope.subscription = subscription;
    $scope.dow = editDaypartService.dow;
    $scope.timezones = window.timeZones;
    $scope.isEdited = false;
    $scope.isSaving = false;

    var initFormData;
    userInfo.getUserTimezone(false, function(data) {
      $scope.formData.timezone = data;
      // wait until timezone retrieved before storing initial form data
      initFormData = angular.copy($scope.formData);
    });
    $scope.canAutoselect = null;
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.slots = [];
    $scope.copyFrom = 0;
    $scope.allowSetGlobal = $scope.entStatus.isEnterprise && (me.permissions.account.owner || me.permissions.account.music);

    $scope.showMusic = false;
    $scope.showMix = false;

    var dataContainer = null;
    var scrollWidth = 0;
    var scrollLeft = 0;
    $scope.daypartZoom = 0;

    $scope.changeForm = function() {
      $scope.isSaved = false;
      $scope.isEdited = formEditService.checkEdited(initFormData, $scope.formData, locationChangeMessage);
    };

    $scope.$watch('slots', function(newValue, oldValue) {
      // ignore first watch since slots gets timeLabel added later
      if (oldValue[0] && oldValue[0].timeLabel && newValue !== oldValue) {
        $scope.isSaved = false;
        $scope.isEdited = formEditService.checkEdited(oldValue, newValue);
      }
    }, true);

    $scope.zoomIn = function() {
      scrollLeft = dataContainer.scrollLeft * 2 + (dataContainer.clientWidth / 2);
      if ($scope.daypartZoom < 3) {
        $scope.daypartZoom++;
        setDataAreaSize();
      }
    }
    $scope.zoomOut = function() {
      if ($scope.daypartZoom > 0) {
        $scope.daypartZoom--;
        setDataAreaSize();
        scrollLeft = dataContainer.scrollLeft / 2 - (dataContainer.clientWidth / 4);
      }
    }
    var setDataAreaSize = function() {
      $scope.dataAreaSize = 'zoom'+$scope.daypartZoom;
    }
    setDataAreaSize();

    $scope.$on('daypart-container-loaded', function(event,container) {
      dataContainer = container;
      scrollWidth = container.scrollWidth;
    });

    $scope.$watch(function() {
      if (dataContainer) {
        return scrollWidth != dataContainer.scrollWidth
      }
    }, function() {
      if (dataContainer) {
        if (scrollWidth > 0) {
          scrollWidth = dataContainer.scrollWidth;
          dataContainer.scrollLeft = scrollLeft;
        } else {
          scrollWidth = dataContainer.scrollWidth;
        }
      }
    });

    var showModal = function(publicStationList, mixStationList) {
      daypartUpdateModal.setOptions({
        headerText: 'Create Daypart',
        stationList: publicStationList,
        mixStationList: mixStationList,
      });
      daypartUpdateModal.setModel({
        station: '',
        mixstation: '',
        startTime: '',
        endTime: ''
      });
    }

    $scope.copyDay = function(index) {
      $rootScope.confirmLocationSwitch = 'Are you sure? Any changes made to "' + $scope.formData.name + '" will not be saved.';
      $rootScope.confirmationmodel = $scope.confirmationmodel;
      var slots = editDaypartService.getDaysSlots(index, $scope.slots);
      if (slots.length === 0) {
        return $scope.showError('Please select at least one music station');
      } else {
        confirmationDialog({buttonText: 'Yes'},
          'Are you sure? This will override the settings for every other day of the week.',
          function() {
            $scope.slots = editDaypartService.copyDay(slots);
            $scope.safeApply();
          }
        );
      }
    }

    userInfo.getUserPerms(function (permissions) {
      userInfo.isUserLimitedToCompanySelections()
        .then(function (isUserLimited) {
          isUserLimitedToCompanySelections = isUserLimited;
          $scope.canAutoselect = permissions.canPlayMusic && permissions.canSelectMusic && !isUserLimited;
        });
    });

    if (api.userObject.has_company_stations && !api.userObject.permissions.account.owner && !api.userObject.permissions.admin.superadmin && !api.userObject.permissions.admin.music) {
      $scope.playlists = (playlists['companyStations']['public']) ? playlists['companyStations']['public'] : [];
      $scope.mixes = (playlists['companyStations']['mix']) ? playlists['companyStations']['mix'] : [];
    } else {
      $scope.playlists = playlists['public'];
      $scope.mixes = playlists['mix'];
    }

    $scope.playlists.forEach(function (playlist) {
      playlist.ratingList = [playlist.content_rating_id];
    })
    $scope.mixes.forEach(function (mix) {
      mix.ratingList = JSON.parse(mix.content_ratings);
    })

    var modalPublicStationList = editDaypartService.getModalStationList($scope.playlists);
    var modalMixStationList = editDaypartService.getModalStationList($scope.mixes);

    showModal(modalPublicStationList, modalMixStationList);

    // Add existing slots
    for (var key in $scope.formData.playlists) {
      for (var i=0; i<$scope.formData.playlists[key].length; i++) {
        $scope.slots.push(editDaypartService.mapToSlot(key, $scope.formData.playlists[key][i],$scope.dow));
      }
    }

    $scope.copyDay = function(index) {
      $rootScope.confirmLocationSwitch = 'Are you sure? Any changes made to "' + $scope.formData.name + '" will not be saved.';
      $rootScope.confirmationmodel = $scope.confirmationmodel;
      var slots = editDaypartService.getDaysSlots(index, $scope.slots);
      if (slots.length === 0) {
        return $scope.showError('Please select at least one music station');
      } else {
        confirmationDialog({buttonText: 'Yes'},
          'Are you sure? This will override the settings for every other day of the week.',
          function() {
            $scope.slots = editDaypartService.copyDay(slots);
            $scope.safeApply();
          }
        )
        .catch(angular.noop);
      }
    }

    $scope.clickBackButton = function() {
      formEditService.confirmRouteNavigation($scope, $scope.isEdited, 'account.admin.dayparting', locationChangeMessage);
    };

    function openCreateDaypartSummaryModal(daypart, isUserLimitedToCompanySelections) {
      return $modal
        .open({
          templateUrl: 'partials/create_daypart_summary_modal.html',
          windowClass: 'create-daypart-summary-modal',
          controller: ['$modalInstance', 'isUserLimitedToCompanySelections', 'me', 'daypart', 'musicSelection',
            function ($modalInstance, isUserLimitedToCompanySelections, me, daypart, musicSelection) {
              var vm = this;

              // Properties
              vm.daypart = daypart;
              vm.isUserLimitedToCompanySelections = isUserLimitedToCompanySelections;

              // Methods
              vm.activateDaypart = activateDaypart;
              vm.skipDaypartActivation = skipDaypartActivation;

              function activateDaypart(playWhen) {
                musicSelection.setSelection('dayparting', daypart.daypartingid, daypart.name, playWhen,
                  function () {
                    me.music_type = 'dayparting';
                    me.music_id = daypart.daypartingid;
                  }
                );

                $modalInstance.close();
              }

              function skipDaypartActivation() {
                $modalInstance.dismiss();
              }
            }
          ],
          controllerAs: 'vm',
          resolve: {
            isUserLimitedToCompanySelections: function () {
              return isUserLimitedToCompanySelections;
            },
            me: function () {
              return api.getMe();
            },
            daypart: function () {
              return daypart;
            }
          }
        })
        .result;
    }

    $scope.onMobileFormSubmission = function () {
      if (!vm.formController.$valid) {
        angular.element('html, body').animate({ scrollTop: 0 }, 500);
      }
    };

    $scope.submit = function() {
      if (!vm.formController.$valid) {
        return;
      }

      var daypartFlag = true;
      $scope.formData.playlists = editDaypartService.mapSlotsToPlaylist($scope.slots, $scope.dow);
      $.each($scope.formData.playlists, function(index, value) {
        if (value.length !== 0) {
          daypartFlag = false;
        }
      });

      if (daypartFlag) {
        return $scope.showError('Please add at least one music station');
      }

      if (!$scope.entStatus.isEnterprise) $scope.formData.isGlobal = 0;

      api.editUser($scope.formData, function() {
        $scope.$emit('refreshAccountInfo');
      },function(err){
        $scope.showError('We were unable to set the timezone');
        console.error('Unable to set timezone',err);
      });

      vm.isSaving = true;
      if (preset) {
        api.editDayparting($scope.formData, function(result) {
          initFormData = angular.copy($scope.formData);
          $scope.isSaved = true;
          $scope.isEdited = false;
          if (result.error) {
            return $scope.showError(result.error);
          } else {
            $rootScope.confirmLocationSwitch = false;
            if (!$scope.formData.autoselect) {
              api.getMusic(true);
              $scope.showSuccess( '<b>"' + $scope.formData.name + '"</b> has been saved');
              $state.go('account.admin.dayparting');
            } else {
              musicSelection.setSelection('dayparting', $scope.formData.daypartingid, $scope.formData.name, 'next', function() {
                $scope.me.music_type = 'dayparting';
                $scope.me.music_id = $scope.formData.daypartingid;
                api.getMusic(true);
                $scope.showSuccess('<b>"' + $scope.formData.name + '"</b> has been saved and is now your selected Daypart');
                $state.go('account.admin.dayparting');
              });
            }
          }

          vm.isSaving = false;
        }, function(err) {
          console.error('Error editing daypart: ', err);

          var message = err.message
            ? err.message
            : 'There was an error updating this Daypart.';
          $scope.showError(message);

          $rootScope.confirmLocationSwitch = false;
          vm.isSaving = false;
        });
      } else {
        api.createDayparting($scope.formData, function(result) {
          if (result.error) {
            return $scope.showError(result.error);
          } else {
            $scope.isEdited = false;
            $scope.isSaved = true;
            $rootScope.confirmLocationSwitch = false;
            $scope.formData.type = 'daypart';
            $scope.formData.daypartingid = result.daypartingid;
            dataCacher.setData($scope.formData);
            if ($scope.canAutoselect || isUserLimitedToCompanySelections) {
              openCreateDaypartSummaryModal($scope.formData, isUserLimitedToCompanySelections)
                .catch(angular.noop)
                .finally(function () {
                  $state.go('account.admin.dayparting');
                });
            } else {
              $scope.showSuccess( '<b>"' + $scope.formData.name + '"</b> has been saved');
              $state.go('account.admin.dayparting');
            }
            api.getMusic(true);
          }

          vm.isSaving = false;
        }, function (err) {
          console.error('Error creating new daypart: ', err);

          var message = err.message
            ? err.message
            : 'There was an error creating this Daypart.';
          $scope.showError(message);

          vm.isSaving = false;
        });
      }
    }


    // create ratings map mappint playlist id to content ratings
    function createRatingsMap() {
      var ratingsMap = {};
      playlists.public.forEach(function (playlist) {
        ratingsMap[playlist.musicid] = [playlist.content_rating_id];
      })
      playlists.mix.forEach(function (mix) {
        ratingsMap[mix.musicid] = JSON.parse(mix.content_ratings);
      })
      return ratingsMap;
    }
  }
]);

app.controller('AdminPlaylistsCtrl', ['$scope', 'confirmationDialog', 'api', 'mixes', 'subscription', 'me', 'userPerms', 'subscriptionInfo',
  function($scope, confirmationDialog, api, mixes, subscription, me, userPerms, subscriptionInfo) {
    $scope.$parent.currentTab = 'playlists';
    $scope.$parent.hideLoader();
    $scope.$parent.topTitle = 'Music';
    $scope.subscription = subscription;
    $scope.me = me;
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.userPerms = userPerms;

    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'name';
    $scope.reverse = false;
    setupMixes(mixes);

    $scope.order = function (orderBy) {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
      $scope.orderBy = orderBy;
      $scope.sortDirection = ($scope.reverse) ? 'down' : 'up';
      $scope.mixes = customSort($scope.mixes);
    };

    $scope.searchMixes = function() {
      $scope.mixes = customSort(mixes.mix);
    }

    var customMixSearch = function(mixes) {
      var results = [];
      if ($scope.query && $scope.query.length > 0) {
        for (var i=0; i<mixes.length; i++) {
          if ((mixes[i].name && mixes[i].name.toLowerCase().indexOf($scope.query.toLowerCase()) !== -1) ||
              (mixes[i].username && mixes[i].username.toLowerCase().indexOf($scope.query.toLowerCase()) !== -1)) {
            results.push(mixes[i]);
          }
        }
      } else {
        return mixes;
      }
      return results;
    }

    var customSort = function (mixes) {
      var result = [];
      mixes = customMixSearch(mixes);
      if ($scope.reverse) {
        result = mixes.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? -1 : x < y ? 1 : 0;
        });
        return result;
      }
      else {
        result = mixes.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? 1 : x < y ? -1 : 0;
        });
        return result;
      }
    };

    $scope.getMixPage = function(page) {
      api.getMixPlaylists(page).then(function(result) {
        setupMixes(result);
      });
    };

    $scope.removeMix = function(mix) {

      if (($scope.me.music_type === 'mix' && $scope.me.music_id === mix.mixid) || mix.isActive) {
        return $scope.showError('You cannot delete the Mix Station: ' + mix.name + ', because it is currently in use. Make sure it is not assigned to any zones or used in any Dayparts, then try again.');
      }

      confirmationDialog({buttonText: 'Yes'},
        'Are you sure you want to delete the Mix Station: ' + mix.name + '?',
        function() {
          api.removeMixPlaylist(mix.mixid, function(resp) {
            if (resp.error) {
              $scope.showError(resp.error);
            } else {
              $scope.showSuccess( 'Your Mix Station <b>"' + mix.name + '"</b> has been removed');
              api.getMusic(true);
              $scope.getMixPage($scope.mixPage);
            }
          },function(err) {
            console.error("Error occured in removeMix when called admin_music",err);
            return $scope.showError("Unable to delete the Mix Station");
          })
        }
      ).catch(angular.noop);
    }

    function setupMixes (mixes) {
      mixes.mix.forEach(function (mix) {
        mix.ratingList = JSON.parse(mix.content_ratings);
      });

      if (api.userObject.has_company_stations && !api.userObject.permissions.account.owner && !api.userObject.permissions.admin.superadmin && !api.userObject.permissions.admin.music) {
        $scope.mixes = mixes.mix;
      }
      else {
        $scope.mixes = mixes.mix.filter(function(item) {
          if (
            item.isGlobal                  ||
            $scope.userPerms.isMusicAdmin  ||
            item.userid === $scope.me.user.userid ||
            $scope.me.music_type === 'mix' && $scope.me.music_id === item.mixid
          ) {
            return true;
          }
        });
      }
      $scope.mixPage = mixes.meta.page;
      $scope.mixTotal = mixes.meta.total;
      $scope.mixLimit = mixes.meta.limit;
    }
  }
]);

app.controller('AdminDaypartingCtrl', ['$scope', 'confirmationDialog', 'api', 'dayparting', 'subscription', 'userPerms', 'me', 'subscriptionInfo',
  function($scope, confirmationDialog, api, dayparting, subscription, userPerms, me, subscriptionInfo) {
    $scope.subscription = subscription;
    $scope.$parent.currentTab = 'dayparting';
    $scope.me = me;
    $scope.userPerms = userPerms;
    $scope.$parent.topTitle = 'Music';
    $scope.$parent.hideLoader();
    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'name';
    $scope.reverse = false;
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    setupDayparts(dayparting);

    $scope.order = function (orderBy) {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
      $scope.orderBy = orderBy;
      $scope.sortDirection = ($scope.reverse) ? 'down' : 'up';
      $scope.presets = customSort($scope.presets);
    };

    $scope.search = function() {
      $scope.presets = customSort(dayparting.dayparting);
    }

    var customSearch = function (data) {
      var results = [];
      if ($scope.query && $scope.query.length > 0) {
        for (var i=0; i<data.length; i++) {
          if ((data[i].name && data[i].name.toLowerCase().indexOf($scope.query.toLowerCase()) !== -1) ||
              (data[i].username && data[i].username.toLowerCase().indexOf($scope.query.toLowerCase()) !== -1)) {
            results.push(data[i]);
          }
        }
      } else {
        return data;
      }
      return results;
    };

    var customSort = function (data) {
      var result = [];
      data = customSearch(data);
      if ($scope.reverse) {
        result = data.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? -1 : x < y ? 1 : 0;
        });
        return result;
      }
      else {
        result = data.sort(function (a, b) {
          var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
              y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
          return x > y ? 1 : x < y ? -1 : 0;
        });
        return result;
      }
    };

    $scope.getDaypartingPage = function(page) {
      api.getDayPartingPresets(page).then(function(result) {
        setupDayparts(result);
      });
    };

    $scope.removeDayparting = function(preset) {
      if (($scope.me.music_type === 'dayparting' && $scope.me.music_id === preset.daypartingid) || preset.isActive) {
        return $scope.showError('You cannot delete the Daypart: ' + preset.name + ', because it is currently in use.');
      }

      confirmationDialog({buttonText: 'Yes'},
        'Are you sure you want to delete the Daypart: ' + preset.name + '?',
        function() {
          api.removeDayparting(preset.daypartingid, function(resp) {
            if (resp.error) {
              return $scope.showError(resp.error);
            } else {
              $scope.showSuccess( 'Your Dayparting <b>"' + preset.name + '"</b> has been removed');
              api.getMusic(true);
              $scope.getDaypartingPage($scope.DaypartingPage);
            }
          },function(err) {
            console.error("Error occured in removeDayparting when called in admin music",err);
            return $scope.showError("Unable to delete the Daypart");
          })
        }
      );
    }

    function setupDayparts(dayparting) {
      if (api.userObject.has_company_stations && !api.userObject.permissions.account.owner && !api.userObject.permissions.admin.superadmin && !api.userObject.permissions.admin.music) {
        $scope.presets = dayparting.dayparting;
      }
      else {
        $scope.presets = dayparting.dayparting.filter(function(item) {
          if (
            item.isGlobal                  ||
            $scope.userPerms.isMusicAdmin  ||
            item.userid === $scope.me.user.userid ||
            $scope.me.music_type === 'dayparting' && $scope.me.music_id === item.daypartingid
          ) {
            return true;
          }
        });
      }
      $scope.DaypartingPage = dayparting.meta.page;
      $scope.DaypartingTotal = dayparting.meta.total;
      $scope.DaypartingLimit = dayparting.meta.limit;
    }
  }
]);

app.controller('AdminDownvotesCtrl', ['$scope', 'api', 'removed', 'subscription', 'subscriptionInfo',
  function($scope, api, removed, subscription, subscriptionInfo) {
    $scope.subscription = subscription;
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();

    $scope.pageSize = 50;
    $scope.query = '';
    $scope.search = function () {
      return function (item) {
        return $scope.query === ''
          || (item.username && item.username.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.name && item.name.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.reason && item.reason.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.artist_name && item.artist_name.toLowerCase().indexOf($scope.query.toLowerCase()) > -1);
      };
    };

    $scope.$parent.currentTab = 'downvote';

    $scope.removed = removed.media;
    $scope.removed.forEach(function(item) {
      item.thumbUrl = item.thumbUrl.replace('http:', 'https:');
    });

    $scope.$parent.hideLoader();

    $scope.restore = function(song, i) {
      api.restoreRemoved(song, function() {
        $scope.removed.splice(i, 1);
        $scope.showSuccess('This song is now restored!');
      }, function() {
        $scope.showError('There was a problem restoring this song.');
      });
    };

    $scope.applyToAccount = function(i, song) {
      api.removedApplyToAccount($scope.removed[i].removeid, $scope.removed[i].mediaid, function() {
        song.isGlobal = true;
      }, function() {
        $scope.showWarning('There was a problem removing this song for all your locations.');
      });
    };

  }
]);

app.controller('AdminPrefetchCtrl', AdminPrefetchCtrl);

AdminPrefetchCtrl.$inject = ['$modal', '$scope', 'api', 'apiTimeDataUtility', 'userPerms', 'me', '$location', 'networkConstraints', 'networkConstraintsService', 'deviceCommand'];

function AdminPrefetchCtrl($modal, $scope, api, apiTimeDataUtility, userPerms, me, $location, networkConstraints, networkConstraintsService, deviceCommand) {
  $scope.$parent.currentTab = 'prefetch';
  if (!userPerms.isAccountOwner) {
    return true;
  }
  $scope.locations = {};
  $scope.pageSize = 50;
  $scope.form = { query: '' };
  $scope.orderBy = 'username';
  $scope.prefetch = {
    downloadWindow: {
      startTime: undefined,
      stopTime: undefined,
      isStopTimeInNextDay: undefined
    },
    enabled: networkConstraintsService.isPrefetchEnabled(),
    saving: false
  };
  $scope.account = me.account;
  $scope.dataready = false;

  init();

  function init() {
    updateMediaDownloadWindow();
  }

  $scope.openMediaDownloadWindowModal = function () {
    if (!$scope.prefetch.enabled) {
      return;
    }

    $modal
      .open({
        templateUrl: 'partials/media_download_window_edit_modal.html',
        windowClass: 'media-download-window-edit',
        controller: 'MediaDownloadWindowEditModal',
        controllerAs: 'vm',
        resolve: {
          networkConstraints: function () {
            return networkConstraints;
          }
        }
      })
      .result
      .then(function (result) {
        var promise;
        var updatedNetworkConstraints = angular.copy(networkConstraints);

        $scope.prefetch.saving = true;

        if (result.deleteWindow) {
          updatedNetworkConstraints.downloadStartTime = null;
          updatedNetworkConstraints.downloadStopTime = null;

          promise = networkConstraintsService.deleteDownloadWindow();
        } else {
          updatedNetworkConstraints.downloadStartTime = result.downloadStartTime;
          updatedNetworkConstraints.downloadStopTime = result.downloadStopTime;

          promise = networkConstraintsService.updateNetworkConstraints(updatedNetworkConstraints);
        }

        promise
          .then(function () {
            networkConstraints = updatedNetworkConstraints;
            updateMediaDownloadWindow();
          })
          .catch(function (err) {
            // TODO: Handle error
          })
          .finally(function () {
            $scope.prefetch.saving = false;
          });
      })
      .catch(angular.noop);
  };

  $scope.order = function (orderBy) {
    $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
    $scope.orderBy = orderBy;
    $scope.locations = customSort($scope.locations);
  };

  function customSort(locations) {
    var result = [];
    if ($scope.reverse) {
      result = locations.sort(function (a, b) {
        var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
            y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
        return x > y ? -1 : x < y ? 1 : 0;
      });
      return result;
    } else {
      result = locations.sort(function (a, b) {
        var x = (a[$scope.orderBy]) ? a[$scope.orderBy].toString().toLowerCase() : '',
            y = (b[$scope.orderBy]) ? b[$scope.orderBy].toString().toLowerCase() : '';
        return x > y ? 1 : x < y ? -1 : 0;
      });
      return result;
    }
  }

  $scope.search = function () {
    var query = $scope.form.query.toLowerCase();
    return function (item) {
      return query == ''
        || (item.username && item.username.toLowerCase().indexOf(query) > -1);
    }
  }

  function updateMediaDownloadWindow() {
    var downloadWindow = $scope.prefetch.downloadWindow;

    if (!networkConstraints || !networkConstraints.downloadStartTime || !networkConstraints.downloadStopTime) {
      downloadWindow.startTime = null;
      downloadWindow.stopTime = null;
      downloadWindow.isStopTimeInNextDay = false;
    } else {
      downloadWindow.startTime = apiTimeDataUtility.convertApiTimeToDate(networkConstraints.downloadStartTime);
      downloadWindow.stopTime = apiTimeDataUtility.convertApiTimeToDate(networkConstraints.downloadStopTime);
      downloadWindow.isStopTimeInNextDay = downloadWindow.stopTime < downloadWindow.startTime;
    }
  }

  $scope.saveLocationDefault = function() {
    var params = { skipBilling: 1, default_prefetch: $scope.account.default_prefetch };
    api.editAccount($scope.account.custid, params, function(results) {
      // Nothing to see here...
    }, function(err) {
      $scope.showError('Could not save setting');
      console.error(err);
    });
  }

  $scope.toggleLocationOverride = function(user) {
    user.isPrefetch = (user.isPrefetch) ? 0 : 1;
    var params = { userid: user.userid, isPrefetch: user.isPrefetch };
    api.editUser(params, function(results) {
      // If any of the user's streams have a CloudBox assigned, send the command to fetch its schedule.
      // Pre-6.x apks will ignore it, and hopefully there won't be many of them left soon.
      $scope.streams.forEach(function(s) {
        if (s.userid === user.userid && s.devicetype === 'cloudbox') {
          var device = {
            deviceid: s.deviceid,
            userid: s.userid,
            custid: s.custid,
            type: s.devicetype
          };
          deviceCommand.updateSchedule(device, function(message) {
            // Not going to bother with the success message.
            if (message.errMessage) $scope.showError(message.errMessage);
          });
        }
      });
    }, function(err) {
      $scope.showError('Could not save setting');
      console.error(err);
    });
  }

  api.getUsers(1, function(results) {
    api.getStreamsForAccount(function(str) {
      $scope.locations = results.users;
      $scope.streams = str.streams;
      $scope.dataready = true;
      $scope.order($scope.orderBy);
    }, function(err) {
      $scope.showError('Failed to get zones');
    });
  }, function(err) {
    $scope.showError('Failed to get locations');
  });

}

app.controller('AdminStreamsCtrl', AdminStreamsCtrl);

AdminStreamsCtrl.$inject = ['$modal', '$scope', '$window', 'api', 'me', 'subscription', 'subscriptionInfo', '$timeout', 'deviceCommand', 'refresher', 'streamModal', 'streamHistoryModal', 'autoLoginUrlModal', 'confirmationDialog', 'streamUpdateService', 'initialData', 'userPerms', 'playerService', 'intercom', 'awsService', 'userNotificationService', 'refreshCloudBoxModal'];

function AdminStreamsCtrl($modal, $scope, $window, api, me, subscription, subscriptionInfo, $timeout, deviceCommand, refresher, streamModal, streamHistoryModal, autoLoginUrlModal, confirmationDialog, streamUpdateService, initialData, userPerms, playerService, intercom, awsService, userNotificationService, refreshCloudBoxModal) {

  // Parent controller
  $scope.$parent.hideLoader();
  $scope.$parent.currentTab = 'zones';

  // Properties
  $scope.dataReady = true;
  $scope.me = me;
  var groups = initialData.groups;
  var messagePresets = initialData.messagePresets;
  var messageSchedules = initialData.messageSchedules;
  var music = initialData.music;
  var streamsPollRate = initialData.streams.streamsPollRate;
  $scope.groups = initialData.groups;
  $scope.streams = initialData.streams.streams; // enhanced stream data for all streams in the account
  $scope.devices = initialData.streams.devices;
  $scope.songs = initialData.streams.songs;
  $scope.userPerms = userPerms;
  $scope.subscription = subscription;
  $scope.showMessages = $scope.$parent.showMessages;
  $scope.selectingGroup = false;
  $scope.selectingMusic = false;
  $scope.selectedStreams = [];
  $scope.selectedPreset = -2;
  $scope.selectedGroup = -1;
  $scope.selectedStation = -2;
  $scope.selectedCommand = -1;
  $scope.toggleAllSelected = false;
  $scope.query = '';
  $scope.orderBy = 'username';
  $scope.orderBy2 = 'streamname';
  $scope.orderBy3 = '';
  $scope.reverse = false;
  $scope.availableOptions = [];
  $scope.messagePresets = [];
  $scope.messageSchedules = [];
  $scope.selectedButton = '';
  $scope.inTrial = subscriptionInfo.inTrial();
  $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
  $scope.zonesAllowed = subscriptionInfo.zonesAllowed();
  $scope.messageQuantityAllowedPerPreset = subscriptionInfo.messageQuantityAllowedPerPreset();
  $scope.pageSize = 50;
  $scope.currentPage = 1;
  var allMusic, selectGroup1, selectMusic1, selectPreset1, selectSchedule1;
  var groupsById = {};
  var skipLimit = 6;
  var skipTracker = [];
  var editStreamid = null;
  var refreshSongsTimer;

  $scope.search = function () {
    var query = $scope.query.toLowerCase();
    return function (item) {
      return $scope.query == ''
        || (item.username && item.username.toLowerCase().indexOf(query) > -1)
        || (item.streamname && item.streamname.toLowerCase().indexOf(query) > -1)
        || (item.songInfo && item.songInfo.name && item.songInfo.name.toLowerCase().indexOf(query) > -1)
        || (item.songInfo && item.songInfo.artist && item.songInfo.artist.toLowerCase().indexOf(query) > -1)
        || (item.musicInfo && item.musicInfo.name && item.musicInfo.name.toLowerCase().indexOf(query) > -1)
        || (item.groupname && item.groupname.toLowerCase().indexOf(query) > -1)
        || (item.messagePreset && item.messagePreset.name && item.messagePreset.name.toLowerCase().indexOf(query) > -1)
        || (item.messagePreset && item.messagePreset.messages && item.messagePreset.messages.toLowerCase().indexOf(query) > -1)
        || (item.messageSchedule && item.messageSchedule.name && item.messageSchedule.name.toLowerCase().indexOf(query) > -1)
        || (item.deviceName && item.deviceName.toLowerCase().indexOf(query) > -1);
    };
  };

  $scope.tooltipText = function(tooltip, stream) {
    var text = '';
    if (tooltip) {
      text = tooltip;
    }
    if (!$scope.zonesAllowed) {
      if (tooltip === 'Add Zone') {
        text = "* Upgrade plan to add zones";
      } else if (!$scope.entStatus.isEnterprise && stream.userid !== $scope.me.user.userid) {
        text = "* Upgrade plan to use this feature";
      }
    }
    return text;
  };

  var initSelectButtons = function() {
    selectGroup1 = $(".selectGroup1 > select").select2({placeholder: 'Regions'});
    selectMusic1 = $(".selectMusic1 > select").select2({placeholder: 'Music'});
    selectPreset1 = $(".selectPreset1 > select").select2({placeholder: 'Message Presets'});
    selectSchedule1 = $(".selectSchedule1 > select").select2({placeholder: 'Message Schedules'});

    $('.select2 > select').on('select2:open', function(evt) {
      $(".select2-dropdown").css({'width': '250px', 'min-width': '250px'});
    });

    selectGroup1.on('select2:closing', function(e) {
      api.getGroups(function(result) {
        filterGroups(result.groups);
      }, function(err) {
        console.error('Error getting groups on select2 close');
      });
    });

    selectSchedule1.on('select2:closing', function(e) {
      api.getMessageSchedules().then(function(result) {
        filterMessageSchedules(result.schedules);
      });
    });

    selectPreset1.on('select2:closing', function(e) {
      api.getPresets().then(function(result) {
        filterMessagePresets(result.presets);
      });
    });

    selectMusic1.on('select2:closing', function(e) {
      api.getMusic(true).then(function(result) {
        filterMusic(result);
      });
    });

  };

  var resetSelectButtons = function() {
    selectGroup1.val('');
    selectGroup1.select2({placeholder: 'Region'});
    selectMusic1.val('');
    selectMusic1.select2({placeholder: 'Music'});
    selectPreset1.val('');
    selectPreset1.select2({placeholder: 'Message Presets'});
    selectSchedule1.val('');
    selectSchedule1.select2({placeholder: 'Message Schedules'});
    $scope.selectedStreams = [];
  };

  initSelectButtons();

  $scope.stopPropagation = function(e) {
    e.stopPropagation();
  };

  if (groups) {
    filterGroups(groups);
  }

  if (messagePresets) {
    filterMessagePresets(messagePresets);
  }

  if (messageSchedules) {
    filterMessageSchedules(messageSchedules);
  }

  if (music) {
    filterMusic(music);

    var mapSong = function(stream) {
      if (stream.deviceid && $scope.songs[stream.streamid]) {
        return $scope.songs[stream.streamid];
      } else {
        // if we couldn't find the song, just generate a placeholder name
        return {
          name: '',
          artist: ''
        };
      }
    };

    var mapMusic = function(stream) {
      if (allMusic) {
        var musicInfo = {};
        allMusic.forEach(function(music) {
          if (stream.music_id === music.musicid && stream.music_type == music.type) {
            musicInfo = music;
          }
        });
        // If we couldn't find the music just generate a placeholder name
        if (stream.music_id && !Object.keys(musicInfo).length) {
          musicInfo = {
            name: '(account-created ' + stream.music_type + ')',
            musicid: stream.music_id,
            type: stream.music_type
          };
        }
        return musicInfo;
      }
    };

    var mapMessagePreset = function(stream) {
      if (messagePresets) {
        var messagePreset = {};
        messagePresets.forEach(function(preset) {
          if (stream.message_preset === preset.presetid) {
            messagePreset = preset;
          }
        });
        // If we couldn't find the message preset just generate a placeholder name
        if (stream.message_preset && !Object.keys(messagePreset).length) {
          messagePreset = {
            presetid: stream.message_preset,
            name: '(account-created preset)'
          };
        }
        return messagePreset;
      }
    };

    var mapMessageSchedule = function(stream) {
      if (messageSchedules) {
        var messageSchedule = {};
        messageSchedules.forEach(function(schedule) {
          if (stream.schedule_id === schedule.scheduleid) {
            messageSchedule = schedule;
          }
        });
        // If we couldn't find the message schedule just generate a placeholder name
        if (stream.schedule_id && !Object.keys(messageSchedule).length) {
          messageSchedule = {
            scheduleid: stream.schedule_id,
            name: '(account-created schedule)'
          };
        }
        return messageSchedule;
      }
    };

    var mapStreams = function(streams) {
      var selectedStreams = [];
      var streamIndex = {};
      streams.sort(function(a,b) {
        return a.streamid - b.streamid;
      });
      $scope.streams.sort(function(a,b) {
        return a.streamid - b.streamid;
      });
      $scope.groups.forEach(function(item) {
        var groupObj = {name: item.name, isDefault: item.is_default};
        groupsById[item.groupid] = groupObj;
      });

      // generate map for condensed iterations - fmadden
      for (var i = 0; i < $scope.streams.length; i++) {
        streamIndex[$scope.streams[i].streamid] = i;
      }

      for (var i = 0; i < streams.length; i++) {
        // 1/25/18 RK: need to explicitly set new values for $scope.streams. If you assign it to a new mapped array you get flickering in the view.
        // also need to make sure $scope.streams and new stream data contain the same number of streams

        /* TODO How do we know if a stream gets added or removed?
        if ($scope.streams.length > streams.length) {
          $scope.streams.length = streams.length;
        }
        if ($scope.streams.length < streams.length) {
          var lengthDiff = streams.length - $scope.streams.length;
          for (var j = 0; j < lengthDiff; j++) {
            $scope.streams.push({});
          }
        }
        */
        // condensed iteration algorithm - fmadden
        // The streams parameter is (normally) a subset of the total $scope.streams, so we need to find the match, can't use same index.
        var scopeStream = $scope.streams[streamIndex[streams[i].streamid]];
        if (scopeStream && scopeStream.streamid === streams[i].streamid) {
          scopeStream.songInfo = mapSong(streams[i]);
          scopeStream.musicInfo = mapMusic(streams[i]);
          scopeStream.messagePreset = mapMessagePreset(streams[i]);
          scopeStream.messageSchedule = mapMessageSchedule(streams[i]);
          if ($scope.devices[scopeStream.streamid]) {
            var device = $scope.devices[scopeStream.streamid];
            scopeStream.deviceIP = (device.ipaddress) ? device.ipaddress : '';
            scopeStream.deviceMAC = (device.macaddress) ? device.macaddress : '';
          }
          Object.keys(streams[i]).map(function(key) {
            scopeStream[key] = streams[i][key];
          });
          if (groupsById[scopeStream.groupid]) {
            scopeStream.groupname = groupsById[streams[i].groupid].name;
            scopeStream.groupDefault = groupsById[streams[i].groupid].isDefault;
          }
          else {
            // Franchise B sub-accounts may have their own group IDs if not assigned by the top level
            scopeStream.groupname = 'Default';
            scopeStream.groupDefault = true;
          }
        }

        /*
        // The streams parameter is (normally) a subset of the total $scope.streams, so we need to find the match, can't use same index.
        for (var j = 0; j < $scope.streams.length; j++) {
          // update selectedStreams
          if ($scope.selectedStreams.length && $scope.selectedStreams.includes($scope.streams[j].streamid)) {
            selectedStreams.push(streams[i].streamid);
          }

          if ($scope.streams[j].streamid === streams[i].streamid) {
            $scope.streams[j].songInfo = mapSong(streams[i]);
            $scope.streams[j].musicInfo = mapMusic(streams[i]);
            $scope.streams[j].messagePreset = mapMessagePreset(streams[i]);
            $scope.streams[j].messageSchedule = mapMessageSchedule(streams[i]);
            if ($scope.devices[$scope.streams[j].streamid]) {
              var device = $scope.devices[$scope.streams[j].streamid];
              $scope.streams[j].deviceIP = (device.ipaddress) ? device.ipaddress : '';
              $scope.streams[j].deviceMAC = (device.macaddress) ? device.macaddress : '';
            }
            Object.keys(streams[i]).map(function(key) {
              $scope.streams[j][key] = streams[i][key];
            });
            if (groupsById[$scope.streams[j].groupid]) {
              $scope.streams[j].groupname = groupsById[streams[i].groupid].name;
              $scope.streams[j].groupDefault = groupsById[streams[i].groupid].isDefault;
            }
            else {
              // Franchise B sub-accounts may have their own group IDs if not assigned by the top level
              $scope.streams[j].groupname = 'Default';
              $scope.streams[j].groupDefault = true;
            }
            break;
          }
        }
        */
      }
    };

    var getActiveAccountStreams = function() {
      var devicesOnPage = [];
      var streamsOnSonos = [];
      var activeStreams = [];
      for (var i = 0; i < $scope.streams.length; i++) {
        if ($scope.streams[i].devicetype === 'sonos') {
          streamsOnSonos.push($scope.streams[i].streamid);
        }
        if ($scope.streams[i].deviceid) {
          devicesOnPage.push($scope.streams[i].deviceid);
        }
      }

      var getActiveStreamsForSonos = function() {
        if (streamsOnSonos.length > 0) {
          api.getStreamsSubsetWithDevice(streamsOnSonos, function(result) {
            if (result.songs) {
              for (var i = 0; i < streamsOnSonos.length; i++) {
                if (result.songs[streamsOnSonos[i]]) {
                  activeStreams.push(streamsOnSonos[i]);
                }
              }
            }
            setDeviceDetailsForStream(activeStreams);
          }, function(err) {
            console.warn('Error calling api.getStreamsSubsetWithDevice, err: ', err);
            setDeviceDetailsForStream(activeStreams);
          });
        } else {
          // No streams on Sonos
          setDeviceDetailsForStream(activeStreams);
        }
      };

      if (devicesOnPage.length > 0) {
        // Get device state for the devices we can get
        api.getDeviceState(devicesOnPage)
          .then(function (results) {
            if (results.DeviceState && results.DeviceState.length > 0) {
              results.DeviceState.forEach(function (devState) {
                if (devState.streamid && moment().diff(moment(devState.lastUpdate), 'minutes') <= 10 && devState.state === "playing") {
                  activeStreams.push(devState.streamid);

                  // Don't need to fetch streams from DB for devices we already got from Device State
                  var idx = streamsOnSonos.indexOf(devState.streamid);
                  if (idx >= 0) {
                    streamsOnSonos.splice(idx, 1);
                  }
                }
              });
            }
            getActiveStreamsForSonos();
          })
          .catch(function (err) {
            console.warn('Error calling api.getDeviceState, err: ', err);

            // Device State request failed, proceed to get active streams on sonos
            getActiveStreamsForSonos();
          });
      } else {
        //No devices on Page, proceed to get active streams on sonos
        getActiveStreamsForSonos();
      }
    };

    var setDeviceDetailsForStream = function (activeStreams){
      for (var i = 0; i < $scope.streams.length; i++) {
        var stream = $scope.streams[i];
        stream.active = 0;
        for (var j = 0; j < activeStreams.length; j++) {
          if (
              activeStreams[j] === stream.streamid &&
              $scope.devices[stream.streamid]     &&
              $scope.devices[stream.streamid].deviceid === stream.deviceid
          ) {
            // 2015-9-11 mathachew: We don't know if the device is active until this point. It could be set
            // in the mapping above, but would then need to be unset for inactive streams
            stream.deviceName = $scope.devices[stream.streamid].devicename;
            stream.deviceType = $scope.devices[stream.streamid].type;
            stream.deviceIP   = $scope.devices[stream.streamid].ipaddress;
            stream.deviceMAC  = $scope.devices[stream.streamid].macaddress;
            stream.deviceAppversion  = $scope.devices[stream.streamid].appversion;
            if (!stream.skips) stream.skips = 0;
            // 2017-8-3 rk: stream is only active if they actually have an active device playing that we can get the name of
            if (stream.deviceName) stream.active = 1;
          }
        }
      }
    };
    var mapDeviceStateMedia = function(streamid, srcSong) {
      if ($scope.songs[streamid]) {
        $scope.songs[streamid].name = srcSong.title;
        $scope.songs[streamid].mediaType = srcSong.type;
        $scope.songs[streamid].artist = srcSong.artist;
        $scope.songs[streamid].stationid = null;
        $scope.songs[streamid].station = srcSong.station;
        $scope.songs[streamid].mediaid = srcSong.mediaid;
        $scope.songs[streamid].liked = false;
      }
      else {
        // Stream won't have a $scope.songs entry if it wasn't active when the initialData was fetched
        $scope.songs[streamid] = {
          name: srcSong.title,
          mediaType: srcSong.type,
          artist: srcSong.artist,
          stationid: null,
          station: srcSong.station,
          mediaid: srcSong.mediaid,
          liked: false
        };
      }
    };

    var mapDeviceStateDevice = function(streamid, srcDevice, srcId) {
      var destDevice = $scope.devices[streamid];
      if (typeof destDevice == 'undefined')
        // If a new stream was just added, it may not have a device assigned.
        return;
      else if (destDevice.deviceid != srcId)
        // TODO Need to know when the device for a stream changes!
        console.warn("DeviceState id (%d) doesn't agree with $scope.devices deviceid (%d)", srcId, destDevice.deviceid);
      else {
        destDevice.devicename = srcDevice.name;
        destDevice.type = srcDevice.type;
      }
    };

    var getStreamsFromDb = function (streamids, callback) {
      if (!streamids || !streamids.length) {
        if (callback) {
          callback(null);
        }

        return;
      }

      api.getStreamsSubsetWithDevice(streamids, function(result) {
        streamsPollRate = result.streamsPollRate;
        Object.keys(result.songs).map(function(key) {
          $scope.songs[key] = result.songs[key];
        });
        Object.keys(result.devices).map(function(key) {
          $scope.devices[key] = result.devices[key];
        });
        mapStreams(result.streams);
        getActiveAccountStreams();
        $scope.safeApply();
        if (callback) callback(null);
      }, function(err) {
        console.warn('Error calling api.getStreamsSubsetWithDevice, err: ', err);
        if (callback) callback(err);
      });
    };

    var getStreamPage = function(callback) {
      var devicesOnPage = [];
      var streamsOnPage = [];

      var getRemainingStreams = function () {

        // Get remaining entries not found in Device State
        // TODO if we don't call this because we got everything from Device State, we won't get updates to poll rate.
        if (streamsOnPage.length > 0) {
          getStreamsFromDb(streamsOnPage, callback);
        } else {

          // If we didn't need to get remaining from api, still need to do this.
          getActiveAccountStreams();
          $scope.safeApply();
          if (callback) {
            callback(null);
          }
        }
      };

      // Only consider the streams on the page
      $scope.filteredUsers.forEach(function(item) {
        if (item.deviceType === 'sonos') {
          streamsOnPage.push(item.streamid);
        }
        //var id = $scope.devices[item.streamid].deviceid;
        if (item.deviceid) devicesOnPage.push(item.deviceid);
      });

      if (devicesOnPage.length) {

        // Get device state for the devices we can get
        api.getDeviceState(devicesOnPage)
          .then(function (results) {
            if (results.DeviceState && results.DeviceState.length > 0) {
              var mediaLikes = [];

              results.DeviceState.forEach(function (devState) {
                if (devState.streamid && moment().diff(moment(devState.lastUpdate), 'minutes') <= 10) {
                  if ('not_playing' === devState.state) {
                    mapDeviceStateMedia(devState.streamid, { name: '', mediaType: '', artist: '', station: '' });
                  } else {
                    mapDeviceStateMedia(devState.streamid, devState.media);
                  }

                  mapDeviceStateDevice(devState.streamid, devState.device, devState.id);

                  // Don't need to fetch streams from DB for devices we already got from Device State
                  var idx = streamsOnPage.indexOf(devState.streamid);
                  if (idx >= 0) {
                    streamsOnPage.splice(idx, 1);
                  }

                  if (devState.userid && devState.media.mediaid && devState.media.station) {
                    mediaLikes.push({
                      userId: devState.userid,
                      mediaId: devState.media.mediaid,
                      playlistName: devState.media.station,
                      streamId: devState.streamid
                    });
                  }
                }
              });

              if (mediaLikes.length > 0) {
                api.getMediaLikeBatch(mediaLikes)
                  .then(function (mediaLikesResults) {
                    mediaLikes.forEach(function (like) {
                      var mediaLikeResult = mediaLikesResults.filter(function (likeResult) {
                        return like.userId === likeResult.userId
                          && like.mediaId === likeResult.mediaId
                          && like.playlistName === likeResult.playlistName;
                      });

                      if (mediaLikeResult.length > 0) {
                        $scope.songs[like.streamId].liked = true;
                      }
                    });
                  });
              }
            }

            getRemainingStreams();
          })
          .catch(function (err) {
            console.warn('Error calling api.getDeviceState, err: ', err);

            // Device State request failed, get everything from api
            getRemainingStreams();
          });
      } else {
        getRemainingStreams();
      }
    };

    // eslint-disable-next-line no-inner-declarations
    function getSuccessMessage(type, name, prefetchCount, nonPrefetchCount) {
      if (prefetchCount === 0 && nonPrefetchCount > 0) {
        return 'The ' + type + ' has been updated to ' + name + ' for ' + nonPrefetchCount + ' zone(s)';
      } else if (prefetchCount > 0 && nonPrefetchCount === 0) {
        return 'The ' + type + ' will be updated to ' + name + ' for ' + prefetchCount + ' zone(s) at the next media window';
      } else if (prefetchCount > 0 && nonPrefetchCount > 0) {
        return 'The ' + type + ' has been updated to ' + name + ' for ' + nonPrefetchCount + ' zone(s), and ' + prefetchCount + ' will take effect at the next media window';
      } else {
        return 'The ' + type + ' was not updated';
      }
    }

    // eslint-disable-next-line no-inner-declarations
    function getStreamBreakdown(streamids, streams, devices, streamsUpdated) {
      var prefetchStreams = [], nonPrefetchStreams = [];
      streamids.forEach(function (streamid) {
        var matches = streams.filter(function (s) {
          return s.streamid === streamid && (streamsUpdated ? streamsUpdated.indexOf(s.streamid) !== -1 : true);
        });

        if (matches.length) {
          var stream = matches[0];
          var device = devices[stream.streamid];
          if (stream.isPrefetch && device && device.type === 'cloudbox' && device.appversion[0] >= '6')
            prefetchStreams.push(stream);
          else
            nonPrefetchStreams.push(stream);
        }
      });
      return {
        prefetchStreams: prefetchStreams,
        nonPrefetchStreams: nonPrefetchStreams
      };
    }

    $scope.changeMusic = function () {
      var stationName = $scope.selectedStation.name;
      var musicType = $scope.selectedStation.value.split('_')[0];
      var musicId = $scope.selectedStation.value.split('_')[1];

      api.updateMassMusic($scope.selectedStreams, musicType, musicId)
        .then(function (response) {
          $scope.selectedButton = '';
          $scope.selectedStation = -2;
          getStreamPage(null);

          var breakdown = getStreamBreakdown($scope.selectedStreams, $scope.streams, $scope.devices, response.meta.streamsUpdated);

          $scope.showSuccess(getSuccessMessage('station', stationName, breakdown.prefetchStreams.length, breakdown.nonPrefetchStreams.length));

          if ($scope.selectedStreams.length !== response.meta.streamsUpdated.length) {
            userNotificationService.addErrorMessage('There was an issue changing the station for ' + ($scope.selectedStreams.length - response.meta.streamsUpdated.length) + ' zone(s).');
          }

          resetSelectButtons();

          if ($scope.toggleAllSelected) {
            $scope.toggleAll();
          }
        })
        .catch(function () {
          resetSelectButtons();

          if ($scope.toggleAllSelected) {
            $scope.toggleAll();
          }

          $scope.showWarning('There was an error updating the station');
        });
    };
  }

  function setupMusicDropdowns (music) {
    var musicOptions = music;
    $scope.availableOptions = [];

    // Allow music admins to view all music selections, regardless of whether they are limited to company selections.
    if (music.companyStations && !userPerms.isMusicAdmin) {
      musicOptions = music.companyStations;
    }

    if (musicOptions.dayparting && musicOptions.dayparting[0]) {
      musicOptions.dayparting.map(function(item) {
        if (
          music.companyStations         ||
          item.isGlobal                 ||
          $scope.userPerms.isMusicAdmin ||
          (!item.isGlobal && me.user.userid === item.userid)
        ) {
          $scope.availableOptions.push({
            value: item.type + '_' + item.daypartingid,
            name: item.name,
            type: '--- Dayparting ---'
          });
        }
      });
    }
    if (musicOptions.mix && musicOptions.mix[0]) {
      musicOptions.mix.map(function(item) {
        if (
          music.companyStations         ||
          item.isGlobal                 ||
          $scope.userPerms.isMusicAdmin ||
          (!item.isGlobal && me.user.userid === item.userid)
        ) {
          $scope.availableOptions.push({
            value: item.type + '_' + item.mixid,
            name: item.name,
            type: '--- Mix Stations ---'
          });
        }
      });
    }
    if (musicOptions.public && musicOptions.public[0]) {
      musicOptions.public.map(function(item) {
        $scope.availableOptions.push({
          value: item.type + '_' + (item.playlistid ? item.playlistid : item.musicid),
          name: item.name,
          type: '--- Stations ---'
        });
      });
    }
  }


  $scope.changeGroup = function () {
    var selectedGroup = $scope.groups
      .find(function (group) {
        return group.groupid === $scope.selectedGroup;
      });
    var selectedGroupName = selectedGroup.name;
    var breakdown = getStreamBreakdown($scope.selectedStreams, $scope.streams, $scope.devices);

    api.updateMassGroupId({
      streams: $scope.selectedStreams,
      groupid: $scope.selectedGroup
    }, function () {
      $scope.selectedButton = '';
      $scope.selectedGroup = -1;
      getStreamPage(null);
      $scope.showSuccess(getSuccessMessage('region', selectedGroupName, breakdown.prefetchStreams.length, breakdown.nonPrefetchStreams.length));
      resetSelectButtons();

      if ($scope.toggleAllSelected) {
        $scope.toggleAll();
      }
    }, function () {
      resetSelectButtons();

      if ($scope.toggleAllSelected) {
        $scope.toggleAll();
      }

      $scope.showWarning('There was an error updating the region');
    });
  };

  $scope.changeMessagePreset = function () {
    var selectedMessagePreset = $scope.messagePresets
      .find(function (preset) {
        return preset.presetid === $scope.selectedPreset;
      });
    var selectedMessagePresetName = selectedMessagePreset.name;
    var breakdown = getStreamBreakdown($scope.selectedStreams, $scope.streams, $scope.devices);

    api.updateMassMessagePreset({
      streams: $scope.selectedStreams,
      preset_id: $scope.selectedPreset
    }, function () {
      $scope.selectedButton = '';
      $scope.selectedPreset = -2;
      getStreamPage(null);
      $scope.showSuccess(getSuccessMessage('message preset', selectedMessagePresetName, breakdown.prefetchStreams.length, breakdown.nonPrefetchStreams.length));
      resetSelectButtons();

      if ($scope.toggleAllSelected) {
        $scope.toggleAll();
      }
    }, function () {
      resetSelectButtons();

      if ($scope.toggleAllSelected) {
        $scope.toggleAll();
      }

      $scope.showWarning('There was an error updating the message preset');
    });
  };

  $scope.changeMessageSchedule = function () {
    var selectedMessageSchedule = $scope.messageSchedules
      .find(function (schedule) {
        return schedule.scheduleid === $scope.selectedSchedule;
      });
    var selectedMessageScheduleName = selectedMessageSchedule.name;
    var breakdown = getStreamBreakdown($scope.selectedStreams, $scope.streams, $scope.devices);

    api.updateMassMessageSchedule({
      streams: $scope.selectedStreams,
      schedule_id: $scope.selectedSchedule
    }, function () {
      $scope.selectedButton = '';
      $scope.selectedSchedule = -2;
      getStreamPage(null);
      $scope.showSuccess(getSuccessMessage('message schedule', selectedMessageScheduleName, breakdown.prefetchStreams.length, breakdown.nonPrefetchStreams.length));
      resetSelectButtons();

      if ($scope.toggleAllSelected) {
        $scope.toggleAll();
      }
    }, function () {
      resetSelectButtons();

      if ($scope.toggleAllSelected) {
        $scope.toggleAll();
      }

      $scope.showWarning('There was an error updating the message schedule');
    });
  };

  $scope.order = function (orderBy) {
    if (orderBy === 'active' || orderBy === 'songInfo.name') {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : true;
      $scope.orderBy2 = '-username';
      $scope.orderBy3 = '-streamname';
    } else {
      $scope.reverse = ($scope.orderBy === orderBy) ? !$scope.reverse : false;
      $scope.orderBy2 = 'username';
      $scope.orderBy3 = 'streamname';
    }
    if (orderBy === 'username') {
      $scope.orderBy2 = 'streamname';
    }
    $scope.orderBy = orderBy;
  };

  $scope.toggleAll = function(e) {
    $scope.selectedStreams = [];
    if (!$scope.toggleAllSelected) {
      if ($scope.query) {
        $scope.filteredUsers.forEach(function(item) {
          $scope.selectedStreams.push(item.streamid);
        });
      } else {
        $scope.streams.forEach(function (item) {
          $scope.selectedStreams.push(item.streamid);
        });
      }
    }
    $scope.toggleAllSelected = !($scope.toggleAllSelected);
  };

  $scope.changeChecked = function(item, e) {
    if (!$scope.entStatus.isEnterprise || item == undefined || e.target.tagName.toLowerCase() == 'a' || e.target.tagName.toLowerCase() == 'button') {
      return;
    }
    var loc = $scope.selectedStreams.indexOf(item);
    if (loc > -1) {
      $scope.selectedStreams.splice(loc, 1);
    } else {
      $scope.selectedStreams.push(item);
    }
    $scope.toggleAllSelected = ($scope.selectedStreams.length == $scope.streams.length);
    if ($scope.selectedStreams.length == 0) {
      $scope.selectedButton = '';
    }
  };

  $scope.viewLocationStream = function(streamId) {
    api.getStreamHistory(streamId, 50)
      .then(function (rows) {

        // 2016-10-28 tbrown  API now returns a Unix timestamp, convert to JS date.
        rows.songs.map(function(song) {
          song.time = new Date(song.timestamp.ts * 1000);
        });
        streamHistoryModal.show(rows).catch(angular.noop);
      })
      .catch(function () {
        $scope.showWarning('There was an error');
      });
  };

  var updateMusic = function(callback) {
    getStreamPage(function(err) {
      if (err) {
        console.warn('Error getting device state and streams, continuing anyway.', err);
      }
      api.getGroups(function(groupResults) {
        api.getMusic(1).then(function(musicResult) {
          allMusic = musicResult.public.concat(musicResult.mix, musicResult.dayparting);
          $scope.groups = groupResults.groups;
          refresher.cancelTimer();
          if (subscriptionInfo.messageQuantityAllowedPerPreset()) {
            api.getPresets(1).then(function(presets) {
              messagePresets = presets.presets;
              api.getMessageSchedules().then(function(messageSchedules) {
                messageSchedules = messageSchedules.schedules;
                mapStreams($scope.streams);
                $scope.safeApply();
                if (callback) {
                  callback();
                }
                return;
              });
            });
          } else {
            mapStreams($scope.streams);
            $scope.safeApply();
            if (callback) {
              callback();
            }
            return;
          }
        });
      });
    });
  };

  /*
  var updateMusic = function() {
    var streamsOnPage = [];
    $scope.filteredUsers.forEach(function(item) {
      streamsOnPage.push(item.streamid);
    });

    api.getStreamsSubsetWithDevice(streamsOnPage, function(streamResults) {
      streamsPollRate = streamResults.streamsPollRate;
      if (streamResults.streams.length) {
        api.getGroups(function(groupResults) {
          if (
            !angular.equals($scope.songs, streamResults.songs)     ||
            !angular.equals($scope.devices, streamResults.devices) ||
            !angular.equals($scope.groups, groupResults.groups)    ||
            !streamUpdateService.compareStreams($scope.streams, streamResults.streams)
          ) {
            api.getMusic(1).then(function(musicResult) {
              allMusic = musicResult.public.concat(musicResult.mix, musicResult.dayparting);
              $scope.groups = groupResults.groups;
              Object.keys(streamResults.songs).map(function(key) {
                $scope.songs[key] = streamResults.songs[key];
              });
              Object.keys(streamResults.devices).map(function(key) {
                $scope.devices[key] = streamResults.devices[key];
              });
              refresher.cancelTimer();
              if (subscriptionInfo.messageQuantityAllowedPerPreset()) {
                api.getPresets(1).then(function(presets) {
                  messagePresets = presets.presets;
                  api.getMessageSchedules().then(function(messageSchedules) {
                    messageSchedules = messageSchedules.schedules;
                    mapStreams(streamResults.streams);
                    getActiveAccountStreams(me.account.custid);
                    $scope.safeApply();
                    return;
                  });
                });
              } else {
                mapStreams(streamResults.streams);
                getActiveAccountStreams(me.account.custid);
                $scope.safeApply();
                return;
              }
            });
          }
        });
      }
    }, function(err) {
      console.error('There was a problem updating music', err);
      return;
    });
  };
  */

  var skipCounter = function(stream) {
    if (skipTracker[stream.userid]) {
      $timeout.cancel(skipTracker[stream.userid]);
    }
    skipTracker[stream.userid] = $timeout(function() {
      if (stream.skips > 0) {
        stream.skips--;
        skipCounter(stream);
      }
    }, 600000);
  };

  var refreshSongs = function() {
    updateMusic(function() {
      refreshSongsTimer = $timeout(refreshSongs, streamsPollRate);
    });
  };

  $scope.$on('$destroy', function() {
    skipTracker.forEach(function(item){
      $timeout.cancel(item);
    });
    $timeout.cancel(refreshSongsTimer);
  });

  $scope.isLocalStream = function(stream) {
    // It's the local stream if it's selected in the player bar and we're in Playing (Stream) mode.
    return (streamUpdateService.getSelectedStream().streamid === stream.streamid) && playerService.isPlayingMode();
  };

  $scope.skipDevice = function(stream, trackSkip) {
    if (trackSkip && stream.skips >= skipLimit) {
      $scope.showSuccess('You have reached the skip limit for this device. You will receive an additional skip after 10 minutes.');
      return;
    }
    var device = $scope.devices[stream.streamid];
    device.userid = stream.userid;
    device.custid = stream.custid;
    deviceCommand.skipDevice(device, function(message) {
      if (message.successMessage) {
        if (trackSkip) {
          stream.skips++;
          skipCounter(stream);
        }
        $scope.showSuccess(message.successMessage);
      }
      if (message.errMessage) {
        $scope.showWarning(message.errMessage);
      }
      var timerOptions = {
        counter: 3,
        interval: 3000
      };
      refresher.refresh(updateMusic, timerOptions);
    });
  };

  $scope.pauseDevice = function(stream) {
    var device = $scope.devices[stream.streamid];
    device.userid = stream.userid;
    device.custid = stream.custid;
    deviceCommand.pauseDevice(device, function(message) {
      if (message.successMessage) {
        $scope.showSuccess(message.successMessage);
      }
      if (message.errMessage) {
        $scope.showWarning(message.errMessage);
      }
    });

    var intercomData = {
      source: 'zones page',
      custid: device.custid,
      localDeviceId: $scope.me.device_id,
      localUserId: $scope.me.user.userid,
      streamingDeviceType: device.type,
      streamingDeviceId: device.deviceid,
      streamingUserId: device.userid,
      streamId: stream.streamid
    };
    intercom.sendEvent('remote pause', intercomData);
  };

  $scope.unpauseDevice = function(stream) {
    var device = $scope.devices[stream.streamid];
    device.userid = stream.userid;
    device.custid = stream.custid;
    deviceCommand.unpauseDevice(device, function(message) {
      if (message.successMessage) {
        $scope.showSuccess(message.successMessage);
      }
      if (message.errMessage) {
        $scope.showWarning(message.errMessage);
      }
    });

    var intercomData = {
      source: 'zones page',
      custid: device.custid,
      localDeviceId: $scope.me.device_id,
      localUserId: $scope.me.user.userid,
      streamingDeviceType: device.type,
      streamingDeviceId: device.deviceid,
      streamingUserId: device.userid,
      streamId: stream.streamid
    };
    intercom.sendEvent('remote play', intercomData);
  };

  $scope.isPrefetchEnabled = userPerms.isAccountOwner && me.account.use_prefetch;

  $scope.isStreamDeviceCloudBox = function (stream) {
    return stream.devicetype === 'cloudbox';
  };

  $scope.requestDevicePrefetch = function (stream) {
    var device = $scope.devices[stream.streamid];
    device.userid = stream.userid;
    device.custid = stream.custid;

    $scope.openPrefetchConfirmModal(device)
      .result
      .then(function () {
        deviceCommand.updateSchedule(device, handleCommandResponse)
      })
      .catch(angular.noop);

    function handleCommandResponse(message) {
      if (message.successMessage) {
        userNotificationService.addSuccessMessage(message.successMessage);
      }

      if (message.errMessage) {
        userNotificationService.addWarnMessage(message.errMessage);
      }
    }
  };

  $scope.openPrefetchConfirmModal = function (device) {
    return $modal.open({
      templateUrl: 'partials/device_dl_media_confirm_modal.html',
      windowClass: 'device-dl-media-confirm',
      controller: ['device', function (device) {
        var vm = this;

        vm.device = device;
      }],
      controllerAs: 'vm',
      resolve: {
        device: function () {
          return device;
        }
      }
    });
  };

  $scope.removeSong = function(stream) {
    var reason = "DontLikeSong";
    var song = $scope.songs[stream.streamid];
    var removedSong = {
      reason: reason,
      mediaid: song.mediaid,
      userid: stream.userid
    };
    var intercomData = {
      'Name': song.name,
      'Description': stream.musicInfo.description,
      'Artist': song.artist,
      'Station': stream.musicInfo.name,
      'Reason': reason,
      'Media ID': song.mediaid
    };
    api.removeSong(removedSong, function() {
      $scope.showSuccess(song.name + ' has been successfully removed');
      intercom.sendEvent('Removed song', intercomData);
      $scope.skipDevice(stream, false);
    }, function() {
      $scope.showWarning('There was a problem removing this song.');
      intercom.sendEvent('Remove song failed', intercomData);
    });
  };

  $scope.toggleSongLike = function (stream) {
    var song = $scope.songs[stream.streamid];
    if (!song) {
      return;
    }

    if (song.liked) {
      deleteSongLike(stream);
    } else {
      createSongLike(stream);
    }
  };

  function createSongLike(stream) {
    var song = $scope.songs[stream.streamid];
    var playlistId = $scope.songs[stream.streamid].playlistid;
    var playlistName = $scope.songs[stream.streamid].station;

    song.liked = true;
    song.isMediaLikeRequestActive = true;

    api.createMediaLike(stream.userid, song.mediaid, playlistId, playlistName)
      .then(function () {
        $scope.showSuccess(song.name + ' has been successfully liked');
      })
      .catch(function () {
        song.liked = false;
        $scope.showWarning('There was a problem liking this song.');
      })
      .finally(function() {
        song.isMediaLikeRequestActive = false;
      });
  }

  function deleteSongLike(stream) {
    var song = $scope.songs[stream.streamid];
    var playlistId = $scope.songs[stream.streamid].playlistid;
    var playlistName = $scope.songs[stream.streamid].station;

    song.liked = false;
    song.isMediaLikeRequestActive = true;

    api.deleteMediaLike(stream.userid, song.mediaid, playlistId, playlistName)
      .catch(function () {
        song.liked = true;
        $scope.showWarning('There was a problem unliking this song.');
      })
      .finally(function() {
        song.isMediaLikeRequestActive = false;
      });
  }

  $scope.canSetVolume = function(stream) {
    var device = $scope.devices[stream.streamid];

    return device ? deviceCommand.deviceSupportsCommands(device.type) : false;
  };

  var adjustVolume = function(stream, value) {
    var device = angular.copy($scope.devices[stream.streamid]);
    device.userid = stream.userid;
    device.custid = stream.custid;

    deviceCommand.adjustDeviceVolume(device, value);

    var intercomData = {
      source: 'admin zones page',
      custid: device.custid,
      localDeviceId: $scope.me.device_id,
      localUserId: device.userid,
      streamingDeviceId: device.deviceid,
      target: $scope.me.device_id === device.deviceid ? 'local' : 'remote',
      volumeChange: (value >= 0 ? '+' : '') + (value * 100) + '%'
    }
    intercom.sendEvent("Change volume (relative)", intercomData);
  };

  $scope.lowerVolume = function(stream) {
    adjustVolume(stream, '-0.05');
  };

  $scope.raiseVolume = function(stream) {
    adjustVolume(stream, '0.05');
  };

  $scope.refreshCloudBox = function(stream) {
    refreshCloudBoxModal({
      username: stream.username,
      streamname: stream.streamname
    })
      .then(function (params) {
        api.refreshCloudBox(stream.streamid)
          .then(function (response) {
            if (!response.data.success) {
              $scope.showWarning('Cannot reach your CloudBox. Please check network connection. If this issue persists, chat with our support team.');
            } else if (!response.data.deviceid) {
              $scope.showWarning('No CloudBox found for this zone.');
            } else {
              $scope.showSuccess('Your CloudBox should resume playing shortly.');
            }
          })
          .catch(function (err) {
            $scope.showError('Failed to resume CloudBox. If this issue persists please contact Support.');
          });
      })
      .catch(function (e) {
        // 2021-04-08 rporczak -- Refresh CloudBox canceled. No-op.
      });
  }

  var accountOwnerFilter = function(stream) {
    if (
      !stream.unlicensed_account_owner ||
      (stream.unlicensed_account_owner && !stream.isAccountAdmin)
    ) {
      return true;
    } else {
      return false;
    }
  };

  var countLocations = function() {
    var locCount = 0;
    var locCountObj = {};
    $scope.streams.forEach(function(item) {
      if (accountOwnerFilter(item)) {
        if (locCountObj[item.userid]) {
          return;
        } else {
          locCountObj[item.userid] = item;
          locCount++;
        }
      }
    });
    return locCount;
  };

  $scope.showStreamDialog = function() {
    if (countLocations() === 1) {
      var filteredUser = $scope.filteredUsers.filter(function(item) {
        return accountOwnerFilter(item);
      });
      streamModal.setModel({
        userid: filteredUser[0].userid,
        location: filteredUser[0].username + ' - ' + filteredUser[0].street + ', ' + filteredUser[0].state
      });
    }
    streamModal.show()
      .then(function(result) {
        if (result.status && result.status !== 200) {
          $scope.showWarning('There was a problem saving this zone, please try again. If the issue persists, please contact support');
        }
        else {
          subscriptionInfo.refreshSubscription(function() {
            api.getStreamsWithDevice($scope.currentPage, function(result) {
              if (result.streams) {
                $scope.streams = result.streams;
                $scope.devices = result.devices;
                updateMusic(null);
              }
            }, function(err) {
              console.error(err);
            });
            $scope.showSuccess('The Zone: "' + result.streamname + '" has been successfully added');
          });
        }
      })
      .catch(angular.noop);
  };

  $scope.isEditing = function(stream) {
    return editStreamid === stream.streamid;
  };

  $scope.editStream = function(stream) {
    if (editStreamid !== stream.streamid) {
      editStreamid = stream.streamid;
      $scope.tempStreamname = {value: stream.streamname};
    }
  };

  $scope.saveStreamEdit = function(stream) {
    var newStreamname = $scope.tempStreamname.value;
    if (newStreamname === stream.streamname) {
      editStreamid = null;
      $scope.tempStreamname.value = '';
      return;
    }
    var data = {
      custid: api.userObject.user.custid,
      userid: stream.userid,
      streamname: newStreamname,
      streamid: stream.streamid
    };
    api.editStream(data).then(function() {
      stream.streamname = newStreamname;
      editStreamid = null;
      $scope.tempStreamname.value = '';
      updateMusic(null);
      if (streamUpdateService.getSelectedStream().streamid === stream.streamid) {
        streamUpdateService.setSelectedStream(stream);
      }
      streamUpdateService.setStreamsUpdateFlag();
      $scope.showSuccess('The Zone: "'+ stream.streamname + '" has been successfully updated');
    }, function(err) {
      if (err.data && err.data.code === 'DuplicateError') {
        $scope.showWarning('This Zone name is already taken for this location, please try another');
      } else {
        $scope.showWarning('There was a problem editing this zone, please try again. If the issue persists, please contact support');
      }
    });
  };

  $scope.cancelStreamEdit = function () {
    editStreamid = null;
    $scope.tempStreamname = '';
  };

  $scope.showAutoLoginDialog = function (stream) {
    if (stream.streamid) {
      api.getAutoLoginURL(stream, function (loginInfo) {
        if (loginInfo.autologin.autologin_weburl) {
          stream.autologin_weburl = loginInfo.autologin.autologin_weburl;
        }
        autoLoginUrlModal.show(stream).catch(angular.noop);
      }, function (err) {
        console.error('Error: Failed to check Auto Login URL', err);
      });
    }
  }

  $scope.showStreamAudioLinkDialog = function (stream) {
    if (stream.streamid) {
      $modal
        .open({
          templateUrl: 'partials/stream_audio_link_modal.html',
          windowClass: 'stream-audio-link-modal',
          resolve: {
            stream: function () {
              return stream;
            },
            streams: function () {
              return $scope.streams;
            },
            streamAudioLink: function () {
              return api.getStreamAudioLinks(stream.streamid)
                .then(function (audioLinks) {
                  var audioLink = audioLinks && audioLinks[0];

                  return audioLink ? audioLink : null;
                });
            }
          },
          controllerAs: 'vm',
          controller: ['$modalInstance', 'stream', 'streams', 'streamAudioLink',
            function ($modalInstance, stream, streams, streamAudioLink) {
              var vm = this;

              // Properties
              vm.form = {
                permanentStream: null,
                ephemeralStreamId: null,
                streams: null
              };
              vm.isUpdatingAudioLink = Boolean(streamAudioLink);

              // Startup
              init();

              function init() {
                vm.form.streams = streams
                  .filter(function (s) {
                    return s.streamid !== stream.streamid && s.userid === stream.userid;
                  })
                  .map(function (s) {
                    s.label = s.username + ' ' + String.fromCharCode(8212) + ' ' + s.streamname;

                    return s;
                  });

                if (streamAudioLink) {
                  for (var i = 0; i < streams.length; i++) {
                    if (streams[i].streamid === streamAudioLink.permanentStream.id) {
                      vm.form.permanentStream = stream;
                      break;
                    }
                  }

                  vm.form.ephemeralStreamId = streamAudioLink.ephemeralStream.id;
                } else {
                  vm.form.permanentStream = stream;
                }
              }

              // Methods
              vm.remove = remove;
              vm.submit = submit;

              function remove() {
                $modalInstance.close({
                  permanentStreamId: vm.form.permanentStream.streamid,
                  ephemeralStreamId: streamAudioLink.ephemeralStream.id,
                  create: false,
                  delete: true,
                  update: false
                });
              }

              function submit(form) {
                if (form.$invalid) {
                  return;
                }

                $modalInstance.close({
                  prevEphemeralStreamId: vm.isUpdatingAudioLink ? streamAudioLink.ephemeralStream.id : undefined,
                  ephemeralStreamId: vm.form.ephemeralStreamId,
                  create: !vm.isUpdatingAudioLink,
                  delete: false,
                  update: vm.isUpdatingAudioLink
                });
              }
            }
          ]
        })
        .result
        .then(function (result) {
          if (result.create) {
            api.updateStreamAudioLink(stream.streamid, result.ephemeralStreamId)
              .then(function () {
                stream.has_audio_links = true;
                userNotificationService.addSuccessMessage('Successfully setup audio ducking for zone <strong>' + stream.streamname + ' &mdash; ' + stream.username + '</strong>.');
              })
              .catch(function () {
                userNotificationService.addErrorMessage('Failed to setup audio ducking for zone <strong>' + stream.streamname + ' &mdash; ' + stream.username + '</strong>.');
              });
          } else if (result.update) {
            var isDeleteStreamAudioLinkSuccess = false;

            api.deleteStreamAudioLink(stream.streamid, result.prevEphemeralStreamId)
              .then(function () {
                isDeleteStreamAudioLinkSuccess = true;
                return api.updateStreamAudioLink(stream.streamid, result.ephemeralStreamId);
              })
              .then(function () {
                stream.has_audio_links = true;
                userNotificationService.addSuccessMessage('Successfully updated audio ducking for zone <strong>' + stream.streamname + ' &mdash; ' + stream.username + '</strong>.');
              })
              .catch(function () {
                if (isDeleteStreamAudioLinkSuccess) {
                  stream.has_audio_links = false;
                }

                userNotificationService.addErrorMessage('Failed to update audio ducking for zone <strong>' + stream.streamname + ' &mdash; ' + stream.username + '</strong>.');
              });
          } else if (result.delete) {
            api.deleteStreamAudioLink(result.permanentStreamId, result.ephemeralStreamId)
              .then(function () {
                stream.has_audio_links = false;
                userNotificationService.addSuccessMessage('Successfully removed audio ducking for zone <strong>' + stream.streamname + ' &mdash; ' + stream.username + '</strong>.');
              })
              .catch(function () {
                userNotificationService.addErrorMessage('Failed to remove audio ducking for zone <strong>' + stream.streamname + ' &mdash; ' + stream.username + '</strong>.');
              });
          }
        })
        .catch(angular.noop);
    }
  };

  $scope.removeStream = function (stream) {
    confirmationDialog($scope, 'Are you sure you want to remove the zone: "' + stream.streamname + '"?', function() {
      api.removeStream(stream.streamid).then(function() {
        subscriptionInfo.refreshSubscription(function() {
          api.getStreamsWithDevice($scope.currentPage, function(result) {
            if (result.streams) {
              $scope.streams = result.streams;
              $scope.devices = result.devices;
              updateMusic(null);
            }
          }, function(err) {
            console.error(err);
          });
          var selectedStreamIndex = $scope.selectedStreams.indexOf(stream.streamid);
          if (selectedStreamIndex > -1) {
            $scope.selectedStreams.splice(selectedStreamIndex, 1);
          }
          $scope.showSuccess('The Zone: "'+ stream.streamname + '" has been successfully removed');
        });
      }, function(err) {
        if (err.data && err.data.message) {
          $scope.showWarning(err.data.message);
        } else {
          $scope.showWarning('There was a problem removing this zone, please try again. If the issue persists, please contact support');
        }
      });
    });
  };

  $scope.pageChanged = function(num) {
    $scope.currentPage = num;
    var tbody = $('.streams .table tbody');
    if (tbody) {
      tbody.scrollTop(0);
    }
  };

  var updateStreamsFromMessage = function(message, func) {
    message.streams.forEach(function(streamid) {
      var found = false;
      for (var i = 0; i < $scope.streams.length; i++) {
        if ($scope.streams[i].streamid === streamid) {
          func(i, message);
          found = true;
          break;
        }
      }
      if (!found) console.log('Streamid %d is not in the scope', streamid);
    });
  };

  $scope.$on('music-selection-changed', function(event, message) {
    updateStreamsFromMessage(message, function(i, message) {
      console.log('Set music for stream[%d] %d to %s %d', i, $scope.streams[i].streamid, message.music_type, message.music_id);
      $scope.streams[i].musicInfo = mapMusic({ music_id: message.music_id, music_type: message.music_type });
      $scope.streams[i].music_id = message.music_id;
      $scope.streams[i].music_type = message.music_type;
    });
  });

  $scope.$on('message-preset-set', function(event, message) {
    updateStreamsFromMessage(message, function(i, message) {
      console.log('Set preset for stream %d to %d', $scope.streams[i].streamid, message.presetid);
      $scope.streams[i].messagePreset = mapMessagePreset({ message_preset: message.presetid });
      $scope.streams[i].message_preset = message.presetid;
    });
  });
  $scope.$on('message-preset-cleared', function(event, message) {
    updateStreamsFromMessage(message, function(i, message) {
      console.log('Clear preset for stream %d', $scope.streams[i].streamid);
      $scope.streams[i].messagePreset = {};
      $scope.streams[i].message_preset = null;
    });
  });

  $scope.$on('schedule-set', function(event, message) {
    updateStreamsFromMessage(message, function(i, message) {
      console.log('Set schedule for stream %d to %d', $scope.streams[i].streamid, message.scheduleid);
      $scope.streams[i].messageSchedule = mapMessageSchedule({ schedule_id: message.scheduleid });
      $scope.streams[i].schedule_id = message.scheduleid;
    });
  });

  $scope.$on('schedule-cleared', function(event, message) {
    updateStreamsFromMessage(message, function(i, message) {
      console.log('Clear schedule for stream %d', $scope.streams[i].streamid);
      $scope.streams[i].messageSchedule = {};
      $scope.streams[i].schedule_id = null;
    });
  });

  $scope.$on('stream-device-assigned', function(event, message) {
    console.log('Device %d is now assigned to stream %d', message.deviceid, message.streamid);
    var found = false;
    for (var stream in $scope.devices) {
      if ($scope.devices[stream].deviceid == message.deviceid) {
        // Assign the device to the incoming streamid if it's a different stream
        if (message.streamid != stream) {
          $scope.devices[message.streamid] = $scope.devices[stream];
          $scope.devices[stream] = {}; // I think, since this device is not on that stream any more
        }
        found = true;
        break;
      }
    }
    if (!found) {
      console.log('Device %d is not in $scope.devices, get stream update', message.deviceid);
      // Add it
      getStreamsFromDb([message.streamid], null);
    }
  });

  // Need to call this initially to set the song/music/message info on $scope.streams.
  // Maybe later that information could be directly accessed instead of setting it on the stream?
  mapStreams($scope.streams);
  getActiveAccountStreams();

  // 2020-10-14 rporczak -- Need to be able to cancel this timeout in case the user
  //  navigates away.
  refreshSongsTimer = $timeout(refreshSongs, 2000);

  function filterGroups (groups) {
    $scope.groups = groups;
  }

  function filterMusic (music) {
    allMusic = music.public.concat(music.mix, music.dayparting);
    setupMusicDropdowns(music);
  }

  function filterMessageSchedules (messageSchedules) {
    $scope.messageSchedules = messageSchedules.filter(function(item) {
      if (
        item.isGlobal                   ||
        $scope.userPerms.isMessageAdmin ||
        (!item.isGlobal && me.user.userid === item.userid)
      ) {
        return true;
      }
    });
    $scope.messageSchedules.unshift({
      scheduleid: -1,
      name: 'No Scheduled Messages'
    });
  }

  function filterMessagePresets (messagePresets) {
    $scope.messagePresets = messagePresets.filter(function(item) {
      if (
        item.isGlobal                 ||
        $scope.userPerms.isMusicAdmin ||
        (!item.isGlobal && me.user.userid === item.userid)
      ) {
        return true;
      }
    });
    $scope.messagePresets.unshift({
      presetid: -1,
      name: 'No Message Preset'
    });
  }

}

app.controller('AddLocationCtrl', AddLocationCtrl);

AddLocationCtrl.$inject = ['$scope', 'api', 'me', '$timeout', '$location', 'groups', '$rootScope', 'subscriptionInfo', 'companyStations', 'formEditService', 'shippingRates', 'boxOrderService', 'confirmationDialog', 'ENV'];

function AddLocationCtrl ($scope, api, me, $timeout, $location, groups, $rootScope, subscriptionInfo, companyStations, formEditService, shippingRates, boxOrderService, confirmationDialog, ENV) {
  $scope.isEditing = false;
  $scope.me = me;
  $scope.$parent.hideLoader();
  $scope.$parent.currentTab = 'locations';
  $scope.timezones = window.timeZones;
  $scope.statesProvinces = window.statesProvinces;
  $scope.$parent.topTitle = 'Add Location';
  $scope.isDisabled = false;
  $scope.inTrial = subscriptionInfo.inTrial();
  $scope.shippingRates = shippingRates.shippingRates.map(function(item) { item.value = parseFloat(item.value); return item; });
  $scope.selectedRate = { choice: 0 }; // needs to be an object for ng-model to work in the view
  $scope.tax = 0;
  $scope.cloudBoxPrice = boxOrderService.formatCloudBoxPrice();
  $scope.continentalShipping = true;
  $scope.cloudBox = { isOrdering: false };
  $scope.shipTo = {
    corporate: false,
    dest: ''
  };
  $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
  $scope.messageQuantityAllowedPerPreset = subscriptionInfo.messageQuantityAllowedPerPreset();
  $scope.guardCompanySelections = guardCompanySelections;
  var box_order_params = {};
  var confirmLocationSwitch = 'Are you sure? The information will not be saved.';
  $rootScope.confirmLocationSwitch = confirmLocationSwitch;

  var findDefaultGroup = function(groups) {
    var defaultGroup = groups[0];
    for (var i = 0; i < groups.length; i++) {
      if (groups[i].is_default) {
        defaultGroup = groups[i];
        break;
      }
    }
    return defaultGroup;
  };

  $scope.clickBackButton = function() {
    formEditService.confirmNavigation($scope, true, '/admin/locations', confirmLocationSwitch);
  };

  $scope.formdata = {
    username: '',
    timezone: 'US/Eastern',
    group: findDefaultGroup(groups.groups),
    permissions: {
      user: {
        can_play_music: true,
        can_skip: true,
        can_downvote: true,
        can_pause: true,
        manage_music: true,
        select_music: true,
        manage_messages: true,
        select_messages: true,
        manage_devices: true
      }
    },
    //TODO: Refactor has_company_stations permission save steps to proper implementation. This is a shortcut, directly updating the field in the database
    has_company_stations: (me.account.default_company_stations) ? me.account.default_company_stations : 0
  };

  function guardCompanySelections() {
    if (
        $scope.formdata.has_company_stations === 1 &&
        (
          !companyStations ||
          !companyStations.companyStationDetails ||
          companyStations.companyStationDetails.length < 1
        )
    ) {
      $scope.showError('You must first add a Station, Mix, or Daypart to your Company Selections before you can enable this restriction.');
      $timeout(function() {
        $scope.formdata.has_company_stations = 0;
      }, 100);
    }
  }

  api.getAccount($scope.me.account.custid, function(result) {
    $scope.account = result.account;
  });

  function createBoxOrderParams(addressData, location) {
    var shippingAddress = boxOrderService.generateAddress(addressData, $scope.shipTo.corporate, $scope.account);
    box_order_params = {
      "account": $scope.me.account.name,
      "address": shippingAddress.street,
      "address2": shippingAddress.street2,
      "city": shippingAddress.city,
      "state": shippingAddress.state,
      "zipcode": shippingAddress.zipcode,
      "phone": shippingAddress.phone,
      "custid": location.custid,
      "device_userid": location.userid,
      "email": $scope.me.user.email,
      "is_replacement": false,
      "is_upgrade": false,
      "status": 1,
      "username": location.username,
      "shipping_rate": $scope.shippingRates[$scope.selectedRate.choice].value,
      "shipping_type": $scope.shippingRates[$scope.selectedRate.choice].name,
      "tax_amount": $scope.tax,
      "terms_checked": $scope.formdata.terms_checkbox,
      "prop65_checked": $scope.showProp65 ? $scope.formdata.prop65_checkbox : false
    };
    return box_order_params;
  }

  $scope.submit = function() {
    $scope.isDisabled = true;
    api.addNewUser($scope.formdata, function(result) {
      if ($scope.cloudBox.isOrdering) {
        api.createBoxOrder(createBoxOrderParams($scope.formdata, result.user)).then(function() {
          $rootScope.confirmLocationSwitch = false;
          confirmationDialog({ hideCancelBtn: true, backdrop: 'static' }, 'This location has been added to your account and a CloudBox order has been submitted. You will receive an email confirmation shortly.', function() {
            subscriptionInfo.refreshSubscription( function() {
              $location.path('/admin/locations');
              return;
            });
          });
        }, function(err) {
          confirmationDialog({hideCancelBtn: true}, 'There was an issue adding this location and ordering a CloudBox. Please try again. If the issue persists, please contact Cloud Cover Music Support.', function() {
            console.error(err);
            return;
          });
        });
      } else {
        $rootScope.confirmLocationSwitch = false;
        confirmationDialog({ hideCancelBtn: true, backdrop: 'static' }, 'This location has been added to your account.', function() {
          subscriptionInfo.refreshSubscription( function() {
            $location.path('/admin/locations');
            return;
          });
        });
      }
    }, function(err) {
      $scope.showError('There was an issue adding this user.');
      console.error(err.code + ': ' + err.message);
      $rootScope.confirmLocationSwitch = false;
      $location.path('/admin/locations');
    });
  };

  var checkContinentalShipping = function(shippingAddress) {
    boxOrderService.checkContinentalShipping(shippingAddress.state, function(continentalShipping, shippingDest) {
      $scope.continentalShipping = continentalShipping;
      $scope.shipTo.dest = shippingDest;
      if (!$scope.continentalShipping) {
        $scope.selectedRate.choice = 2;
      } else {
        $scope.selectedRate.choice = 0;
      }
    });
  };

  $scope.confirmNextDayShipping = function() {
    return boxOrderService.confirmNextDayShipping();
  };

  $scope.calculateTotal = function() {
    return $scope.shippingRates[$scope.selectedRate.choice].value + $scope.cloudBoxPrice + $scope.tax;
  };

  $scope.calculateTax = function() {
    if (!$scope.cloudBox.isOrdering || !$scope.formdata.street || !$scope.formdata.city || !$scope.formdata.state || !$scope.formdata.zipcode || $scope.formdata.zipcode.length < 5) {
      $scope.tax = 0;

      // 2019-09-03 rporczak -- This may seem a bit odd, but these flags are only relevant
      //  when a CloudBox is being ordered and we're doing ZIP code verification. So, if
      //  we aren't ordering a CloudBox, or if any fields are blank -- which will
      //  disable the input, because  they are required! -- reset these flags. This addresses
      //  a bug where if CloudBox ordering is turned on long enough to invalidate a ZIP code
      //  and then it is turned off again, the Submit button stays disabled.
      $scope.isDisabled = false;
      $scope.invalidInput = false;
      return;
    }
    var shippingAddress = boxOrderService.generateAddress($scope.formdata, $scope.shipTo.corporate, $scope.account);
    checkContinentalShipping(shippingAddress);
    boxOrderService.calculateTax(shippingAddress, $scope.cloudBoxPrice).then(function(result) {
      $scope.isDisabled = false;
      $scope.tax = result.tax.amount_to_collect;
      $scope.invalidInput = false;
    }, function(err) {
      $scope.tax = 0;
      if (err.status === 400 && err.data) {
        $scope.invalidInput = true;
        $scope.isDisabled = true;
      } else {
        $scope.isDisabled = false;
      }

      $scope.showWarning("There is an issue with the address for this location, please verify the information is correct and try again.");
    });
  };

  $scope.calculateProp65 = function () {
    var shippingAddress = boxOrderService.generateAddress($scope.formdata, $scope.shipTo.corporate, $scope.account);
    if(ENV.featureFlags.prop65 && $scope.cloudBox.isOrdering && shippingAddress.state === 'CA') {
      $scope.showProp65 = true;
    } else {
      $scope.showProp65 = false;
    }
  };
}
app.controller('AdminBillingCtrl', ['$scope', 'confirmationDialog', 'api', 'subscription', 'invoices', '$window', '$location', 'ENV', 'subscriptionInfo', 'plansInfo', 'enterprisePlansInfo', 'couponService',
  function($scope, confirmationDialog, api, subscription, invoices, $window, $location, ENV, subscriptionInfo, plansInfo, enterprisePlansInfo, couponService) {
    $scope.$parent.currentTab = 'billing';
    $scope.topSub = false;
    $scope.$parent.hideLoader();
    $scope.me = api.userObject;
    $scope.subscription = subscription;
    $scope.subscriptionInfo = subscriptionInfo.getPaymentStatus();
    $scope.subscription_pretty = '';
    $scope.addCoupon = {};
    $scope.inTrial = subscriptionInfo.inTrial();
    $scope.addonStreams = subscription.addonStreams;
    $scope.isSubscriptionPlanAnnual = subscriptionInfo.isPlanAnnual();
    $scope.invoices = !invoices ? null : invoices.map(function(invoice) {
      return {
        invoiceNumber: invoice.invoiceNumber,
        issuedOn: moment(invoice.issuedOn).format('MMM Do, YYYY'),
        dueOn: moment(invoice.issuedOn).add(invoice.netTerms, 'days').format('MMM Do, YYYY'),
        status: getInvoiceStatus(invoice.status),
        totalAmount: (invoice.totalAmount).toLocaleString('en-US', {
          style: 'currency',
          currency: 'USD',
        }) + ' USD'
      };
    });

    if (api.userObject.recurly.quantity && api.userObject.recurly.quantity._) {
      $scope.subscription.quantity = api.userObject.recurly.quantity._;
      $scope.subscription.unit_amount_in_cents = api.userObject.recurly.unit_amount_in_cents._;
    }

    if ($scope.addonStreams) {
      var addonCost = ($scope.addonStreams.quantity._ * $scope.addonStreams.unit_amount_in_cents._) / 100;
      $scope.totalCost = addonCost + ($scope.subscription.quantity * $scope.subscription.unit_amount_in_cents) / 100;
    } else {
      $scope.totalCost = ($scope.subscription.quantity * $scope.subscription.unit_amount_in_cents) / 100;
    }

    function getInvoiceStatus(status) {
      var map = {
        collected: 'Paid',
        paid: 'Paid',
        open: 'Open',
        failed: 'Failed',
        past_due: 'Past Due'
      };
      return map[status] || status;
    }

    function getAccountCoupons() {
      $scope.couponList = [];
      $scope.couponDetails = {};
      if ($scope.subscription.vendorid) {
        api.getAccountCouponRedemptions($scope.subscription.vendorid).then(function(result) {
          if (result && result.redemption) {
            $scope.couponList = Array.isArray(result.redemption) ? result.redemption : [result.redemption];
            for(var i=0; i<$scope.couponList.length; i++) {
              if ($scope.couponList[i].coupon_code.length && $scope.couponList[i].state == 'active') {
                api.validateCoupon($scope.couponList[i].coupon_code, function(result) {
                  if (result.coupon_code) {
                    var coupon = couponService.prepareCouponFeedback(result);
                    if (!$scope.couponDetails[coupon.coupon_code]) {
                      $scope.couponDetails[coupon.coupon_code] = coupon;
                    } else {
                      if (!$scope.couponDetails[coupon.coupon_code].qty_redeemed) $scope.couponDetails[coupon.coupon_code].qty_redeemed = 2;
                      else $scope.couponDetails[coupon.coupon_code].qty_redeemed += 1;
                    }
                  }
                }, function(err) {
                  console.error(err);
                });
              }
            }
          }
        });
      }
    }
    getAccountCoupons();

    $scope.updateCouponCode = function() {
      couponService.updateCouponCode({coupon_code: $scope.addCoupon.code}, function(coupon, coupon_error) {
        $scope.coupon = null;
        $scope.coupon_error = null;
        if (coupon_error) {
          $scope.coupon_error = coupon_error;
        } else if (coupon) {
          if (coupon.duration === 'forever' || coupon.duration === "temporal" || (coupon.max_redemptions == 1 || coupon.max_redemptions_per_account == 1)) {
            if ($scope.couponDetails[coupon.coupon_code]) {
              $scope.coupon_error = "Coupon has already been redeemed";
              return;
            }
          } else if (coupon.max_redemptions_per_account > 1) {
            if ($scope.couponDetails[coupon.coupon_code] && (
              $scope.couponDetails[coupon.coupon_code].qty_redeemed >= coupon.max_redemptions_per_account
            )
          ) {
              $scope.coupon_error = "Coupon redemption limit reached";
              return;
            }
          }
          $scope.coupon = coupon;
        }
      });
    };

    $scope.applyCoupon = function() {
      var isSubscription = false;
      if ($scope.coupon) {
        if ($scope.coupon.redemption_resource === 'subscription') {
          isSubscription = true;
        }
        $scope.safeApply(function() {
          api.submitCoupon($scope.coupon.coupon_code, isSubscription, function(result) {
            $scope.safeApply(function() {
              getAccountCoupons();
              $scope.addCoupon.code = '';
              $scope.coupon = null;
            });
          },function(err) {
            console.error(err);
          });
        });
      }
    }

    if (plansInfo.plans) {
      plansInfo = plansInfo.plans.concat(enterprisePlansInfo.enterprise);
    } else {
      plansInfo = plansInfo.concat(enterprisePlansInfo.enterprise);
    }
    var plans = subscriptionInfo.getPlansObject(plansInfo);

    if (api.userObject.recurly.collection_method === 'manual') {
      $scope.collectionMethod = 'manual';
    } else {
      $scope.collectionMethod = 'automatic';
    }

    if (subscription.vendor_code.match('annual_')) {
      $scope.subscription_billing_frequency = 'yr';
    } else if (subscription.vendor_code.match('6mos_')) {
      $scope.subscription_billing_frequency = '6 mo';
    } else {
      $scope.subscription_billing_frequency = 'mo';
    }

    if (plans[$scope.subscription.vendor_code]) {
      $scope.subscription_pretty = plans[$scope.subscription.vendor_code].name;
    } else {
      $scope.subscription_pretty = $scope.subscription.vendor_code;
    }

    $scope.account_contact = {};

    if ($scope.subscription.admins === 1 && $scope.subscription.groups === 1 && $scope.subscription.dayparting === 1 && $scope.subscription.alerts === 1 && $scope.subscription.reports === 1 && $scope.subscription.remote === 1) {
      $scope.isEnterprise = true;
    } else {
      $scope.isEnterprise = false;
    }

    $scope.cancelled = false;
    if ($scope.subscription.state === 'trial') {
      api.getCancellation($scope.me.account.custid, function(res){
        if (res.length > 0 && res[res.length-1].cancellationid) {
          $scope.cancelled = true;
          $scope.expiration = moment(api.userObject.subscription.trial_ends_at).format("MMMM Do, YYYY");
        }
      }, function(err) {
        console.error("Failed to retrieve cancellation information for trial in adminBillingCtrl", err);
      });
    }
    else if (api.userObject.recurly.state === 'canceled' || api.userObject.recurly.state === 'expired') {
      $scope.cancelled = true;
      $scope.expiration = moment(api.userObject.recurly.expires_at._).format("MMMM Do, YYYY");
    }

    if ($scope.subscription.vendor_code === 'enterprise_professional') $scope.topSub = true;
    if (/disc*/i.test($scope.subscription.vendor_code)) {
      $scope.hasDiscount = true;
    }
    api.getAccount($scope.me.account.custid, function(data) {
      $scope.account_contact = data.account;
    });

    $scope.showAdmins = $scope.$parent.showAdmins;

    $scope.$parent.topTitle = 'Account Settings';

    $scope.showUpdateCardForm = function() {
      $scope.$emit('showCardUpdateForm');
    };

    $scope.$on('refreshBillingCtrlPayment', function() {
      $scope.subscription = api.userObject.subscription;
    });

    $scope.privatize = function() {
      var message = "This will hide your payment information and you will need to contact support to change billing information afterwards.";
      confirmationDialog($scope,message,function(){
        $scope.account_contact.has_private_billing = true;
        api.privatizeRequest($scope.me.account.custid, $scope.account_contact, function(result) {
          $location.path('/admin/billing');
        });
      });
    };

    $scope.setManualBilling = function() {
      var message = "Would you like to switch to manual billing?";
      confirmationDialog($scope,message,function(){
        $scope.account_contact.manual_bill = true;
        api.setManualBilling($scope.me.account.custid,$scope.account_contact, function(result) {
          $scope.showSuccess('Your request to update your payment method to manual billing has been received. You will receive an email within 24 hours for confirmation.');
          $scope.collectionMethod = "manual";
        });
      });
    };

    $scope.downloadPdf = function (invoice) {
      invoice.isLoading = true;

      api.downloadInvoicePdf(invoice.invoiceNumber)
        .then(function (objectUrl) {
          var fileLink = document.createElement('a');
          fileLink.href = objectUrl;
          fileLink.download = 'CCM_Invoice_' + invoice.invoiceNumber + '.pdf';
          fileLink.click();
        })
        .catch(function() {
          $scope.showError('Unable to download invoice #' + invoice.invoiceNumber + ' at this time. Please try again in a few hours.');
        })
        .finally(function () {
          invoice.isLoading = false;
        });
    };

    $scope.openInvoiceUrl = function(invoice) {
      invoice.isLoading = true;

      api.getHostedToken(invoice.invoiceNumber)
        .then(function (token) {
          var invoiceUrl = 'https://' + ENV.recurly + '.recurly.com/account/invoices/' + invoice.invoiceNumber + '?ht=' + token;
          $window.open(invoiceUrl);
        })
        .catch(function () {
          $scope.showError('Unable to capture payment at this time. Please try again in a few hours.');
        })
        .finally(function () {
          invoice.isLoading = false;
        });
    };
  }
]);
app.controller('OrderDeviceCtrl', ['$scope', 'api', 'users', 'account', '$modal', 'confirmationDialog', 'subscriptionInfo', 'shippingRates', 'boxOrderService', '$anchorScroll', '$location', 'ENV',
  function($scope, api, users, account, $modal, confirmationDialog, subscriptionInfo, shippingRates, boxOrderService, $anchorScroll, $location, ENV) {
    $scope.$parent.currentTab = 'orderdevice';
    $scope.$parent.hideLoader();
    $scope.statesProvinces = window.statesProvinces;
    $scope.account = account.account;
    $scope.users = users.users;
    $scope.shippingRates = shippingRates.shippingRates.map(function(item) { item.value = parseFloat(item.value); return item; });
    $scope.selectedRate = { choice: 0 }; // needs to be an object for ng-model to work in the view
    $scope.formdata = {};
    $scope.shipTo = {
      corporate: false,
      dest: ''
    };
    $scope.isDisabled = false;
    $scope.streams = [];
    $scope.selectedStream = null;
    $scope.tax = 0;
    $scope.cloudBoxPrice = boxOrderService.formatCloudBoxPrice();
    $scope.continentalShipping = true;
    if ($scope.account.recurly && $scope.account.manual_bill) {
      $scope.hasManualBilling = true;
    } else {
      $scope.hasManualBilling = false;
    }
    var user = api.userObject;

    $scope.subscriptionInfo = subscriptionInfo.getPaymentStatus();
    $scope.isTrial = user.subscription.state === 'trial';

    $scope.years = [];
    var d = new Date();
    for (var i=0;i<5;i++) {
      $scope.years[i] = d.getFullYear()+i;
    }

    // opens trial-conversion form directive in account.html for submitting billing info
    $scope.showBillingForm = function() {
      $scope.$emit('showBillingForm');
    };

    $scope.getUser = function(selectedUser) {
      if (selectedUser) {
        // Fetch streams for this user
        api.getStreamsForUser(selectedUser.userid, function(streams) {
          $scope.streams = streams.streams;
          if (streams.streams && streams.streams.length == 1 ) {
            $scope.selectedStream = streams.streams[0];
          }
        }, function(err) {
          console.error('There was an error fetching streams for this user: ' + err);
        });
      } else {
        $scope.streams = [];
        $scope.selectedStream = null;
      }
    };

    var clearForm = function() {
      $scope.orderDevice.$setPristine();
      $scope.selectedUser = {};
      $scope.selectedStream = {};
      $scope.terms_checkbox = false;
      $scope.prop65_checkbox = false;
      $scope.isDisabled = false;
      $scope.formdata = {};
      $scope.tax = 0;
      api.getUsers(1, function(result) {
        $scope.users = result.users;
      }, function(err) {
        console.error('Error fetching users');
      });
    };

    $scope.checkDisabled = function() {
      return !$scope.selectedUser || !$scope.selectedUser.username || $scope.orderDevice.$invalid || !$scope.selectedRate || $scope.isDisabled;
    };


    var submitOrder = function(selectedUser, selectedStream) {
      var shippingAddress = boxOrderService.generateAddress($scope.selectedUser, $scope.shipTo.corporate, $scope.account);
      $scope.formdata = selectedUser;
      $scope.formdata.accountEmail = $scope.account.email;
      $scope.formdata.account = $scope.account.name;
      $scope.formdata.status = 1;
      $scope.formdata.address = shippingAddress.street;
      $scope.formdata.address2 = shippingAddress.street2;
      $scope.formdata.city = shippingAddress.city;
      $scope.formdata.state = shippingAddress.state;
      $scope.formdata.zipcode = shippingAddress.zipcode;
      $scope.formdata.phone = shippingAddress.phone;
      $scope.formdata.streamid = selectedStream ? selectedStream.streamid : null;
      $scope.formdata.streamname = selectedStream ? selectedStream.streamname : ''; // for the email
      $scope.formdata.shipping_rate = $scope.shippingRates[$scope.selectedRate.choice].value;
      $scope.formdata.shipping_type = $scope.shippingRates[$scope.selectedRate.choice].name;
      $scope.formdata.tax_amount = $scope.tax;
      $scope.formdata.terms_checked = $scope.terms_checkbox;
      $scope.formdata.prop65_checked = $scope.showProp65 ? $scope.prop65_checkbox : false;

      api.createBoxOrder($scope.formdata).then(function() {
        confirmationDialog({hideCancelBtn: true}, 'Thank you for ordering a CloudBox. You will receive an email confirmation shortly.', function() {
          return;
        });
        clearForm();
      }, function(err) {
        confirmationDialog({hideCancelBtn: true}, 'There was an issue ordering the CloudBox. Please try again. If the issue persists, please contact Cloud Cover Music Support.', function() {
          console.error(err);
          $scope.isDisabled = false;
          return;
        });
      });
    };

    $scope.submit = function(selectedUser, selectedStream) {
      if (!$scope.subscriptionInfo.hasPayment && !$scope.hasManualBilling) {
        var message = "Please add your credit card information to order a CloudBox. Thank you!";
        confirmationDialog({hideCancelBtn: true}, message, function() {
          $location.hash('billingBtn');
          $anchorScroll();
          return;
        });
      } else {
        $scope.isDisabled = true;
        submitOrder(selectedUser, selectedStream);
      }
    };

    var checkContinentalShipping = function(shippingAddress) {
      boxOrderService.checkContinentalShipping(shippingAddress.state, function(continentalShipping, shippingDest) {
        $scope.continentalShipping = continentalShipping;
        $scope.shipTo.dest = shippingDest;
        if (!$scope.continentalShipping) {
          $scope.selectedRate.choice = 2;
        } else {
          $scope.selectedRate.choice = 0;
        }
      });
    };

    $scope.confirmNextDayShipping = function() {
      return boxOrderService.confirmNextDayShipping();
    };

    $scope.calculateTotal = function() {
      return $scope.shippingRates[$scope.selectedRate.choice].value + $scope.cloudBoxPrice + $scope.tax;
    };

    $scope.calculateTax = function() {
      var shippingAddress = boxOrderService.generateAddress($scope.selectedUser, $scope.shipTo.corporate, $scope.account);
      if (!shippingAddress.zipcode || shippingAddress.zipcode.length < 5 || !shippingAddress.state) {
        $scope.tax = 0;
        $scope.isDisabled = true;
        return;
      }
      checkContinentalShipping(shippingAddress);
      boxOrderService.calculateTax(shippingAddress, $scope.cloudBoxPrice).then(function(result) {
        $scope.isDisabled = false;
        $scope.tax = result.tax.amount_to_collect;
        $scope.invalidInput = false;
      }, function(err) {
        $scope.tax = 0;
        if (err.status === 400 && err.data) {
          $scope.invalidInput = true;
          $scope.isDisabled = true;
        } else {
          $scope.isDisabled = false;
        }

        $scope.showWarning("There is an issue with the address for this order, please verify the information is correct and try again.");
      });
    };

    $scope.calculateProp65 = function () {
      var shippingAddress = boxOrderService.generateAddress($scope.selectedUser, $scope.shipTo.corporate, $scope.account);
      if(ENV.featureFlags.prop65 && shippingAddress.state === 'CA') {
        $scope.showProp65 = true;
      } else {
        $scope.showProp65 = false;
      }
    };
  }
]);
(function (angular, moment, app) {
  app.controller('AdminReportsController', AdminReportsController);

  AdminReportsController.$inject = ['$q', '$scope', 'api', 'recurringReports', 'reportingService', 'subscriptionInfo', 'userNotificationService'];

  function AdminReportsController($q, $scope, api, recurringReports, reportingService, subscriptionInfo, userNotificationService) {
    var vm = this;

    $scope.$parent.currentTab = 'reports';
    $scope.$parent.hideLoader();

    var currentTimezone = moment.tz.guess();

    var timezones = angular.copy(window.timeZones);
    timezones.unshift(currentTimezone);

    var recurringReportFrequencies = ['daily', 'weekly'];

    // Properties
    vm.currentTimezone = currentTimezone;
    vm.dateRangeOptions = [
      { name: 'Today', value: 0 },
      { name: 'Yesterday', value: 1 },
      { name: '7 days ago', value: 7 },
      { name: '1st of the month', value: 'month' },
      { name: '30 days ago', value: 30 },
    ];
    vm.entStatus = subscriptionInfo.getEnterpriseStatus();
    vm.form = {
      timezone: timezones[0],
      reports: {
        locationsAdded: {
          reportId: 'locations-added',
          name: 'Locations Added',
          recurring: {
            daily: {
              active: false,
              recipients: []
            },
            weekly: {
              active: false,
              recipients: []
            }
          }
        },
        message: {
          reportId: 'message',
          name: 'Detailed Message Plays',
          recurring: {
            daily: {
              active: false,
              recipients: []
            },
            weekly: {
              active: false,
              recipients: []
            }
          }
        },
        streaming: {
          reportId: 'streaming',
          name: 'Detailed Streaming Hours',
          recurring: {
            daily: {
              active: false,
              recipients: []
            },
            weekly: {
              active: false,
              recipients: []
            }
          }
        },
        streamStatus: {
          reportId: 'stream-status',
          name: 'Location Status',
          recurring: {
            daily: {
              active: false,
              recipients: []
            },
            weekly: {
              active: false,
              recipients: []
            }
          }
        },
        currentActivity: {
          reportId: 'current-activity',
          name: 'Current Activity',
          recurring: {
            daily: {
              active: false,
              recipients: []
            }
          }
        }
      }
    };
    vm.locations = undefined;
    vm.me = api.userObject;
    vm.recurringReports = recurringReports;
    vm.reports = {
      locationsAdded: {
        loading: false,
        submitted: false
      },
      message: {
        loading: false,
        submitted: false
      },
      streaming: {
        loading: false,
        submitted: false
      },
      streamStatus: {
        loading: false,
        submitted: false
      },
      currentActivity: {
        loading: false,
        submitted: false
      }
    };
    vm.timezones = timezones;

    // Special date range options for the Locations Added report. We don't want the other reports to go this far back.
    vm.extendedDateRangeOptions = vm.dateRangeOptions.slice(0);
    vm.extendedDateRangeOptions.push({ name: 'Two months ago', value: 60 });
    vm.extendedDateRangeOptions.push({ name: 'Three months ago', value: 90 });

    // Selected options per report
    vm.selectedDateRange = [vm.dateRangeOptions[0], vm.dateRangeOptions[0], vm.dateRangeOptions[0], vm.dateRangeOptions[0], null];
    vm.selectedLocations = [ [], [], [], [], [] ]; // array of location names per report
    vm.locationOptions = ['all', 'all', 'all', 'all', 'all'];
    vm.selectedFilter = '0'; // only applies to the Locations report

    // Methods
    vm.addRecipient = addRecipient;
    vm.generateLocationsAddedReport = generateLocationsAddedReport;
    vm.generateCurrentActivityReport = generateCurrentActivityReport;
    vm.generateMessageReport = generateMessageReport;
    vm.generateStreamingReport = generateStreamingReport;
    vm.generateStreamStatusReport = generateStreamStatusReport;
    vm.removeRecipient = removeRecipient;
    vm.resetReportSubmitted = resetReportSubmitted;
    vm.updateRecurringReport = updateRecurringReport;

    // Startup
    init();

    function init() {
      initRecurringReports();

      api.getLocsWithStreamCounts(api.userObject.user.custid)
        .then(function (locationData) {
          vm.locations = locationData.locations;
        });
    }

    function initRecurringReports() {
      recurringReports.forEach(function (r) {
        var report;

        if (r.reportType === 1) {
          report = vm.form.reports.locationsAdded;
        } else if (r.reportType === 2) {
          report = vm.form.reports.message;
        } else if (r.reportType === 3) {
          report = vm.form.reports.streamStatus;
        } else if (r.reportType === 4) {
          report = vm.form.reports.streaming;
        } else if (r.reportType === 6) {
          report = vm.form.reports.currentActivity;
        }

        if (report) {
          var freqStr;
          if (r.frequency === 1) {
            freqStr = 'daily';
          } else if (r.frequency === 2) {
            freqStr = 'weekly';
          }

          if (report.recurring[freqStr]) {
            report.recurring[freqStr].id = r.id;
            report.recurring[freqStr].active = r.active;
          }

          if (r.recipients) {
            report.recurring[freqStr].recipients = r.recipients;
          }
        }
      });
    }

    function generateLocationsAddedReport() {
      if (vm.selectedDateRange[1].value === 'month') {
        vm.startDate = moment().startOf('month').format('YYYY-MM-DD');
      } else {
        vm.startDate = moment().subtract(vm.selectedDateRange[1].value, 'days').format('YYYY-MM-DD');
      }

      var usernames;
      if (vm.locationOptions[1] === 'select' && vm.selectedLocations[1].length) {
        usernames = vm.locations
          .filter(function (loc) {
            return vm.selectedLocations[1].indexOf(loc.username) !== -1;
          })
          .map(function (loc) {
            return loc.username;
          });
      }

      var now = moment().add(1, 'days').format('YYYY-MM-DD');
      var options = {
        startAt: vm.startDate,
        endAt: now,
        timezone: vm.form.timezone,
        usernames: usernames
      };

      vm.reports.locationsAdded.loading = true;
      reportingService.generateLocationsAddedReport(options)
        .then(function () {
          vm.reports.locationsAdded.submitted = true;
          userNotificationService.addSuccessMessage('The report is being generated. You will receive an email at <strong>' + vm.me.user.email + '</strong> when the report is available for download.');
        })
        .catch(function () {
          vm.reports.locationsAdded.submitted = true;
          userNotificationService.addErrorMessage('An error occurred while generating the report.');
        })
        .finally(function () {
          vm.reports.locationsAdded.loading = false;
        });
    }

    function generateCurrentActivityReport() {
      var usernames;
      if (vm.locationOptions[4] === 'select' && vm.selectedLocations[4].length) {
        usernames = vm.locations
          .filter(function (loc) {
            return vm.selectedLocations[4].indexOf(loc.username) !== -1;
          })
          .map(function (loc) {
            return loc.username;
          });
      }

      var options = {
        timezone: vm.form.timezone,
        usernames: usernames
      }

      vm.reports.currentActivity.loading = true;
      reportingService.generateCurrentActivityReport(options)
        .then(function () {
          vm.reports.currentActivity.submitted = true;
          userNotificationService.addSuccessMessage('The report is being generated. You will receive an email at <strong>' + vm.me.user.email + '</strong> when the report is available for download.');
        })
        .catch(function () {
          vm.reports.currentActivity.submitted = true;
          userNotificationService.addErrorMessage('An error occurred while generating the report.');
        })
        .finally(function () {
          vm.reports.currentActivity.loading = false;
        });
    }

    function generateMessageReport() {
      if (vm.selectedDateRange[3].value === 'month') {
        vm.startDate = moment().startOf('month').format('YYYY-MM-DD');
      } else {
        vm.startDate = moment().subtract(vm.selectedDateRange[3].value, 'days').format('YYYY-MM-DD');
      }

      var usernames;
      if (vm.locationOptions[3] === 'select' && vm.selectedLocations[3].length) {
        usernames = vm.locations
          .filter(function (loc) {
            return vm.selectedLocations[3].indexOf(loc.username) !== -1;
          })
          .map(function (loc) {
            return loc.username;
          });
      }

      var options = {
        startAt: vm.startDate,
        timezone: vm.form.timezone,
        usernames: usernames
      };

      vm.reports.message.loading = true;
      reportingService.generateMessageReport(options)
        .then(function () {
          vm.reports.message.submitted = true;
          userNotificationService.addSuccessMessage('The report is being generated. You will receive an email at <strong>' + vm.me.user.email + '</strong> when the report is available for download.');
        })
        .catch(function () {
          vm.reports.message.submitted = true;
          userNotificationService.addErrorMessage('An error occurred while generating the report.');
        })
        .finally(function () {
          vm.reports.message.loading = false;
        });
    }

    function generateStreamingReport() {
      if (vm.selectedDateRange[2].value === 'month') {
        vm.startDate = moment().startOf('month').format('YYYY-MM-DD');
      } else {
        vm.startDate = moment().subtract(vm.selectedDateRange[2].value, 'days').format('YYYY-MM-DD');
      }

      var userIds;
      if (vm.locationOptions[2] === 'select' && vm.selectedLocations[2].length) {
        userIds = vm.locations
          .filter(function (loc) {
            return vm.selectedLocations[2].indexOf(loc.username) !== -1;
          })
          .map(function (loc) {
            return loc.userid;
          });
      }

      var now = moment().add(1, 'days').format('YYYY-MM-DD');
      var options = {
        startAt: vm.startDate,
        endAt: now,
        timezone: vm.form.timezone,
        userIds: userIds
      };

      vm.reports.streaming.loading = true;
      reportingService.generateStreamingReport(options)
        .then(function () {
          vm.reports.streaming.submitted = true;
          userNotificationService.addSuccessMessage('The report is being generated. You will receive an email at <strong>' + vm.me.user.email + '</strong> when the report is available for download.');
        })
        .catch(function () {
          vm.reports.streaming.submitted = true;
          userNotificationService.addErrorMessage('An error occurred while generating the report.');
        })
        .finally(function () {
          vm.reports.streaming.loading = false;
        });
    }

    function generateStreamStatusReport() {
      if (vm.selectedDateRange[0].value === 'month') {
        vm.startDate = moment().startOf('month').format('YYYY-MM-DD');
      } else {
        vm.startDate = moment().subtract(vm.selectedDateRange[0].value, 'days').format('YYYY-MM-DD');
      }

      var usernames;
      if (vm.locationOptions[0] === 'select' && vm.selectedLocations[0].length) {
        usernames = vm.locations
          .filter(function (loc) {
            return vm.selectedLocations[0].indexOf(loc.username) !== -1;
          })
          .map(function (loc) {
            return loc.username;
          });
      }

      var status;
      if (vm.selectedFilter === '1' || vm.selectedFilter === '2') {
        status = 'active';
        if (vm.selectedFilter === '2') {
          status = 'inactive';
        }
      }

      var now = moment().add(1, 'days').format('YYYY-MM-DD');
      var options = {
        startAt: vm.startDate,
        endAt: now,
        timezone: vm.form.timezone,
        usernames: usernames,
        status: status
      };

      vm.reports.streamStatus.loading = true;
      reportingService.generateStreamStatusReport(options)
        .then(function () {
          vm.reports.streamStatus.submitted = true;
          userNotificationService.addSuccessMessage('The report is being generated. You will receive an email at <strong>' + vm.me.user.email + '</strong> when the report is available for download.');
        })
        .catch(function () {
          vm.reports.streamStatus.submitted = false;
          userNotificationService.addErrorMessage('An error occurred while generating the report.');
        })
        .finally(function () {
          vm.reports.streamStatus.loading = false;
        });
    }

    function resetReportSubmitted(reportId) {
      var report = vm.reports[reportId];
      if (report) {
        report.submitted = false;
      }
    }

    function addRecipient(reportId, frequency, formController) {
      if (vm.form.reports[reportId].recurring[frequency].recipients.length >= 4) {
        return;
      }

      vm.form.reports[reportId].recurring[frequency].recipients.push('');
      formController.$setDirty();
    }

    function removeRecipient(reportId, frequency, index, formController) {
      vm.form.reports[reportId].recurring[frequency].recipients.splice(index, 1);
      formController.$setDirty();
    }

    function updateRecurringReport(reportId, formController) {
      if (formController.$invalid) {
        return;
      }

      var report = vm.form.reports[reportId];
      var promises = [];

      recurringReportFrequencies.forEach(function (freq) {
        // 2021-03-30 rporczak -- Not all reports support all frequencies. Better to keep data meaningful and
        //  skip over unsupported frequencies, e.g. Current Activity weekly report.
        if (report.recurring[freq]) {

          var isEnabled = report.recurring[freq].active;
          var recipients = isEnabled ? report.recurring[freq].recipients : [];

          var promise;
          if (isEnabled) {
            promise = reportingService.enableRecurringReport(api.userObject.user.userid, report.reportId, freq, recipients);
          } else {
            promise = reportingService.disableRecurringReport(api.userObject.user.userid, report.reportId, freq, recipients);
          }

          promises.push(promise);
        }
      });

      $q.all(promises)
        .then(function () {
          userNotificationService.addSuccessMessage('Your changes for the automated <strong>' + report.name + '</strong> report have been saved.');
        })
        .catch(function () {
          userNotificationService.addErrorMessage('There was a problem saving your changes for the automated <strong>' + report.name + '</strong> report.');
        })
        .finally(function () {
          formController.$setPristine();
        });
    }
  }

})(window.angular, window.moment, app);

(function (angular, app) {
  app.controller('AdminStreamHistoryController', AdminStreamHistoryController);

  AdminStreamHistoryController.$inject = ['$scope', 'streamed', 'subscriptionInfo', 'api', '$interval', 'deviceCommand', 'intercom', 'me', 'refresher', 'streams', 'streamUpdateService'];

  function AdminStreamHistoryController($scope, streamed, subscriptionInfo, api, $interval, deviceCommand, intercom, me, refresher, streams, streamUpdateService) {
    var digitFormatter = function(value) {
      return value < 10 ? '0' + value : value;
    };
    var currentStreamHistory = streamed;
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.pageSize = 15;
    $scope.query = '';
    $scope.$parent.currentTab = 'streamhistory';
    $scope.streams = streams;
    $scope.stream = {
      streamid: api.userObject.streamid
    };

    // 2/15/18 RK: to avoid delay in view where filter will be empty when switching zones,
    // we need this extra variable which is set only once new data is ready
    $scope.filteredStream = {
      streamid: api.userObject.streamid
    };

    var mapMusic = function (music) {
      var streamedMusic = music.songs
        .filter(function (song) {
          return song.mediaType !== 'Message';
        });

      $scope.streamed = streamedMusic
        .map(function (song) {
          var date = new Date(song.timestamp.ts * 1000),
              month = digitFormatter(date.getMonth() + 1),
              day = digitFormatter(date.getDate()),
              hour = date.getHours();
          var meridian = digitFormatter(hour) < 12 ? 'AM' : 'PM';
          var min = digitFormatter(date.getMinutes());
          hour = hour < 13 ? digitFormatter(hour) : digitFormatter(hour - 12);
          song.timestamp.date = month + '-' + day + '-' + date.getFullYear();
          song.timestamp.time = hour + ':' + min + ' ' + meridian;
          song.album.thumb_url = song.album.thumb_url.replace('http:', 'https:');

          return song;
        });
    };

    var updateMusic = function(streamid, callback) {
      api.getStreamHistory(streamid, 50)
        .then(function (fetchedHistory) {
          if (fetchedHistory.songs.length) {
            if (
              !(currentStreamHistory.songs && currentStreamHistory.songs.length) ||
              $scope.filteredStream.streamid !== streamid ||
              fetchedHistory.songs[0].mediaid !== currentStreamHistory.songs[0].mediaid
            ) {
              currentStreamHistory = fetchedHistory;
              mapMusic(fetchedHistory);
              refresher.cancelTimer();
            }
          } else {
            currentStreamHistory = fetchedHistory;
            $scope.streamed = [];
          }
          if (callback) callback(fetchedHistory.songs);
        });
    };

    if ($scope.stream.streamid) {
      mapMusic(streamed);
    } else {
      $scope.$watch(function() {
        return streamUpdateService.getSelectedStream();
      }, function(stream) {
        if (stream && stream.streamid) {
          $scope.stream.streamid = stream.streamid;
          $scope.filteredStream.streamid = stream.streamid;
          api.getStreamHistory(stream.streamid, 50)
            .then(function (result) {
              streamed = result;
              mapMusic(streamed);
            });
        }
      })
    }

    $scope.getStreamHistory = function(streamid) {
      updateMusic(streamid, function() {
        $scope.stream.streamid = streamid;
        $scope.filteredStream.streamid = streamid;
      });
    };

    $scope.search = function () {
      return function (item) {
        return $scope.query == ''
          || (item.username && item.username.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.song && item.song.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.artist && item.artist.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.album.name && item.album.name.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.streamname && item.streamname.toLowerCase().indexOf($scope.query.toLowerCase()) > -1)
          || (item.station && item.station.toLowerCase().indexOf($scope.query.toLowerCase()) > -1);
      };
    };

    var refreshSongsInterval = $interval(function() {
      updateMusic($scope.filteredStream.streamid, null);
    }, 180000); // 3 min

    $scope.$on('$destroy', function() {
      $interval.cancel(refreshSongsInterval);
    });

    $scope.previewSong = function($event, song) {
      return $scope.pushMedia({
        id: song.mediaid,
        name: song.song,
        description: 'song preview',
        mediaType: 'song',
        mediaUrl: song.uri.mp4
      });
    };

    $scope.$on('$locationChangeSuccess', function() {
      if ($scope.interruptMedia && $scope.interruptMedia.description === 'song preview') {
        $scope.interruptMedia.scope.playNextMedia();
      }
    });

    $scope.toggleSongLike = function (song) {
      song.liked ? $scope.deleteSongLike(song) : $scope.createSongLike(song);
    };

    $scope.createSongLike = function (song) {
      $scope.isMediaLikeRequestActive = true;
      song.liked = true;

      api.createMediaLike(api.userObject.user.userid, song.mediaid, song.stationid)
        .catch(function () {
          song.liked = false;
          $scope.showWarning('There was a problem liking this song.');
        })
        .finally(function () {
          $scope.isMediaLikeRequestActive = false;
        });
    };

    $scope.deleteSongLike = function (song) {
      $scope.isMediaLikeRequestActive = true;
      song.liked = false;

      api
        .deleteMediaLike(api.userObject.user.userid, song.mediaid, song.stationid)
        .catch(function () {
          song.liked = true;
          $scope.showWarning('There was a problem unliking this song.');
        })
        .finally(function () {
          $scope.isMediaLikeRequestActive = false;
        });
    };

    $scope.removeSong = function (song, index) {
      var removedSong = {
        reason: 'DontLikeSong',
        mediaid: song.mediaid,
        userid: api.userObject.user.userid
      };
      var intercomEventData = {
        'Name': song.song,
        'Description': song.artist + ' / ' + song.album.name,
        'Artist': song.artist,
        'Station': song.station,
        'Reason': removedSong.reason,
        'Media ID': song.mediaid
      };

      song.removeActive = true;
      api.removeSong(removedSong, function (result) {
        intercom.sendEvent('Removed song', intercomEventData);

        if ($scope.currentMedia && removedSong.mediaid === $scope.currentMedia.mediaid) {
          $scope.skipDevice(song, index);
        } else {
          updateMusic($scope.filteredStream.streamid, function (newList) {
            if (newList[1] && (newList[1].mediaid === song.mediaid)) {
              $scope.skipDevice(song, index);
            }
          });
        }

        song.removeid = result.removeid;
        song.userid = api.userObject.user.userid;
      }, function () {
        intercom.sendEvent('Remove song failed', intercomEventData);
        song.removeActive = false;
        $scope.showWarning('There was a problem removing this song.');
      });
    };

    /*
     * Looks like this method isn't used anywhere in Tune -fmadden 02/14/20
     */
    $scope.restore = function(song) {
      api.restoreRemoved(song, function() {
        song.userid = null;
        song.removeActive = false;
      }, function() {
        $scope.showError('There was a problem restoring this song.');
      });
    };

    $scope.skipDevice = function(device, index) {
      var selectedStream = streamUpdateService.getSelectedStream();
      if (index === 0) {
        if (!device.userid) {
          device.userid = api.userObject.user.userid;
          device.custid = api.userObject.user.custid;
        }
        if (selectedStream.streamid === device.streamid && me.active_player) {
          $scope.skipSong();
        } else {
          device.type = device.deviceType;
          deviceCommand.skipDevice(device, function(message) {
            if (message.successMessage) $scope.showSuccess(message.successMessage);
            if (message.errMessage) $scope.showWarning(message.errMessage);
          });
        }
        var timerOptions = {
          counter: 11,
          interval: 1000
        };
        refresher.refresh(function() {
          updateMusic($scope.filteredStream.streamid,null);
        }, timerOptions);
      }
    };
  }

})(window.angular, app);

app.controller('AdminCtrl', ['$rootScope', '$scope', '$state', 'api', 'subscriptionInfo',
  function ($rootScope, $scope, $state, api, subscriptionInfo) {
    $scope.dataReady = true;
    // $scope.subscription = subscription;
    $scope.$root = $rootScope;
    $scope.currentTab = '';
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.currentNavState = null;

    $scope.hideLoader = function () {
      $rootScope.loadingContent = false;
    };

    $scope.showLoader = function () {
      $rootScope.loadingContent = true;
    };

    $scope.activeLink = function (linked) {
      if (linked === $scope.currentTab) {
        return 'active-link';
      }
      return false;
    };

    $scope.toggleMenu = function (ev) {
      if (ev.target.classList.contains('toggle-menu')) {
        $scope.displayMenu = !$scope.displayMenu;
      } else {
        $scope.displayMenu = false;
      }
    };

    init();

    function init() {
      api.getApiVersion()
        .then(function (data) {
          $scope.version = data.version;
        });

      $scope.currentNavState = $state.current.name;

      $rootScope.$on('$stateChangeSuccess', function (event, toState) {
        $scope.currentNavState = toState.name;
      });
    }
  }
]);

app.controller('AdminsCtrl', ['$scope', 'api', 'me', 'admins', '$rootScope',
  function($scope, api, me, admins, $rootScope) {
    $rootScope.loadingContent = false;
    $scope.$parent.currentTab = 'admins';
    $scope.showMessages = $scope.$parent.showMessages;
    $scope.userPage = admins.meta.page;
    $scope.dataReady = true;
    $scope.admins = admins.users.map(function(item) {
      if (item.account_permissions === "00000001"
          || item.account_permissions === "00000003"
          || item.account_permissions === "00000005"
          || item.account_permissions === "00000007"
          || item.account_permissions === "00000009"
          || item.account_permissions === "0000000b"
          || item.account_permissions === "0000000d"
          || item.account_permissions === "0000000f") {
        item.isOwner = true;
      } else  {
        item.isOwner = false;
      }
      return item;
    });

    $scope.pageSize = 20;
    $scope.query = '';
    $scope.orderBy = 'username';
    $scope.search = function () {
      return function (item) {
        return $scope.query == ''
          || (item.username && item.username.toLowerCase().indexOf($scope.query.toLowerCase()) > -1);
      };
    };

    $scope.getUserPage = function(page) {
      api.getAdmins(page, function(result) {
        $scope.userPage = result.meta.page;
        $scope.admins = result.users;
      });
    };
  }
]);

app.controller('RegionsCtrl', ['$scope', 'api', 'groups', 'subscription', 'music', 'messagePresets', 'messageSchedules', 'subscriptionInfo', 'confirmationDialog', 'userInfo',
  function($scope, api, groups, subscription, music, messagePresets, messageSchedules, subscriptionInfo, confirmationDialog, userInfo) {
    $scope.$parent.currentTab = 'regions';
    $scope.showMessages = $scope.$parent.showMessages;
    $scope.$parent.hideLoader();
    $scope.dataReady = true;
    $scope.selectedPreset = -2;
    $scope.selectedLocations = [];
    $scope.selectedStation = -2;
    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'name';
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.isAddingGroup = false;
    $scope.messageQuantityAllowedPerPreset = subscriptionInfo.messageQuantityAllowedPerPreset();
    userInfo.getUserPerms(function(userPerms) {
      $scope.userPerms = userPerms;
    });
    var isEditingGroup = null;
    var selectMusic1;
    var selectPreset1;
    var selectSchedule1;

    var initSelectButtons = function() {
      selectMusic1 = $(".selectMusic1 > select").select2({placeholder: 'Music'});
      selectPreset1 = $(".selectPreset1 > select").select2({placeholder: 'Message Presets'});
      selectSchedule1 = $(".selectSchedule1 > select").select2({placeholder: 'Message Schedules'});
      $('.select2 > select').on('select2:open', function(evt) {
        $(".select2-dropdown").css({'width': '250px', 'min-width': '250px'});
      });
    };

    var resetSelectButtons = function() {
      selectMusic1.val('');
      selectMusic1.select2({placeholder: 'Music'});

      selectPreset1.val('');
      selectPreset1.select2({placeholder: 'Message Presets'});

      selectSchedule1.val('');
      selectSchedule1.select2({placeholder: 'Message Schedules'});
    };

    initSelectButtons();

    userInfo.checkMessagePresetPermission(function(result) {
      $scope.hasMessagePresets = result && subscription.messages;
    });
    userInfo.checkMessageSchedulePermission(function(result) {
      $scope.hasMessageSchedules = result && subscription.messages;
    });

    $scope.search = function () {
      return function (item) {
        return $scope.query == ''
          || (item.name && item.name.toLowerCase().indexOf($scope.query.toLowerCase()) > -1);
      };
    };

    var mapGroup = function(groups) {
      $scope.groups = groups.filter(function(item) {
        return (!item.is_default);
      }).map(function(item) {
        if (music) {
          music.public.concat(music.mix, music.dayparting).forEach(function(music) {
            if (item.music_id === music.musicid && item.music_type === music.type) {
              item.musicName = music.name;
            }
          });
        }
        if (messagePresets) {
          messagePresets.forEach(function(messagePreset) {
            if (item.message_preset === messagePreset.presetid) {
              item.messagePreset = messagePreset.name;
            }
          });
        }
        if (messageSchedules) {
          messageSchedules.forEach(function(messageSchedule) {
            if (item.schedule_id === messageSchedule.scheduleid) {
              item.messageSchedule = messageSchedule.name;
            }
          });
        }
        return item;
      });
    };
    mapGroup(groups.groups);

    $scope.isEditing = function(group) {
      return (isEditingGroup === group.groupid);
    };

    $scope.editingGroup = {name: ''};

    $scope.editGroup = function(group) {
      if (isEditingGroup !== group.groupid) {
        isEditingGroup = group.groupid;
        $scope.editingGroup.name = group.name;
        $scope.isAddingGroup = true;
      }
    };

    $scope.cancelGroup = function(group) {
      if (group.groupid === null) {
        $scope.groups.pop();
      }
      isEditingGroup = null;
      $scope.editingGroup.name = '';
      $scope.isAddingGroup = false;
    };

    $scope.addGroup = function() {
      $scope.isAddingGroup = true;
      $scope.groups.push({
        name: '',
        groupid: null,
        is_default: null,
        message_preset: null,
        music_id: null,
        music_type: null
      });
    };

    $scope.saveGroup = function(group) {
      if (!$scope.editingGroup.name) {
        return $scope.showWarning('The Region must have a name in order to be added');
      } else {
        group.name = $scope.editingGroup.name;
      }
      if (group.groupid) {
        api.editRegion(group, function() {
          $scope.showSuccess('The Region <b>"' + group.name + '"</b> has been updated!');
          api.getGroups(function(result) {
            mapGroup(result.groups);
            $scope.editingGroup.name = '';
          });
        }, function(err) {
          $scope.showWarning('There was an issue updating the region');
        });
      } else {
        api.addRegion(group, function() {
          $scope.showSuccess('The Region <b>"' + group.name + '"</b> has been added!');
          api.getGroups(function(result) {
            mapGroup(result.groups);
            $scope.editingGroup.name = '';
          });
        }, function(err) {
          $scope.showWarning('There was an issue adding this region');
        });
      }
      $scope.isAddingGroup = false;
      isEditingGroup = null;
    };

    $scope.removeGroup = function(group) {
      confirmationDialog($scope, 'Are you sure you want to remove the region: ' + group.name + '?', function() {
        api.removeItem('/groups/' + group.groupid).then(function() {
          $scope.showSuccess( 'Your region <b>"' + group.name + '"</b> has been removed. All zones in this region are no longer assigned to a region.');
          api.getGroups(function(result) {
            mapGroup(result.groups);
          });
        }, function(err) {
          $scope.showWarning('There was an issue removing this region');
        });
      });
    };

    $scope.messagePresets = [{
      presetid: -1,
      name: 'No Message Preset'
    }].concat(messagePresets);

    $scope.messageSchedules = [{
      scheduleid: -1,
      name: 'No Scheduled Messages'
    }].concat(messageSchedules);

    $scope.changeMessagePreset = function () {
      var selectedMessagePreset = $scope.messagePresets
        .find(function (preset) {
          return preset.presetid === $scope.selectedPreset;
        });
      var selectedMessagePresetName = selectedMessagePreset.name;

      api.updateMassGroupMessagePreset({
        groups: $scope.selectedLocations,
        preset_id: $scope.selectedPreset
      }, function () {
        $scope.selectedButton = '';
        $scope.selectedPreset = -2;
        $scope.showSuccess('The message preset has been updated to ' + selectedMessagePresetName + ' at ' + $scope.selectedLocations.length + ' region(s)');
        $scope.selectedLocations = [];
        $scope.toggleAllSelected = false;
        resetSelectButtons();
        api.getGroups(function (result) {
          mapGroup(result.groups);
        });
      },function () {
        $scope.showWarning('There was an issue updating the message preset');
      });
    };

    $scope.changeMessageSchedule = function () {
      var selectedMessageSchedule = $scope.messageSchedules
        .find(function (schedule) {
          return schedule.scheduleid === $scope.selectedSchedule;
        });
      var selectedMessageScheduleName = selectedMessageSchedule.name;

      api.updateMassGroupMessageSchedule({
        groups: $scope.selectedLocations,
        schedule_id: $scope.selectedSchedule
      }, function () {
        $scope.selectedButton = '';
        $scope.selectedSchedule = -2;
        $scope.showSuccess('The message schedule has been updated to ' + selectedMessageScheduleName + ' at ' + $scope.selectedLocations.length + ' region(s)');
        $scope.selectedLocations = [];
        $scope.toggleAllSelected = false;
        resetSelectButtons();
        api.getGroups(function (result) {
          mapGroup(result.groups);
        });
      }, function () {
        $scope.showWarning('There was an error updating the message schedule');
      });
    };

    $scope.availableOptions = [];

    if (music) {
      $scope.music = music;
      if (music.dayparting[0]) {
        music.dayparting.map(function(item) {
          $scope.availableOptions.push({
            value: item.type + '_' + item.daypartingid,
            name: item.name,
            type: '--- Dayparting ---'
          });
        });
      }
      if (music.mix[0]) {
        music.mix.map(function(item) {
          $scope.availableOptions.push({
            value: item.type + '_' + item.mixid,
            name: item.name,
            type: '--- Mix Stations ---'
          });
        });
      }
      if (music.public[0]) {
        music.public.map(function(item) {
          $scope.availableOptions.push({
            value: item.type + '_' + item.playlistid,
            name: item.name,
            type: '--- Stations ---'
          });
        });
      }

      $scope.changeMusic = function () {
        var stationName = $scope.selectedStation.name;
        var data = {
          groups: $scope.selectedLocations,
          music_type: $scope.selectedStation.value.split('_')[0],
          music_id: $scope.selectedStation.value.split('_')[1]
        };

        api.updateMassGroupMusic(data, function () {
          $scope.selectedButton = '';
          $scope.selectedStation = -2;
          $scope.showSuccess('The music selection has been updated to ' + stationName + ' at ' + $scope.selectedLocations.length + ' region(s)');
          $scope.selectedLocations = [];
          $scope.toggleAllSelected = false;
          resetSelectButtons();
          api.getGroups(function (result) {
            mapGroup(result.groups);
          });
        },function () {
          $scope.showWarning('There was an issue updating the music selection');
        });
      };
    }

    $scope.toggleAllSelected = false;

    $scope.toggleAll = function(e) {
      $scope.selectedLocations = [];

      if (!$scope.toggleAllSelected) {
        $scope.groups.forEach(function (item) {
          $scope.selectedLocations.push(item.groupid);
        });
      }

      $scope.toggleAllSelected = !($scope.toggleAllSelected);
    };

    $scope.changeChecked = function(item, e) {
      if (!$scope.entStatus.isEnterprise || item === undefined || e.target.tagName.toLowerCase() === 'a') {
        return;
      }

      var loc = $scope.selectedLocations.indexOf(item);
      if (loc > -1) {
        $scope.selectedLocations.splice(loc, 1);
      } else {
        $scope.selectedLocations.push(item);
      }

      $scope.toggleAllSelected = ($scope.selectedLocations.length == $scope.groups.length);

      if ($scope.selectedLocations.length === 0) {
        $scope.selectedButton = '';
      }
    };

    $scope.selectedButton = '';
    $scope.toggleButton = function(item) {
      if ($scope.selectedButton !== item) {
        $scope.selectedButton = item;
      } else {
        $scope.selectedButton = '';
      }
    };

  }
]);

app.controller('AdminEnterpriseCtrl', ['$scope', function($scope) {
  $scope.$parent.hideLoader();
  $scope.$parent.currentTab = 'enterprise';
}]);

app.controller('AdminMessageUpgradeCtrl', ['$scope', function($scope) {
  $scope.$parent.hideLoader();
  $scope.$parent.currentTab = 'messageUpgrade';
}]);

app.controller('EditAdminContactCtrl', ['$scope', 'api', '$location',
  function($scope, api, $location) {
    $scope.$parent.currentTab = 'billing';
    $scope.$parent.hideLoader();
    $scope.formdata = {};
    $scope.me = api.userObject;

    api.getAccount($scope.me.account.custid, function(data) {
      $scope.formdata = data.account;
    });

    $scope.submit = function() {
      api.editAccount($scope.me.account.custid, $scope.formdata, function(result) {
        $scope.showSuccess( 'The information has been saved!');
        $location.path('/admin/billing');
      }, function(err) {
        $scope.showError("There was an error updating this account.");
      })
    };
  }
]);

app.controller('AdminUpgradeBillingCtrl', ['$scope', '$state', 'api', 'plansInfo', 'enterprisePlansInfo', 'subscription', 'subscriptionInfo', 'confirmationDialog',
  function($scope, $state, api, plansInfo, enterprisePlansInfo, subscription, subscriptionInfo, confirmationDialog) {
    var plans = {};
    $scope.agreement = false;
    $scope.hasSelectedPlan = false;
    $scope.selectedPlan = {};
    var rawSelectedPlan = {};
    $scope.$parent.currentTab = 'billing';
    $scope.$parent.hideLoader();
    $scope.me = api.userObject;
    $scope.account_contact = {};
    $scope.manualCollection = false;

    function ucFirstAllWords(str) {
      var pieces = str.split(" ");
      for (var i = 0; i < pieces.length; i++) {
        var j = pieces[i].charAt(0).toUpperCase();
        pieces[i] = j + pieces[i].substr(1);
      }
      return pieces.join(" ");
    }

    $scope.subscription = subscription;
    $scope.subscription.vendor_code_pretty = $scope.subscription.vendor_code;
    $scope.subscription.vendor_code_pretty = $scope.subscription.vendor_code_pretty.replace(/_/g, ' ');
    $scope.subscription.vendor_code_pretty = ucFirstAllWords($scope.subscription.vendor_code_pretty);

    $scope.currentPlan = {
      name: subscription.vendor_code_pretty,
      price: Number(subscription.unit_amount_in_cents / 100),
      vendor_code: subscription.vendor_code,
      total: Number(subscription.unit_amount_in_cents / 100 * subscription.quantity),
    };
    if (subscription.addonStreams) {
      $scope.addonStreams = {
        price: Number(subscription.addonStreams.unit_amount_in_cents._ / 100),
        quantity: Number(subscription.addonStreams.quantity._),
        total: Number(subscription.addonStreams.unit_amount_in_cents._ / 100 * subscription.addonStreams.quantity._)
      };
    } else {
      $scope.addonStreams = null;
    }

    $scope.annualBilling = false;
    if (subscriptionInfo.checkDiscountOption()) {
      $scope.annualBilling = true;
      subscriptionInfo.clearDiscountOption();
    }
    if (subscription.vendor_code.indexOf("annual") == 0) {
      $scope.currentPlan.annualDiscount=true;
      $scope.currentPlan.billFrequency = 'yr';
      $scope.annualBilling = true;
    }
    else if (subscription.vendor_code.indexOf("6mos") == 0) {
      $scope.currentPlan.sixMonthDiscount=true;
      $scope.currentPlan.billFrequency = '6 mo';
    } else {
      $scope.currentPlan.billFrequency = 'mo';
    }

    $scope.plan = {};
    //----------------------------------------------------------------
    // fmadden - So this makes no sense to me but if you come to this
    // screen from another screen then the plans are defined in plansInfo.
    // However if you refresh this screen, then plans are in plansInfo.plans.
    //
    // ???
    //----------------------------------------------------------------
    if (plansInfo.plans) {
      plansInfo = plansInfo.plans.concat(enterprisePlansInfo.enterprise);
    } else {
      plansInfo = plansInfo.concat(enterprisePlansInfo.enterprise);
    }
    plans = subscriptionInfo.getPlansObject(plansInfo);
    $scope.plan = subscriptionInfo.getPlanOfferings(plans,$scope.annualBilling);
    $scope.currentPlan.name = plans[subscription.vendor_code].name;

    $scope.setUpgradeMonthlyBilling = function() {
      $scope.annualBilling = false;
      setValues($scope);
    }
    $scope.setUpgradeAnnualBilling = function() {
      $scope.annualBilling = true;
      setValues($scope);
    };

    var setValues = function(scope) {
      scope.plan = subscriptionInfo.getPlanOfferings(plans,scope.annualBilling);
    }

    api.getAccount($scope.me.account.custid, function(data) {
      $scope.account_contact = data.account;
    });

    $scope.$parent.topTitle = 'Upgrade Subscription';

    $scope.selectPlan = function(plan) {
      if (
        $scope.addonStreams &&
        (plan.vendor_code === 'standard' || plan.vendor_code === 'annual_standard_10disc') &&
        ($scope.subscription.vendor_code !== 'standard' || $scope.subscription.vendor_code !== 'annual_standard_10disc')
      ) {
        var planName = plan.name;
        if (plan.name.match(/(music)/i)) {
          planName = 'Music';
        }
        confirmationDialog({planName: planName, templateUrl: 'partials/downgrade_modal.html'}, '', function(success) {
          return;
        }, function(reject) {});
      } else {
        rawSelectedPlan = plan;
        $scope.hasSelectedPlan = true;
        calculatePrice();
      }
    };

    $scope.clickBackButton = function () {
      $state.go('account.admin.billing');
    };

    $scope.deselectPlan = function() {
      $scope.hasSelectedPlan = false;
      $scope.selectedPlan = {};
      $scope.agreement = false;
    };

    function calculatePrice() {
      if (rawSelectedPlan) {
        var annualPrice = 0;
        var plan = rawSelectedPlan;
        plan.monthlyPrice = Number(plan.dollar + (plan.change / 100));
        if ($scope.annualBilling) {
          var annualPrice = ((plan.annualPrice / 12)) * 12;
          $scope.annualPrice = annualPrice;
          plan.total = Number(annualPrice * $scope.subscription.quantity);
          plan.billFrequency = 'yr';
        } else {
          plan.total = Number(plan.monthlyPrice * $scope.subscription.quantity);
          plan.billFrequency = 'mo';
        }
        // 3/9/17 RK: keep the custom price if it's set
        if ($scope.addonStreams) {
          if ($scope.addonStreams.price !== plan.addonStreamPrice) {
            if ($scope.currentPlan.billFrequency === plan.billFrequency && plan.addonStreamPrice !== 0) {
              plan.addonStreamPrice = $scope.addonStreams.price;
            }
          }
          plan.addonStreamsTotal = $scope.addonStreams.quantity * plan.addonStreamPrice;
        }
        $scope.selectedPlan = plan;
      }
    }

    function updatingCollectionMethod() {
      var isManualCollection = false;
      if ($scope.me.recurly.collection_method === 'manual') {
        isManualCollection = true;
      }
      // change collection method if downgrading from annual plan to monthly
      if (!$scope.selectedPlan.isDiscount && isManualCollection) {
        return true;
      }
      if (isManualCollection === $scope.manualCollection) {
        return false;
      } else {
        return true;
      }
    }

    function upgradePlan(planData, successMessage) {
      $scope.setSubmitSpinner = true;
      subscriptionInfo.upgradeSubscription(planData, function(subscription) {
        $scope.setSubmitSpinner = false;
        if (subscription.err) {
          $scope.showError('There was an issue changing your plan, please contact support for assistance.');
        } else {
          $scope.showSuccess(successMessage);
          $state.go('account.admin.billing');
        }
      });
    }

    $scope.submitPlan = function() {
      var planData = {};
      if ($scope.agreement) {
        $scope.agreement = false;
        $scope.$parent.showLoader();
        var successMessage = 'Thanks, your subscription has been updated!';
        planData = {
          'plan': $scope.selectedPlan.vendor_code
        };
        if (updatingCollectionMethod()) {
          var collectionMethod = "automatic";
          if (!$scope.selectedPlan.isDiscount) {
            $scope.account_contact.manual_bill = false;
            successMessage = 'Thanks, your subscription has been updated and your payment collection method has been set to automatic. Check payment is only available with 12 month billing.';
          } else {
            $scope.account_contact.manual_bill = $scope.manualCollection;
            if ($scope.manualCollection) {
              collectionMethod = 'manual';
            }
            successMessage = 'Thanks, your subscription has been updated and your payment collection method has been set to ' + collectionMethod + '.';
          }
          api.setManualBilling($scope.me.account.custid, $scope.account_contact, function() {
            upgradePlan(planData, successMessage);
          });
        } else {
          upgradePlan(planData, successMessage);
        }
      } else {
        return $scope.showWarning('Please read and agree to the terms, before changing your subscription.');
      }
    };
  }
]);

app.controller('AdminCancelBillingCtrl', ['$scope', 'api', 'subscription', '$location', '$window', 'intercom',
  function($scope, api, subscription, $location, $window, intercom) {
    $scope.$parent.currentTab = 'billing';
    $scope.$parent.hideLoader();
    $scope.submitDisabled = true;
    $scope.request_reasons = [
      'Closed/Sold Business',
      'CloudBox Issues',
      'Customer Support',
      'Hardware Setup/Compatibility',
      'Music Selection',
      'Music Volume',
      'Music Content (Language)',
      'Price',
      'Seasonal Closure',
      'Software Bugs',
      'Ease of Use'
    ];

    $scope.selected_reason = { reason: '' };
    $scope.$parent.topTitle = 'Cancel Billing';
    $scope.formdata = {
      notes: '',
      reason: '',
      seasonal_reminder: ''
    };

    $scope.days = [];
    $scope.seasonal_month = null;
    $scope.seasonal_day = null;

    $scope.getDays = function () {
      var total;

      switch ($scope.seasonal_month) {
        case '02':
          total = [1, 29];
          break;

        case '04':
        case '06':
        case '09':
        case '11':
          total = [1, 30];
          break;

        default:
          total = [1, 31];
          break;
      }

      $scope.days = [];

      for (var i = total[0]; i <= total[1]; i++) {
        $scope.days.push(i < 10 ? '0' + i : i.toString());
      }
    };

    $scope.getDays();

    var accountDetails = null;
    api.getAccount(api.userObject.account.custid, function(result) {
      accountDetails = result.account;
    });

    $scope.checkButton = function() {
      if (
           !$scope.selected_reason.reason ||
           ($scope.selected_reason.reason === 'Seasonal Closure' && (!$scope.seasonal_month || !$scope.seasonal_day))
         ) {
        $scope.submitDisabled = true;
      }
      else {
        $scope.submitDisabled = false;
      }
    };

    $scope.submit = function() {
      if ($scope.selected_reason.reason == 'Seasonal Closure') {
        // the year doesn't matter since we care about the month and day
        $scope.formdata.seasonal = 1;
        $scope.formdata.seasonal_reminder = (new Date().getFullYear() + 1) + '-' + $scope.seasonal_month + '-' + $scope.seasonal_day;
      }
      else {
        $scope.formdata.seasonal = 0;
        $scope.formdata.seasonal_reminder = null;
      }

      var formdata = {
        vendorid: subscription.vendorid,
        reason: $scope.selected_reason.reason,
        seasonal: $scope.formdata.seasonal,
        seasonal_reminder: $scope.formdata.seasonal_reminder,
        notes: (accountDetails.notes) ? accountDetails.notes + "<br>\n"+$scope.formdata.notes : $scope.formdata.notes,
      }

      api.submitCancellation(formdata, function(result) {
        intercom.sendEvent('Account Cancellation');
        intercom.sendAttributeUpdate(api.userObject.user, {
          "cancellation_reason": formdata.reason,
          "cancellation_is_seasonal": formdata.seasonal,
          "cancellation_seasonal_reminder": formdata.seasonal_reminder,
          "cancellation_notes": formdata.notes
        });
        $scope.showSuccess( 'Your request for cancellation has been received.\n You will receive an email within 24 hours for confirmation.');
        // not sure why leaving out one of the redirects generates an error when billing page loads
        setTimeout(function() {
          $location.path('/admin/billing');
          $window.location.hash = '#/admin/billing';
          $window.location.reload(true);
        }, 2000);
      }, function(err) {
        $scope.showError("Your cancelation was unsuccessful due to a system processing error.  Please contact Customer Support at (844) 422-6249.");
      });
    }
  }
]);

app.controller('AdminPlansCtrl', ['$scope', 'api', '$location', 'plans', 'enterprise',
  function($scope, api, $location, plans, enterprise) {
    $scope.$parent.hideLoader();
    $scope.plans = plans.plans;
    $scope.enterprise = enterprise.enterprise;
  }
]);

app.controller('AddAdminCtrl', ['$scope', '$rootScope', 'api', '$location', 'userInfo', 'groups', 'formEditService',
  function($scope, $rootScope, api, $location, userInfo, groups, formEditService) {
    var userPerms = {};

    userInfo.getUserPerms(function (perms) {
      userPerms = perms;
    });

    $scope.$parent.currentTab = 'admins';
    $scope.$parent.hideLoader();
    // control display of elements in template based on adding or editing
    $scope.isEditing = false;
    $scope.groups = groups.groups;
    $scope.timezones = window.timeZones;
    $scope.formdata = {
      groupid: groups.groups[0].groupid,
      permissions: {
        group: {
          manager: false,
          music: false,
          messages: false
        },
        account: {
          owner: false,
          payment: false,
          music: false,
          message: false
        }
      }
    };

    // check if any permission boxes are checked
    function hasPermissions(account) {
      for (var i in account) {
        if (account[i]) return true;
      }
      return false;
    }

    var confirmLocationSwitch = 'Are you sure? The information will not be saved.';
    $rootScope.confirmLocationSwitch = confirmLocationSwitch;

    $scope.clickBackButton = function() {
      if ($scope.editadmin.$dirty) {
        formEditService.confirmNavigation($scope, true, '/admin/admins', confirmLocationSwitch);
      } else {
        $rootScope.confirmLocationSwitch = false;
        $location.path('/admin/admins');
      }
    };

    $scope.submit = function() {
      if (userPerms.isAccountOwner) {
        if (hasPermissions($scope.formdata.permissions.account)) {
          $rootScope.confirmLocationSwitch = false;
          api.addNewUser($scope.formdata, function(result) {
            $scope.showSuccess( 'The admin has been added to your account.');
            $location.path('/admin/admins');
          }, function(err) {
            $scope.showError('There was an issue adding this Admin.');
            console.error(err.code + ': ' + err.message);
            $rootScope.confirmLocationSwitch = confirmLocationSwitch;
          });
        } else {
          $scope.showWarning('Please assign permissions to create a new Administrator.');
        }
      } else {
        $scope.showWarning("You don't have permission to create an Administrator.");
      }
    };
  }
]);

app.controller('EditAdminCtrl', ['$scope', '$rootScope', 'api', '$location', '$modal', 'userInfo', 'user', 'groups', 'formEditService', 'confirmationDialog',
  function($scope, $rootScope, api, $location, $modal, userInfo, user, groups, formEditService, confirmationDialog) {
    var userPerms = {};

    userInfo.getUserPerms(function (perms) {
      userPerms = perms;
    });

    $scope.$parent.currentTab = 'admins';
    $scope.$parent.hideLoader();
    // control display of elements in template based on adding or editing
    $scope.isEditing = true;
    $scope.groups = groups.groups;
    $scope.timezones = window.timeZones;

    $scope.formdata = user.user;
    $scope.formdata.permissions = user.permissions;

    // check if any permission boxes are checked
    function hasPermissions(account) {
      for (var i in account) {
        if (account[i]) return true;
      }
      return false;
    }

    var confirmLocationSwitch = 'Are you sure? The information will not be saved.';
    $rootScope.confirmLocationSwitch = confirmLocationSwitch;

    $scope.clickBackButton = function() {
      if ($scope.editadmin.$dirty) {
        formEditService.confirmNavigation($scope, true, '/admin/admins', confirmLocationSwitch);
      } else {
        $rootScope.confirmLocationSwitch = false;
        $location.path('/admin/admins');
      }
    };

    $scope.submit = function() {
      if (userPerms.isAccountOwner) {
        if (hasPermissions($scope.formdata.permissions.account)) {
          if (!api.userObject.permissions.admin.superadmin && $scope.formdata.password) {
            openReauthenticateModal($scope.formdata);
          }
          else {
            api.editUser($scope.formdata, $scope.onEditUserSuccess, $scope.onEditUserError);
          }
        } else {
          $scope.showWarning("Please assign permissions to edit this Administrator.");
        }
      } else {
        $scope.showWarning("You don't have permission to edit this Administrator.");
      }
    };
    $scope.onEditUserSuccess = function() {
      $rootScope.confirmLocationSwitch = false;
      $scope.showSuccess( 'The information has been saved!');
      $location.path('/admin/admins');
    };

    $scope.onEditUserError = function(err) {
      $scope.showError('There was an issue editing this Admin.');
      console.error(err.code + ': ' + err.message);
    };

  function openReauthenticateModal(locationData) {
    return $modal
      .open({
        templateUrl: 'partials/reauthenticate_modal.html',
        windowClass: 'reauthenticate-modal',
        controller: ['$modalInstance', 'api', 'locationData',
          function ($modalInstance, api, locationData) {
            var vm = this;

            // Properties
            vm.returnResponse = {};
            locationData.userpassword = "";
            locationData.user_username = api.userObject.user.username;
            vm.locationData = locationData;

            // Methods
            vm.dismiss = dismiss;
            vm.confirmPassword = confirmPassword;
            vm.clearStatus = clearStatus;

            function confirmPassword() {
              api.editUser($scope.formdata, function(result) {
                $modalInstance.close(vm.returnResponse);
                $scope.onEditUserSuccess();
              }, function (err) {
                if (err.message.includes("Invalid user password")) {
                  vm.returnResponse.status = "error";
                } else {
                  vm.returnResponse.status = "error";
                  $modalInstance.close(vm.returnResponse);
                  $scope.onEditUserError(err);
                }
              });
            }
            function clearStatus() {
              vm.returnResponse.status = "";
            }
            function dismiss() {
              $modalInstance.close();
            }
          }
        ],
        controllerAs: 'vm',
        resolve: {
          locationData: function () {
            return locationData;
          }
        }
      })
      .result;
  }

    $scope.removeAdmin = function() {
      var message = 'Are you sure you want to delete this Admin account?';
      if (userPerms.isAccountOwner) {
        confirmationDialog({buttonText: 'Yes'}, message, function() {
          $scope.formdata.permissions.account = {
            owner: false,
            payment: false,
            music: false,
            messages: false
          };
          api.editUser($scope.formdata, function(result) {
            $scope.showSuccess( 'The Administrator has been removed!');
            $rootScope.confirmLocationSwitch = false;
            $location.path('/admin/admins');
          }, function(err) {
            $scope.showError('There was an issue removing this Admin.');
            console.error(err.code + ': ' + err.message);
          });
        }).catch(angular.noop);
      } else {
        $scope.showWarning("You don't have permission to edit this Administrator.");
      }
    };

    $scope.$parent.topTitle = 'Edit Region: ' + $scope.formdata.username;
  }
]);

app.controller('EditAdminCorporateAddressCtrl', ['$scope', 'api', '$location', 'requirements', '$window',
  function($scope, api, $location, requirements, $window) {
    $scope.$parent.currentTab = 'billing';
    $scope.$parent.hideLoader();
    $scope.statesProvinces = window.statesProvinces;
    $scope.countries = window.countries;
    $scope.formdata = {};
    $scope.me = api.userObject;
    $scope.selectedState = '';
    $scope.selectedCountry = '';

    if (requirements.showNotification) {
      $scope.showWarning("The corporate address is needed for license reporting. This must be complete before you can continue.", { ttl: -1 });
    }

    api.getAccount($scope.me.account.custid, function(data) {
      $scope.formdata = data.account;

      if ($scope.formdata.state) {
        $scope.statesProvinces.forEach(function (item) {
          if ($scope.formdata.state.toUpperCase() == item.abbreviation) {
            $scope.selectedState = item;
          }
        });
      }
      if ($scope.formdata.country) {
        $scope.countries.forEach(function (item) {
          if ($scope.formdata.country.toUpperCase() == item.abbreviation) {
            $scope.selectedCountry = item;
          }
        });
      }
    });


    $scope.submit = function() {
      $scope.formdata.state = $scope.selectedState.abbreviation;
      $scope.formdata.country = $scope.selectedCountry.abbreviation;

      api.updateCorporateAddress($scope.me.account.custid, $scope.formdata, function(result) {
        $scope.showSuccess( 'The information has been saved!');
        $scope.$emit('refreshAccountInfo');
        // refresh the account requirements so that they're not outdated
        if (!requirements.loaded || !requirements.cache.HasCorporateAddress) {
          api.checkAccountRequirements($scope.me.account.custid, function (result) {
            requirements.save(result);
            requirements.process(function () {
              $location.path('/admin/billing');
              $window.location.reload(true);
            }, api.userObject);
          });
        }
        else {
          $location.path('/admin/billing');
        }
      });
    };

  }
]);

app.controller('ArtistRadioController', ['$scope', '$rootScope', 'api', 'streamUpdateService', 'musicSelection', 'me',
  function($scope, $rootScope, api, streamUpdateService, musicSelection, me) {
    $scope.$parent.currentTab = 'playlists';
    $scope.$parent.topTitle = 'Music';
    $scope.currentNav = 'artistradio';
    $scope.navType = 'music';
    $scope.allowSearch = true;
    $scope.searchActive = false;

    $scope.pageSize = 50;
    $scope.query = '';
    $scope.orderBy = 'name';
    $scope.reverse = false;

    $scope.userId = me.user.userid;
    $scope.currentStation = '';

    $scope.updateCurrentStation = function (stream) {
      if(stream && stream.music_type === 'pandoraradio') {
        var currentStation = $scope.stations.find(function (station) { return station.Id === stream.music_id; } );
        if(currentStation) {
          $scope.currentStation = currentStation.id;
          return;
        }
      }
      $scope.currentStation = '';
    };

    $scope.onSetSelectedStream = function (stream) {
      $scope.updateCurrentStation(stream);
    };
    streamUpdateService.addListener($scope);

    if (true) {
      $scope.resultsLoading = true;
      api.getArtistRadioStations($scope.userId)
        .then(function (stationsInfo) {
          $scope.stations = stationsInfo.items;
          if (!$scope.stations || !$scope.stations.length) {
            api.getMostLikedArtists($scope.userId)
              .then(function(result) {
                $scope.suggestedArtists = result.items.map(function (artist) {
                  artist.display = artist.name;
                  return artist;
                });
                $scope.resultsLoading = false;
              })
              .catch(function () {
                $scope.resultsLoading = 'error';
              });
          } else {
            $scope.updateCurrentStation(streamUpdateService.getSelectedStream());
            $scope.resultsLoading = false;
          }
        })
        .catch(function () {
          $scope.resultsLoading = 'error';
        });
    } else {
      $scope.resultsLoading = 'error';
    }

    $scope.handleSearch = function() {
      if(this.artistSearch && this.artistSearch !== '') {

        $scope.musicsearch = this.artistSearch;
        $scope.updateSearch();
      }
    };

    $scope.updateSearch = function() {
      var key = $scope.musicsearch;
      $scope.accounts = [];
      if (key && key != '') {
        $scope.searchActive = true;
        $scope.resultsLoading = true;
        api.searchArtist($scope.userId, key)
          .then(function (result) {
            $scope.artists = result.items.map(function (artist) {
              artist.display = artist.name;
              return artist;
            });
            $scope.resultsLoading = false;
          })
          .catch(function () {
            $scope.resultsLoading = 'error';
          });
      } else {
        $scope.cancelSearch();
      }
    };

    $scope.cancelSearch = function() {
      $scope.musicsearch = '';
      $scope.artists = null;
      $scope.searchActive = false;
      $scope.resultsLoading = false;
    };

    $scope.toggleSearch = function() {
      if ($scope.showSearch) {
        $scope.musicsearch = '';
        $scope.showSearch = false;
      } else {
        $scope.showSearch = true;
      }
    };

    $scope.displayArtistInfo = function(artist) {
      $scope.artistInfo = artist;
    };

    $scope.createArtistRadioStation = function(artist) {
      if (artist) {
        api.createArtistRadioStation($scope.userId, artist.id)
          .then(function () {
            $scope.cancelSearch();
            $scope.showSuccess( '<b>"' + artist.name + '"</b> has been added to your Artist Radio collection.');
            $scope.resultsLoading = true;
            api.getArtistRadioStations($scope.userId)
              .then(function (stationsInfo) {
                $scope.stations = stationsInfo.items;
              })
              .finally(function () {
                $scope.resultsLoading = false;
              });
          })
          .catch(function () {
            $scope.showError( 'Unable to add <b>"' + artist.name + '"</b> to your Artist Radio collection.');
          });
      }
    };

    $scope.removeArtistRadioStation = function(station) {
      if (station) {
        api.removeArtistRadioStation($scope.userId, station.Id)
          .then(function () {
            $scope.showSuccess( '<b>"' + station.name + '"</b> has been removed from your Artist Radio collection.');
            $scope.resultsLoading = true;
            api.getArtistRadioStations($scope.userId)
              .then(function (stationsInfo) {
                $scope.stations = stationsInfo.items;
              })
              .finally(function () {
                $scope.resultsLoading = false;
              });
          })
          .catch(function () {
            $scope.showError( 'Unable to remove <b>"' + station.name + '"</b> to your Artist Radio collection.');
          });
      }
    };

    $scope.buildStationArtStyle = function(station) {
      return { 'background-image': 'url(' + station.art[2].url + ')' };
    };

    $scope.toggleMenu = function(ev) {
      if (ev.target.classList.contains('toggle-menu')) {
        $scope.isNavCollapsed = !$scope.isNavCollapsed;
      }
      else {
        $scope.isNavCollapsed = true;
      }
    };


    /*
    These functions will need to be re-integrated once the player component is available
     */


    $scope.$on('resumeMedia', function() {
      $scope.currentStation = '';
    });

    $scope.onFeedback = function(event, data) {
      var feedback = {
        operation: data.value === data.media.feedbackValue ? 'removeFeedback' : 'setFeedback',
        targetId: data.media.id,
        contextId: data.media.media_station_id,
        trackToken: data.media.trackToken,
        value: data.value
      };
      api.postArtistRadioFeedback($scope.userId, feedback)
        .then(function (result) {
          return result;
        });
    };

    $scope.playArtistRadio = function (station, song) {
      $scope.currentStation = station.id;
      console.log('playing track: ', song.track.id, song.track.name);
      return $rootScope.$broadcast('playArtistRadio', {
        id: song.track.id,
        name: song.track.name,
        artist: song.track.artist.name,
        media_name: song.track.name,
        media_station: station.name,
        media_station_id: station.id,
        imageUrl: song.track.art.artUrl,
        description: 'song preview',
        mediaType: 'song',
        mediaUrl: song.audioUrl,
        trackToken: song.trackToken,
        feedbackValue: song.feedbackValue,
        overrideDuration: song.track.duration
      });
    };

    $scope.playNow = function (station) {
      musicSelection.setSelection('pandoraradio', station.Id, station.Name, 'now', function (succeeded, error) {
        console.log('play started');
      });
      // if (station.id) {
      //   api.postArtistRadioStation($scope.userId, station.id, {command: 'play'})
      //     .then(function (result) {
      //       var song = result.setSource.current;
      //       $scope.playArtistRadio(station, song);
      //       $scope.skipIndex = 0;
      //       api.postArtistRadioStation($scope.userId, station.id, {command: 'setStarted', index: $scope.skipIndex });
      //     });
      // }
    };

    // $scope.skip = function (station) {
    //   if (station.id) {
    //     api.postArtistRadioStation($scope.userId, station.id, {command: 'skip', elapsedTime: 10, index: $scope.skipIndex++ })
    //       .then(function (result) {
    //         var song = result.skip.current;
    //         $scope.playArtistRadio(station, song);
    //         api.postArtistRadioStation($scope.userId, station.id, {command: 'setStarted', index: $scope.skipIndex });
    //       });
    //   }
    // };

  }
]);

app.controller('CreateMixStationFromFiltersModal', CreateMixStationFromFiltersModal);

CreateMixStationFromFiltersModal.$inject = ['$modalInstance', 'activeFilters', 'api', 'filteredStations', 'me', 'musicSelection', 'subscriptionInfo', 'userNotificationService', 'userPermissions'];

function CreateMixStationFromFiltersModal($modalInstance, activeFilters, api, filteredStations, me, musicSelection, subscriptionInfo, userNotificationService, userPermissions) {
  var vm = this;

  // Constants
  var CCM_STATION_ART_BASE_URL = 'https://media.cloudcovermusic.com/stationart/';
  var DEFAULT_STATION_FREQ = 100;

  var userCanActivateMixStation = userPermissions.canPlayMusic && userPermissions.canSelectMusic;

  // Properties
  vm.allowRemoveStation = true;
  vm.allowSetGlobal = undefined;
  vm.createMixStationResult = undefined;
  vm.filters = {};
  vm.form = {
    currentStep: 1,
    options: {
      frequency: [
        { value: 10,  name: '1 - Less'  },
        { value: 20,  name: '2'         },
        { value: 30,  name: '3'         },
        { value: 40,  name: '4'         },
        { value: 50,  name: '5'         },
        { value: 60,  name: '6'         },
        { value: 70,  name: '7'         },
        { value: 80,  name: '8'         },
        { value: 90,  name: '9'         },
        { value: 100, name: '10 - More' }
      ]
    }
  };
  vm.formData = {
    isGlobal: 0,
    name: '',
    playlists: undefined
  };
  vm.loading = false;

  // Methods
  vm.activateMixStation = activateMixStation;
  vm.buildStationArtStyle = buildStationArtStyle;
  vm.cancel = cancel;
  vm.removeStation = removeStation;
  vm.save = save;
  vm.skipMixStationActivation = skipMixStationActivation;

  init();

  function init() {
    buildViewModel();
    updateAllowRemoveStation();
    updateAllowSetGlobal();
  }

  // Public methods

  function activateMixStation(playWhen) {
    var selection = {
      musicId: vm.createMixStationResult.mixid,
      musicName: vm.formData.name,
      when: playWhen
    };

    musicSelection.setSelection('mix', selection.musicId, selection.musicName, selection.when, function () {
      me.music_type = 'mix';
      me.music_id = selection.musicId
    });

    $modalInstance.close();
  }

  function buildStationArtStyle(station) {
    return { 'background-image': 'url(' + CCM_STATION_ART_BASE_URL + station.thumb_url + ')' };
  }

  function cancel() {
    $modalInstance.dismiss({ canceled: true });
  }

  function removeStation(stationIndex) {
    vm.formData.playlists.splice(stationIndex, 1);
    updateAllowRemoveStation();
  }

  function save(form) {
    if (form.$invalid) {
      return;
    }

    vm.loading = true;

    if (!vm.allowSetGlobal) {
      vm.formData.isGlobal = 0;
    }

    var apiRequestData = mapFormDataToApiModel();

    api.createMixPlaylist(apiRequestData, function (result) {
      vm.createMixStationResult = result;

      api.getMusic(true);

      if (userCanActivateMixStation) {
        vm.form.currentStep = 2;
      } else {
        userNotificationService.addSuccessMessage('Your mix station <b>"' + vm.formData.name + '"</b> has been successfully created!');
        $modalInstance.close();
      }
    }, function (err) {
      userNotificationService.addErrorMessage(err);
      $modalInstance.close();
    });
  }

  function skipMixStationActivation() {
    $modalInstance.dismiss();
  }

  // Private methods

  function buildViewModel() {
    for (var category in activeFilters) {
      var categoryFilters = activeFilters[category];

      vm.filters[category] = categoryFilters.map(function (filter) { return filter.name; }).join(', ');
    }

    vm.formData.playlists = filteredStations
      .map(function (station) {
        return {
          freq: DEFAULT_STATION_FREQ,
          name: station.name,
          playlistid: station.playlistid,
          subname: station.subname,
          thumb_url: station.thumb_url,
          content_rating_id: station.content_rating_id,
        };
      });
  }

  function mapFormDataToApiModel() {
    var apiModel = {
      isGlobal: vm.formData.isGlobal,
      name: vm.formData.name,
    };

    apiModel.playlists = vm.formData.playlists
      .map(function (playlist) {
        return {
          freq: playlist.freq,
          playlistid: playlist.playlistid
        };
      });

    return apiModel;
  }

  function updateAllowRemoveStation() {
    vm.allowRemoveStation = vm.formData.playlists.length > 2;
  }

  function updateAllowSetGlobal() {
    var isSubscriptionEnterprise = subscriptionInfo.getEnterpriseStatus().isEnterprise;

    vm.allowSetGlobal = isSubscriptionEnterprise && userPermissions.isMusicAdmin;
  }
}

app.controller('EditMessagePresetCtrl', ['$scope', '$state', '$modal', '$timeout', 'api', 'me', 'messages', 'preset',  'messageSelection', 'subscription', 'subscriptionInfo', '$rootScope', 'formEditService', 'dataCacher',
  function($scope, $state, $modal, $timeout, api, me, messages, preset, messageSelection, subscription, subscriptionInfo, $rootScope, formEditService, dataCacher) {
    var vm = this;

    $scope.$parent.hideLoader();
    $scope.$parent.currentTab = 'message_presets';
    $scope.freq = [];
    for (var i = 1; i < 41; i++) $scope.freq.push(i);
    $scope.canAutoselect = me.permissions.user.can_play_music && me.permissions.user.select_messages;
    $scope.isEdited = false;
    $scope.isSaved = false;
    $scope.isEditing = preset ? true : false;
    $scope.isSaving = false;
    if (!$scope.isEditing) {
      $scope.formData = {
        custid: me.user.custid,
        userid: me.user.userid,
        name: '',
        messages: [],
        freq: 1,
        isGlobal: 0,
        autoselect: 0,
        type: 'messagePreset',
      };
    } else {
      $scope.formData = preset;
      var cachedData = dataCacher.getData();
      if (cachedData && cachedData.type === 'messagePreset') {
        $scope.formData.autoselect = cachedData.autoselect;
        $scope.isSaved = true;
        dataCacher.clearData();
      } else {
        $scope.isSaved = false;
        $scope.formData.autoselect = 0;
      }
    }

    var initFormData = angular.copy($scope.formData);
    $scope.messages = messages.messages;
    $scope.subscription = subscription;
    $scope.entStatus = subscriptionInfo.getEnterpriseStatus();
    $scope.allowSetGlobal = $scope.entStatus.isEnterprise && (me.permissions.account.owner || me.permissions.account.messages);

    $scope.changeForm = function() {
      $scope.isSaved = false;
      $scope.isEdited = formEditService.checkEdited(initFormData, $scope.formData);
    };

    $scope.$watchCollection('formData.messages', function(newValue, oldValue) {
      if (newValue !== oldValue) {
        $scope.changeForm();
      }
    });

    $scope.clickBackButton = function() {
      formEditService.confirmNavigation($scope, $scope.isEdited, '/admin/messages/presets');
    };

    $scope.onMobileFormSubmission = function () {
      if (vm.formController.$invalid) {
        angular.element('html, body').animate({ scrollTop: 0 }, 500);
      }
    };

    function openCreateMessagePresetSummaryModal(messagePreset) {
      return $modal
        .open({
          templateUrl: 'partials/create_message_preset_summary_modal.html',
          windowClass: 'create-message-preset-summary-modal',
          controller: ['$modalInstance', 'api', 'messagePreset',
            function ($modalInstance, api, messagePreset) {
              var vm = this;

              // Properties
              vm.messagePreset = messagePreset;

              // Methods
              vm.activateMessagePreset = activateMessagePreset;
              vm.skipMessagePresetActivation = skipMessagePresetActivation;

              function activateMessagePreset() {
                api.selectMessagePreset(messagePreset.presetid, function () {
                  api.userObject.message_preset = messagePreset.presetid;
                  $modalInstance.close(true);
                }, function () {
                  $modalInstance.close(false);
                });
              }

              function skipMessagePresetActivation() {
                $modalInstance.dismiss('cancel');
              }
            }
          ],
          controllerAs: 'vm',
          resolve: {
            messagePreset: function () {
              return messagePreset;
            }
          },
        })
        .result;
    }

    $scope.addMessage = function(message) {
      $scope.formData.messages.push({
        messageid: message.messageid,
        name: message.message_name,
        day: 0,
        expiration: false
      });
      $scope.messageAddedId = message.messageid;
      $scope.changeForm();

      // Delay the DOM manipulation via the `ng-repeat` directive for one digest loop so that the animation class can be added
      $timeout(function () {
        vm.formController.$setDirty();
        $scope.messageAddedId = null;
      }, 350);
    };

    $scope.onDropOfMessage = function(srcList, srcIndex, targetList, targetIndex) {
      // Copy the item from source to target.
      targetList.splice(targetIndex, 0, srcList[srcIndex]);
      // Remove the item from the source, possibly correcting the index first.
      // We must do this immediately, otherwise ng-repeat complains about duplicates.
      if (srcList == targetList && targetIndex <= srcIndex) srcIndex++;
      srcList.splice(srcIndex, 1);
      // By returning true from dnd-drop we signalize we already inserted the item.
      return true;
    };

    $scope.removeMessage = function (messageIndex) {
      $scope.formData.messages.splice(messageIndex, 1);

      /*
       * This is on hold while we wait to decide if we want to remove message from list on left when adding to preset
       * or if we want the message to be able to be added multiple times.  For now we'll let them add it multiple times
       * which was the previous functionality.
       *
      $scope.messages.forEach(function(message) {
        if (message.messageid === messageid) {
          message.messageAdded = false;
        }
      })
      */
    };

    $scope.submit = function() {
      if (
        (vm.formController.$valid) &&
        ($scope.formData.messages.length > 0)
      ) {

        $scope.formData.isGlobal = ($scope.formData.isGlobal) ? 1 : 0;
        if (!$scope.entStatus.isEnterprise) {
          $scope.formData.isGlobal = 0;
        }

        vm.isSaving = true;
        if (!$scope.isEditing) {
          api.addMessagePreset($scope.formData, function (presetResult) {
            $scope.isSaved = true;
            $scope.isEdited = false;
            $rootScope.confirmLocationSwitch = false;
            $scope.formData.presetid = presetResult.presetid;
            dataCacher.setData($scope.formData);
            messageSelection.loadPresets();
            if ($scope.canAutoselect) {
              openCreateMessagePresetSummaryModal($scope.formData)
                .then(function (result) {
                  if (result === true) {
                    $scope.showSuccess('<b>"' + $scope.formData.name + '"</b> is now your selected Message Preset');
                  } else {
                    $scope.showError('<b>"' + $scope.formData.name + '"</b> could not be made the selected Message Preset');
                  }

                  $state.go('account.admin.messagepresets');
                }, function () {
                  $state.go('account.admin.messagepresets');
                })
                .catch(angular.noop);
            } else {
              $scope.showSuccess('<b>"' + $scope.formData.name + '"</b> Message Preset has been saved');
              $state.go('account.admin.messagepresets');
            }

            vm.isSaving = false;
          }, function (err) {
            $scope.showError('Preset <b>"' + $scope.formData.name + '"</b> could not be saved');
            console.error("Error occurred in call to addMessagePreset in admin messages.", err);

            vm.isSaving = false;
          });
        } else {
          api.editMessagePreset($scope.formData, function (result) {
            initFormData = angular.copy($scope.formData);
            $scope.isSaved = true;
            $scope.isEdited = false;
            $rootScope.confirmLocationSwitch = false;
            if (!$scope.formData.autoselect) {
              $scope.showSuccess('<b>"' + $scope.formData.name + '"</b> has been saved');
              $state.go('account.admin.messagepresets');
            } else {
              api.selectMessagePreset(preset.presetid, function() {
                api.userObject.message_preset = preset.presetid;
                $scope.showSuccess('<b>"' + $scope.formData.name + '"</b> is now your selected Message Preset');
                $state.go('account.admin.messagepresets');
              }, function(err) {
                $scope.showError('<b>"' + $scope.formData.name + '"</b> could not be made the selected Message Preset');
                $state.go('account.admin.messagepresets');
              });
            }

            vm.isSaving = false;
          }, function(err) {
            console.error('Edit message preset: ', err);
            $scope.showError('Could not update the Message Preset');

            vm.isSaving = false;
          });
        }
      } else {
        if ($scope.formData.messages.length < 1) {
          $scope.showError('You must add at least one message to your Message Preset');
        }
      }
    };

  }
]);

(function (angular, app) {
  app.controller('EditMixStationController', EditMixStationController);

  EditMixStationController.$inject = ['$modal', '$rootScope', '$scope', '$state', '$timeout', 'api', 'contentRatingInfoModalService', 'contentRatingService', 'ENV', 'formEditService', 'mixStation', 'navigationService', 'playlistCategories', 'playlistCategoryService', 'playlists', 'subscriptionInfo', 'userInfo', 'userNotificationService', 'userPermissions'];

  function EditMixStationController($modal, $rootScope, $scope, $state, $timeout, api, contentRatingInfoModalService, contentRatingService, ENV, formEditService, mixStation, navigationService, playlistCategories, playlistCategoryService, playlists, subscriptionInfo, userInfo, userNotificationService, userPermissions) {
    var vm = this;

    // Constants
    var DEFAULT_STATION_FREQ = 100;

    var allowedPlaylists = null;
    var availablePlaylists = null;
    var canUserActivateMixStation = null;
    var isUserLimitedToCompanySelections = null;
    var stateChangeStartEventListenerDeregistrationFunc = null;

    // Properties
    vm.allowSetGlobal = undefined;
    vm.formData = {
      isGlobal: null,
      mixid: mixStation ? mixStation.mixid : undefined,   // Needed strictly for the `stationeditUnique` directive
      name: null,
      options: {
        frequency: [
          { value: 100, name: '10 - More' },
          { value: 90,  name: '9'         },
          { value: 80,  name: '8'         },
          { value: 70,  name: '7'         },
          { value: 60,  name: '6'         },
          { value: 50,  name: '5'         },
          { value: 40,  name: '4'         },
          { value: 30,  name: '3'         },
          { value: 20,  name: '2'         },
          { value: 10,  name: '1 - Less'  }
        ]
      },
      searchQuery: null,
      stationCategories: {
        business: undefined,
        genre: undefined,
        mood: undefined,
        rating: []
      },
      stations: []
    };
    vm.headingPrefix = undefined;
    vm.isBusinessCategoriesCollapsed = false;
    vm.isGenreCategoriesCollapsed = false;
    vm.isMoodCategoriesCollapsed = false;
    vm.isEditing = mixStation !== null;
    vm.isSaved = false;
    vm.isSaving = false;
    vm.playlistAddedId = undefined;
    vm.playlistCategories = {
      mostPopular: {
        isActive: false
      },
      newestReleases: {
        isActive: false
      },
      pandora: {
        isActive: false
      },
      recent: {
        isActive: false
      },
      favorites: {
        isActive: false
      },
      rating: {
        isCollapsed: true,
        isShowingAll: true,
        uncommonCount: 0
      }
    };
    vm.playlists = null;
    vm.selectedContentRatings = [];
    vm.selectedStationCategories = [];
    vm.stationCategories = null;
    vm.submitBtnText = vm.isEditing ? 'Save Changes' : 'Save Mix Station';

    // Methods
    vm.addPlaylist = addPlaylist;
    vm.applyPlaylistFilters = applyPlaylistFilters;
    vm.filterPlaylistsByMostPopularCategory = filterPlaylistsByMostPopularCategory;
    vm.filterPlaylistsByNewestReleasesCategory = filterPlaylistsByNewestReleasesCategory;
    vm.filterPlaylistsByRecentCategory = filterPlaylistsByRecentCategory;
    vm.filterPlaylistsByFavoritesCategory = filterPlaylistsByFavoritesCategory;
    vm.filterPlaylistsByPandoraCategory = filterPlaylistsByPandoraCategory;
    vm.onMobileFormSubmission = onMobileFormSubmission;
    vm.onSearchControlKeypress = onSearchControlKeypress;
    vm.removePlaylist = removePlaylist;
    vm.resetPlaylistFilters = resetPlaylistFilters;
    vm.save = save;
    vm.showContentRatingsExplanation = openContentRatingInfoModal;

    // Lifecycle hooks
    init();

    function init() {
      vm.allowSetGlobal = userAllowedSetGlobal();

      if (vm.isEditing) {
        vm.headingPrefix = 'Edit';
        vm.formData.isGlobal = mixStation.isGlobal;
        vm.formData.name = mixStation.name;
      } else {
        vm.headingPrefix = 'Create';
      }

      userInfo.isUserLimitedToCompanySelections()
        .then(function (isUserLimited) {
          isUserLimitedToCompanySelections = isUserLimited;
          canUserActivateMixStation = userPermissions.canPlayMusic && userPermissions.canSelectMusic && !isUserLimited;

          if (isUserLimited) {
            getCompanyStations(api, [
              {
                name: 'public',
                idname: 'musicid',
                values: playlists.public
              },
            ], function (companyStations) {
              initPlaylists(companyStations.public);
            });
          } else {
            initPlaylists(playlists.public);
          }
        });

      initPlaylistCategories();
      initStateChangeEventListener();
    }

    function initPlaylistCategories() {
      var uncommonCount;

      for (var category in playlistCategories) {
        vm.formData.stationCategories[category] =
          playlistCategories[category]
            .map(function (cat) {
              cat.pinned = playlistCategoryService.isPlaylistCategoryCommon(category, cat.name);

              return cat;
            });
        uncommonCount = vm.formData.stationCategories[category]
          .reduce(function (acc, cat) {
            if (!cat.pinned) {
              acc += 1;
            }

            return acc;
          }, 0);

        vm.playlistCategories[category] = {
          isCollapsed: category !== 'genre',
          isShowingAll: false,
          uncommonCount: uncommonCount
        };
      }

      Object.values(contentRatingService.getAllContentRatingDetails())
        .forEach(function (cr) {
          vm.formData.stationCategories.rating.push({
            id: 'content-rating:' + cr.id,
            name: cr.rating
          });
        });
    }

    function initPlaylists(playlists) {
      allowedPlaylists = !playlists ? [] : playlists
        .map(function (p) {
          p.freq = DEFAULT_STATION_FREQ;
          p.backgroundUrl = buildPlaylistUrl(p.thumb_url);

          return p;
        });

      if (vm.isEditing) {
        availablePlaylists = allowedPlaylists
          .filter(function (playlist) {
            var mixStationPlaylist = mixStation.playlists.find(function (p) {
              return p.playlistid === playlist.playlistid;
            });

            return !mixStationPlaylist;
          });

        vm.formData.stations = allowedPlaylists
          .filter(function (allowedPlaylist) {
            var playlist = mixStation.playlists.find(function (playlist) {
              return playlist.playlistid === allowedPlaylist.playlistid;
            });

            if (playlist) {
              allowedPlaylist.freq = playlist.freq;

              return true;
            } else {
              return false;
            }
          });
      } else {
        availablePlaylists = angular.copy(allowedPlaylists);
      }

      vm.playlists = angular.copy(availablePlaylists);
    }

    function initStateChangeEventListener() {
      stateChangeStartEventListenerDeregistrationFunc =
        $rootScope.$on('$stateChangeStart', function (event, toState) {

          // Force the state transition
          if (navigationService.stateChangeData.forceNextTransition) {
            return;
          }

          var isFormDirty = $scope.vm.formController.$dirty;
          if (isFormDirty && !vm.isSaved) {

            // Prevent the state transition
            event.preventDefault();

            var confirmationMessage = vm.isEditing ? 'Your changes for "' + mixStation.name + '" have not been saved. Do you wish to proceed?' : undefined;
            formEditService.confirmRouteNavigation($scope, isFormDirty, toState.name, confirmationMessage);
          }
        });

      $scope.$on('$destroy', function () {

        // Deregister event listener
        stateChangeStartEventListenerDeregistrationFunc();
      });
    }

    // Public methods

    function addPlaylist(playlist) {
      var isPlaylistAdded = vm.formData.stations.find(function (s) {
        return s.playlistid === playlist.playlistid;
      });

      if (isPlaylistAdded) {
        return;
      }

      vm.playlistAddedId = playlist.playlistid;
      vm.formData.stations.push(playlist);

      var availablePlaylistIndex;
      for (var i = 0; i < availablePlaylists.length; i++) {
        if (availablePlaylists[i].playlistid === playlist.playlistid) {
          availablePlaylistIndex = i;

          break;
        }
      }

      availablePlaylists.splice(availablePlaylistIndex, 1);

      var filteredPlaylistIndex;
      for (var j = 0; j < vm.playlists.length; j++) {
        if (vm.playlists[j].playlistid === playlist.playlistid) {
          filteredPlaylistIndex = j;

          break;
        }
      }

      // Delay the DOM manipulation via the `ng-repeat` directive for one digest loop so that the animation class can be added
      $timeout(function () {
        vm.playlistAddedId = null;
        vm.playlists.splice(filteredPlaylistIndex, 1);

        vm.formController.$setDirty();
      });
    }

    function applyPlaylistFilters(category) {
      var isCategoryTypeRating;

      if (category || (vm.formData.searchQuery && vm.formData.searchQuery.length)) {
        vm.playlistCategories.mostPopular.isActive = false;
        vm.playlistCategories.newestReleases.isActive = false;
        vm.playlistCategories.recent.isActive = false;
        vm.playlistCategories.pandora.isActive = false;
        vm.playlistCategories.favorites.isActive = false;
      }

      isCategoryTypeRating = category && Object.prototype.toString.call(category.id) === '[object String]' && category.id.indexOf('content-rating') !== -1;

      vm.playlists = filterStationsByCategories(angular.copy(availablePlaylists), isCategoryTypeRating ? undefined : category);
      vm.playlists = filterStationsBySearchQuery(vm.playlists);
      vm.playlists = filterStationsByContentRating(vm.playlists, isCategoryTypeRating ? category : undefined);
    }

    function filterPlaylistsByMostPopularCategory() {
      vm.playlistCategories.newestReleases.isActive = false;
      vm.playlistCategories.recent.isActive = false;
      vm.playlistCategories.pandora.isActive = false;
      vm.playlistCategories.favorites.isActive = false;

      resetPlaylistSearchQuery();
      resetPlaylistCategoryGroupFilters();

      if (vm.playlistCategories.mostPopular.isActive) {
        vm.playlists = playlistCategoryService.filterPlaylistsByMostPopularCategory(availablePlaylists);
      }
    }

    function filterPlaylistsByNewestReleasesCategory() {
      vm.playlistCategories.mostPopular.isActive = false;
      vm.playlistCategories.recent.isActive = false;
      vm.playlistCategories.pandora.isActive = false;
      vm.playlistCategories.favorites.isActive = false;

      resetPlaylistSearchQuery();
      resetPlaylistCategoryGroupFilters();

      if (vm.playlistCategories.newestReleases.isActive) {
        vm.playlists = playlistCategoryService.filterPlaylistsByNewestReleasesCategory(availablePlaylists);
      }
    }

    function filterPlaylistsByRecentCategory() {
      vm.playlistCategories.newestReleases.isActive = false;
      vm.playlistCategories.mostPopular.isActive = false;
      vm.playlistCategories.pandora.isActive = false;
      vm.playlistCategories.favorites.isActive = false;

      resetPlaylistSearchQuery();
      resetPlaylistCategoryGroupFilters();

      if (vm.playlistCategories.recent.isActive) {
        vm.playlists = playlistCategoryService.filterPlaylistsByRecentCategory(availablePlaylists);
      }
    }

    function filterPlaylistsByFavoritesCategory() {
      vm.playlistCategories.newestReleases.isActive = false;
      vm.playlistCategories.mostPopular.isActive = false;
      vm.playlistCategories.pandora.isActive = false;
      vm.playlistCategories.recent.isActive = false;

      resetPlaylistSearchQuery();
      resetPlaylistCategoryGroupFilters();

      if (vm.playlistCategories.favorites.isActive) {
        vm.searchResultsLoading = true;
        playlistCategoryService.filterPlaylistsByFavoritesCategory(availablePlaylists)
          .then(function (stationPlaylist) {
            if(vm.playlistCategories.favorites.isActive) {
              vm.playlists = stationPlaylist.sort(function (a, b) { return a.name.localeCompare(b.name); });
            }
          })
          .finally(function () {
            vm.searchResultsLoading = false;
          });
      }
    }

    function filterPlaylistsByPandoraCategory() {
      vm.playlistCategories.newestReleases.isActive = false;
      vm.playlistCategories.mostPopular.isActive = false;
      vm.playlistCategories.recent.isActive = false;
      vm.playlistCategories.favorites.isActive = false;

      resetPlaylistSearchQuery();
      resetPlaylistCategoryGroupFilters();

      if (vm.playlistCategories.pandora.isActive) {
        vm.playlists = playlistCategoryService.filterPlaylistsByPandoraCategory(availablePlaylists)
          .sort(function (a, b) { return a.name.localeCompare(b.name); });
      }
    }

    function onMobileFormSubmission() {
      if (vm.formController.$invalid) {
        angular.element('html, body').animate({ scrollTop: 0 }, 500);
      }
    }

    function onSearchControlKeypress(event) {

      // Prevent the `Enter` key from submitting the form when the search field has focus
      if (event.keyCode === 13) {
        event.preventDefault();
      }
    }

    function openContentRatingInfoModal() {
      contentRatingInfoModalService.open().catch(angular.noop);
    }

    function removePlaylist(playlist) {
      var playlistIndex = vm.formData.stations.indexOf(playlist);
      vm.formData.stations.splice(playlistIndex, 1);

      var sortPlaylistsByName = function (a, b) {
        if (a.name > b.name) {
          return 1;
        } else if (a.name < b.name) {
          return -1;
        } else {
          return 0;
        }
      };

      // Reset station frequency
      playlist.freq = DEFAULT_STATION_FREQ;

      playlist.showSelectedMenu = false;

      availablePlaylists.push(playlist);
      availablePlaylists.sort(sortPlaylistsByName);

      if (vm.playlistCategories.mostPopular.isActive) {
        filterPlaylistsByMostPopularCategory();
      } else if (vm.playlistCategories.newestReleases.isActive) {
        filterPlaylistsByNewestReleasesCategory();
      } else if (vm.playlistCategories.recent.isActive) {
        filterPlaylistsByRecentCategory();
      } else if(vm.playlistCategories.favorites.isActive) {
        filterPlaylistsByFavoritesCategory();
      } else if(vm.playlistCategories.pandora.isActive) {
        filterPlaylistsByPandoraCategory();
      }else {
        applyPlaylistFilters();
      }

      vm.formController.$setDirty();
    }

    function resetPlaylistCategoryGroupFilters() {
      for (var categoryType in vm.formData.stationCategories) {
        vm.formData.stationCategories[categoryType]
          .forEach(function (cat) {
            cat.selected = false;
          });
      }

      vm.selectedStationCategories = [];

      for (var cat in vm.playlistCategories) {
        if (cat !== 'genre') {
          vm.playlistCategories[cat].isCollapsed = true;
        }

        vm.playlistCategories[cat].isShowingAll = false;
      }

      applyPlaylistFilters();
    }

    function resetPlaylistFilters() {
      vm.playlistCategories.mostPopular.isActive = false;
      vm.playlistCategories.newestReleases.isActive = false;
      vm.playlistCategories.recent.isActive = false;
      vm.playlistCategories.favorites.isActive = false;
      vm.playlistCategories.pandora.isActive = false;

      resetPlaylistSearchQuery();
      resetPlaylistCategoryGroupFilters();
    }

    function save() {
      var hasNotAddedMinStations = vm.formData.stations.length < 2;
      if (!vm.formController.$valid || hasNotAddedMinStations) {
        if (hasNotAddedMinStations) {
          userNotificationService.addErrorMessage('You must add at least two stations to your Mix Station');
        }

        return;
      }

      vm.isSaving = true;

      var apiRequestData = mapFormDataToApiModel();

      if (vm.isEditing) {
        api.editMixPlaylist(apiRequestData, function () {
          vm.isSaved = true;
          api.getMusic(true);
          $state.go('account.admin.playlists');
          userNotificationService.addSuccessMessage('Your mix station <b>"' + vm.formData.name + '"</b> has been saved!');
        }, function (err) {
          vm.isSaving = false;
          userNotificationService.addErrorMessage('Could not update this Mix Station.');
        });
      } else {
        api.createMixPlaylist(apiRequestData, function (result) {
          var mixStation = apiRequestData;
          mixStation.mixid = result.mixid;

          vm.isSaved = true;
          api.getMusic(true);

          if (canUserActivateMixStation || isUserLimitedToCompanySelections) {
            openCreateMixStationSummaryModal(mixStation, isUserLimitedToCompanySelections)
              .catch(angular.noop)
              .finally(function () {
                $state.go('account.admin.playlists');
              });
          } else {
            $state.go('account.admin.playlists');
            userNotificationService.addSuccessMessage('Your mix station <b>"' + vm.formData.name + '"</b> has been created!');
          }
        }, function (err) {
          vm.isSaving = false;
          userNotificationService.addErrorMessage('Could not create this Mix Station.');
        });
      }
    }

    // Private methods

    function buildPlaylistUrl(stationArtUrl) {
      return ENV.stationArtUrl + stationArtUrl;
    }

    function filterStationsByCategories(playlists, cat) {
      if (cat) {
        if (cat.selected) {
          vm.selectedStationCategories.push(cat);
        } else {
          var selectedIndex = vm.selectedStationCategories.indexOf(cat);
          vm.selectedStationCategories.splice(selectedIndex, 1);
        }
      }

      var selectedStationCategories = vm.selectedStationCategories
        .filter(function (c) {
          var isCategoryTypeRating = Object.prototype.toString.call(c.id) === '[object String]' && c.id.indexOf('content-rating') !== -1;

          return !isCategoryTypeRating;
        });

      if (!selectedStationCategories.length) {
        return playlists;
      }

      var businessCat = vm.formData.stationCategories.business
        .reduce(function (acc, cat) {
          if (cat.selected) {
            acc.push(cat.id);
          }

          return acc;
        }, []);

      var genreCat = vm.formData.stationCategories.genre
        .reduce(function (acc, cat) {
          if (cat.selected) {
            acc.push(cat.id);
          }

          return acc;
        }, []);

      var moodCat = vm.formData.stationCategories.mood
        .reduce(function (acc, cat) {
          if (cat.selected) {
            acc.push(cat.id);
          }

          return acc;
        }, []);

      var categories = businessCat.concat(genreCat).concat(moodCat);

      playlists = playlists
        .filter(function (p) {
          var result = false;

          // TODO: Check if categoryids is not set sometimes at API
          if (p.categoryids) {
            for (var i = 0; i < categories.length; i++) {
              var match = p.categoryids.indexOf(categories[i]) !== -1;

              if (match && i === categories.length - 1) {
                result = true;
              }

              if (!match) {
                break;
              }
            }
          }

          return result;
        });

      return playlists;
    }

    function filterStationsByContentRating(playlists, category) {
      if (category) {
        if (category.selected) {
          vm.selectedStationCategories.push(category);
        } else {
          var selectedIndex = vm.selectedStationCategories.indexOf(category);
          vm.selectedStationCategories.splice(selectedIndex, 1);
        }
      }

      var selectedContentRatingIds = [];
      vm.formData.stationCategories.rating
        .forEach(function (cr) {
          var id;
          if (cr.selected) {
            id = parseInt(cr.id.substr(cr.id.indexOf(':') + 1), 10);
            selectedContentRatingIds.push(id);
          }
        });

      if (selectedContentRatingIds.length) {
        playlists = playlists
          .filter(function (p) {
            return selectedContentRatingIds.indexOf(p.content_rating_id) !== -1;
          });
      }

      return playlists;
    }

    function filterStationsBySearchQuery(playlists) {
      if (!vm.formData.searchQuery) {
        return playlists;
      }

      var queryLowerCase = vm.formData.searchQuery.toLowerCase();

      playlists = playlists
        .filter(function (p) {
          return p.name.toLowerCase().indexOf(queryLowerCase) !== -1 || p.subname.toLowerCase().indexOf(queryLowerCase) !== -1;
        });

      return playlists;
    }

    function getCompanyStations(api, data, callback) {
      var stations = {};
      var stationIds = [];

      api.getCompanyStations(api.userObject)
        .then(function (results) {
          for (var i = 0; i < data.length; i++) {
            if (results[data[i].name].length) {
              stationIds = [];

              for (var j = 0; j < results[data[i].name].length; j++) {
                stationIds.push(results[data[i].name][j].musicid);
              }

              for (var k = 0; k < data[i].values.length; k++) {
                if (stationIds.indexOf(data[i].values[k].musicid) > -1) {
                  if (!stations[data[i].name]) {
                    stations[data[i].name] = [];
                  }

                  stations[data[i].name].push(data[i].values[k]);
                }
              }
            }
          }

          callback(stations);
        });
    }

    function mapFormDataToApiModel() {
      var apiModel = {
        isGlobal: vm.formData.isGlobal,
        name: vm.formData.name,
      };

      if (vm.isEditing) {
        apiModel.mixid = mixStation.mixid;
      }

      apiModel.playlists = vm.formData.stations
        .map(function (playlist) {
          return {
            freq: playlist.freq,
            playlistid: playlist.playlistid
          };
        });

      return apiModel;
    }

    function openCreateMixStationSummaryModal(mixStation, isUserLimitedToCompanySelections) {
      return $modal
        .open({
          templateUrl: 'partials/create_mix_station_summary_modal.html',
          windowClass: 'create-mix-station-from-filters',
          controller: ['$modalInstance', 'isUserLimitedToCompanySelections', 'me', 'mixStation', 'musicSelection',
            function ($modalInstance, isUserLimitedToCompanySelections, me, mixStation, musicSelection) {
              var vm = this;

              // Properties
              vm.isUserLimitedToCompanySelections = isUserLimitedToCompanySelections;
              vm.mixStation = mixStation;

              // Methods
              vm.activateMixStation = activateMixStation;
              vm.skipMixStationActivation = skipMixStationActivation;

              function activateMixStation(playWhen) {
                var selection = {
                  musicId: mixStation.mixid,
                  musicName: mixStation.name,
                  when: playWhen
                };

                musicSelection.setSelection('mix', selection.musicId, selection.musicName, selection.when,
                  function () {
                    me.music_type = 'mix';
                    me.music_id = selection.musicId;
                  });

                $modalInstance.close();
              }

              function skipMixStationActivation() {
                $modalInstance.dismiss();
              }
            }
          ],
          controllerAs: 'vm',
          resolve: {
            isUserLimitedToCompanySelections: function () {
              return isUserLimitedToCompanySelections;
            },
            me: function () {
              return api.getMe();
            },
            mixStation: function () {
              return mixStation;
            }
          }
        })
        .result;
    }

    function resetPlaylistSearchQuery() {
      vm.formData.searchQuery = null;
    }

    function userAllowedSetGlobal() {
      var isSubscriptionEnterprise = subscriptionInfo.getEnterpriseStatus().isEnterprise;

      return isSubscriptionEnterprise && userPermissions.isMusicAdmin;
    }
  }

})(window.angular, app);

(function (app) {
  app.controller('LoginCtrl', LoginController);

  LoginController.$inject = ['$location', '$scope', '$state', '$stateParams', 'api', 'authenticationService', 'ENV', 'intercom', 'requirements'];

  function LoginController($location, $scope, $state, $stateParams, api, authenticationService, ENV, intercom, requirements) {

    // Properties
    $scope.duo = {
      isLoading: false,
      show: false
    };
    $scope.errors = {
      primaryAuthentication: undefined,
      secondaryAuthentication: undefined,
      authorization: undefined,
      userImpersonation: undefined
    };
    $scope.login = {
      password: '',
      username: undefined,
      userImpersonationTargetUsername: undefined
    };
    $scope.userImpersonation = {
      isLoading: false,
      show: false
    };
    $scope.tuneVersion = ENV.version;

    // Methods
    $scope.onDuoLoaded = onDuoLoaded;
    $scope.skipUserImpersonation = skipUserImpersonation;
    $scope.submit = submit;
    $scope.submitUserImpersonation = submitUserImpersonation;

    // Lifecycle hooks
    init();

    function init() {
      var queryParams = $location.search();
      if (queryParams.user) {
        $scope.login.username = queryParams.user;
      } else {
        $scope.login.username = '';
      }

      // Connect to Intercom to get the widget, in case they want to ask a question before logging in.
      intercom.login();

      api.getApiVersion()
        .then(function (result) {
          $scope.version = result;
        });

      api.checkAPIStatus()
        .then(function(result) {
          $scope.APIStatus = result;
        });

      $scope.rooturl = localStorage.api_uri;
    }

    // Public methods

    function onDuoLoaded($event) {
      var iframe = $event.target;
      var isDuoInitialized = Boolean(iframe.getAttribute('src'));

      // The Duo `iframe` will emit a `load` event before Duo has been initialized
      if (isDuoInitialized) {
        $scope.duo.show = true;
      }

      $scope.duo.isLoading = false;
    }

    function skipUserImpersonation() {
      loadUserData();
    }

    function submit() {
      if ($scope.login.username === '' || $scope.login.password === '') {
        return $scope.showError('Please fill out all the fields');
      }

      $('.login-container .signin').prop('disabled', true);
      $('.login-container .loader').show();

      $scope.isLoading = true;

      authenticationService.login($scope.login.username, $scope.login.password)
        .then(function (data) {
          if (data && data.signedRequest) {
            $scope.errors.authentication = undefined;
            $scope.isLoginSuccessful = true;
            $scope.duo.isLoading = true;

            initDuo(data.signedRequest);
          } else {
            loadUserData();
          }
        })
        .catch(function (err) {
          $('.login-container .signin').prop('disabled', false);
          $('.login-container .loader').hide();

          var message = 'Unable to log in. Unknown error.';
          if (err && err.message) {
            message = err.message;
          }

          $scope.showError(message);
        })
        .finally(function () {
          $scope.isLoggingIn = false;
        });
    }

    function submitUserImpersonation() {
      authenticationService.impersonateUser($scope.login.userImpersonationTargetUsername)
        .then(function () {
          $scope.userImpersonation.isLoading = true;
          loadUserData();
        })
        .catch(function (response) {
          $scope.errors.userImpersonation = {
            message: (response && response.data && response.data.message) ? response.data.message : 'An unknown error occurred.'
          };
        });
    }

    // Private methods

    function buildAuthenticationErrorMessage(response) {
      var message;

      if (response.data && response.data.message) {
        message = response.data.message;
      } else if (response.status === -1) {
        message = 'The request was aborted.';
      } else {
        message = response.status;

        if (response.statusText) {
          message += ' - ' + response.statusText;
        }
      }

      return message;
    }

    function initDuo(signedDuoRequest) {
      authenticationService.initDuo(signedDuoRequest)
        .then(function () {
          $scope.duo.show = false;
          $scope.userImpersonation.show = true;
        })
        .catch(function (response) {
          var message = buildAuthenticationErrorMessage(response);

          $scope.errors.secondaryAuthentication = {
            message: message
          };
        });
    }

    function loadUserData() {
      api.getMe()
        .then(function (result) {
          api.checkAccountRequirements(result.user.custid, function (resultRequirements) {
            requirements.save(resultRequirements);

            api.getSubscription({ skipBilling: true })
              .then(function () {
                api.getAccount(result.account.custid, function () {
                  var validUserActions = function () {
                    var returnPath = $stateParams.returnPath;
                    var userCanPlayMusic = result.permissions.user.can_play_music;
                    var userCanManageStreams = result.permissions.account.payment || result.permissions.account.owner || result.permissions.account.music || result.permissions.account.messages;
                    var isAccountActive = userCanPlayMusic || userCanManageStreams;

                    if (returnPath && isAccountActive) {
                      $location.path(returnPath);
                    } else if (userCanPlayMusic) {
                      $state.go('account.playlistsPublicStations');
                    } else if (userCanManageStreams) {
                      $state.go('account.admin.streams');
                    } else {
                      $('.login-container .signin').prop('disabled', false);
                      $('.login-container .loader').hide();

                      return $scope.showError('account has been deactivated.');
                    }
                  };

                  validUserActions();
                });
              });
          });
        });
    }
  }

  app.controller('LogoutCtrl', ['$scope', '$location', '$window', 'api', 'requirements', 'intercom',
    function($scope, $location, $window, api, requirements, intercom) {
      var afterLogout = function() {
        localStorage.removeItem("ccm_stationFilter");
        localStorage.removeItem("ccm_stationFilterType");
        intercom.logout();
        requirements.reset();
        try {
          soundManager.reboot();
        }
        catch (e) {
          console.error("Error rebooting soundManager", e);
        }
        setTimeout(function(){
          $window.location.href = '/';
        }, 300);
      };

      api.logout($scope.login, function() {
        afterLogout();
      }, function() {
        afterLogout();
      });
    }
  ]);

  app.controller('ForgotCtrl', ['$scope', '$rootScope', '$location', 'api',
    function($scope, $rootScope, $location, api) {
      var returnPath = '/login';
      $scope.formdata = {};
      $scope.formdata.username = '';

      // if user was logging in via sonos registration, return them to the sonos login
      $scope.goBack = function() {
        if ($rootScope.urlParameters.linkcode) {
          returnPath = '/sonos/login';
        }

        $location.path(returnPath).search($rootScope.urlParameters);
      }

      $scope.submit = function() {
        if ($scope.formdata.username === '') {
          return $scope.showError('Username is required');
        }

        api.requestPassword($scope.formdata, function(result) {
          $scope.showSuccess('You will receive an email with instructions about how to reset your password in a few minutes.');
          $scope.goBack();
        }, function (err) {
          var errMsg = err && err.message ? err.message : 'An unknown error occurred.';
          $scope.showError(errMsg);
        });
      };
    }
  ]);

  app.controller('ApiAutologinCtrl', ['$scope', 'api', 'me', '$stateParams',
    function($scope, api, me, $stateParams) {
      $scope.me = me;
      api.userObject = me;
      $scope.addDevice = function() {
        api.validateAutoLogin({
          'access_key': $stateParams.accesskey,
          'custid': $scope.me.user.custid,
          'userid': $scope.me.user.userid
        }, function(result1) {
          if (result1.output.status == 'ok') {
            $scope.me.streamid = result1.output.data.streamid;
            var param = {
              token: $stateParams.accesskey,
              streamid: $scope.me.streamid
            };
            if (result1.output.data.device_id != 0 && result1.output.data.device_id != null) {
              $scope.me.device_id = result1.output.data.device_id;
              param.device_id = $scope.me.device_id;
              $scope.activate(param);
            } else {
              api.registerAutoLoginDevice($stateParams.accesskey, function(err, result) {
                $scope.me.device_id = result.device.deviceid;
                param.device_id = $scope.me.device_id;
                var dataautologin = {
                  token: $stateParams.accesskey,
                  device_id: $scope.me.device_id
                };
                api.updateAutologinInfo(dataautologin, function() {
                  $scope.activate(param);
                }, function(err) {
                  console.error("Error when updating auto login", err);
                });

              });
            }
          }
        }, function(error) {
          if (error.code == 'NotAuthorizedError') {
            api.registerAutoLoginDevice($stateParams.accesskey, function(err, result) {
              $scope.me.device_id = result.device.deviceid;
            });

            return $scope.showError(error.message);
          }
        });
      };

      $scope.activate = function (param) {
        api.autoLoginActivateDevice(param)
          .then(function () {
            $scope.next();
          })
          .catch(function () {
            $scope.setPlayerState('inactive');
            $scope.showError('Device cannot be activated and streaming stopped due to IP conflict.');
          });
      };

      $scope.next = function() {
        api.autoLoginGetNext($stateParams.accesskey, function(result) {
          window.location = result.song.uri.ogg + '?token=' + $stateParams.accesskey;
        });
      };
      $scope.addDevice();
    }
  ]);

  app.controller('WebAutoLoginController', WebAutoLoginController);

  WebAutoLoginController.$inject = ['$scope', '$stateParams', 'api', 'me', 'playerService'];

  function WebAutoLoginController($scope, $stateParams, api, me, playerService) {

    // Properties
    $scope.api = api;
    $scope.api.APIKey = $stateParams.accesskey;

    // Utilized by `player.directive.js` to activate player after auto-login is initialized
    $scope.autoLoginActivation = {
      isActivated: false,
      data: {
        device_id: null,
        streamid: null
      }
    };

    $scope.me = me;
    $scope.me.active_player = true;
    $scope.me.permissions = {
      account: {},
      user: {
        can_play_music: true,
        auto_login: true
      }
    };

    // Startup
    init();

    function init() {

      // Auto-Login is never in remote control mode
      playerService.setPlayingMode();

      api.userObject = me;
      addDevice();
    }

    // Private methods

    function activateDevice(params) {
      api.autoLoginActivateDevice(params)
        .then(function (data) {
          $scope.autoLoginActivation.data.device_id = params.device_id;
          $scope.autoLoginActivation.data.streamid = params.streamid;

          // `player.directive.js.` is watching this property
          $scope.autoLoginActivation.isActivated = true;
        })
        .catch(function (err) {
          console.error('Error when updating auto login', err);
        });
    }

    function addDevice() {
      api.validateAutoLogin({
        access_key: $stateParams.accesskey,
        custid: $scope.me.user.custid,
        userid: $scope.me.user.userid
      }, function (result1) {
        $scope.me.streamid = result1.output.data.streamid;
        var params = {
          token: $stateParams.accesskey,
          streamid: $scope.me.streamid
        };

        if (result1.output.status === 'ok') {
          if (result1.output.data.device_id !== 0 && result1.output.data.device_id !== null) {
            $scope.me.device_id = api.userObject.device_id = result1.output.data.device_id;
            params.device_id = $scope.me.device_id;
            activateDevice(params);
          } else {
            console.log('Registering a new auto-login device...');

            // Create a new autologin device
            api.registerAutoLoginDevice($stateParams.accesskey, function (err, result) {
              $scope.me.device_id = api.userObject.device_id = result.device.deviceid;
              params.device_id = $scope.me.device_id;
              var updateData = {
                token: $stateParams.accesskey,
                device_id: $scope.me.device_id
              };

              api.updateAutologinInfo(updateData, function () {
                activateDevice(params);
              }, function (err) {
                console.error('Error when updating auto login', err);
              });
            });
          }
        } else {
          console.log('Registering a new auto-login device...');

          // Error validating the autologin URL, create a new autologin device
          api.registerAutoLoginDevice($stateParams.accesskey, function (err, result) {
            $scope.me.device_id = api.userObject.device_id = result.device.deviceid;
            params.device_id = $scope.me.device_id;
            var updateData = {
              token: $stateParams.accesskey,
              device_id: $scope.me.device_id
            };

            api.updateAutologinInfo(updateData, function () {
              activateDevice(params);
            }, function (err) {
              console.error('Error when updating auto login', err);
            });
          });
        }
      }, function () {
        $scope.showError('We cannot find that username and password in our system.');
        $scope.setPlayerState('inactive');
      });
    }
  }

  app.controller(
    'SelfServeAutologinCtrl',
    ['$scope', '$rootScope', '$window', 'api', '$stateParams',
    function($scope, $rootScope, $window, api, $stateParams) {
      api.getSelfServeWebAutoLoginUrlPath($stateParams.apikey, $stateParams.uuid)

        .then(
          function(response) {
            $window.location.href = response.path;
          })

        .catch(function(err) {
          $scope.showError(err.message);
        })
      ;
    }
  ]);

})(app);

'use strict';

/**
 * TODO: Remove this code and all references to it.
 * Should not need to call `$apply`.
 */
function bindSafeApply(scope) {
  scope.safeApply = function (fn) {
    var rootScopePhase = this.$root && this.$root.$$phase;

    if (rootScopePhase === '$apply' || rootScopePhase === '$digest') {
      if (fn && typeof fn === 'function') {
        fn();
      }
    } else {
      this.$apply(fn);
    }
  };
}

function bindAlerts(scope, growl) {
  scope.showSuccess = growl.addSuccessMessage;
  scope.showInfo = growl.addInfoMessage;
  scope.showWarning = growl.addWarnMessage;
  scope.showError = growl.addErrorMessage;
}

// Grab the current play status
var getStatusDetails = function(scope, rootScope, api) {
  if (!scope.currentMusic || scope.currentMusic.music_id != scope.me.music_id || scope.currentMusic.music_type != scope.me.music_type) {
    api.getMusic().then(function(music) {
      var musicInfo;
      scope.currentMusic = {
        music_type: scope.me.music_type,
        music_id: scope.me.music_id
      };

      if (scope.me.music_type == 'playlist') {
        var currentPlaylist = null;

        for (var i=0; i < music.public.length; i++) {
          if (music.public[i].playlistid == scope.me.music_id) {
            currentPlaylist = music.public[i].name;
          }
        }
      }
    });
  }
  api.getMe(true).then(function(result) {
    scope.me = result;
  });
}

app.controller('MainCtrl', ['$scope', 'growl', 'api', function ($scope, growl, api) {
  bindSafeApply($scope);
  bindAlerts($scope, growl);
  $scope.api = api;
}]);

app.controller('AccountCtrl', ['$scope','$rootScope','$cookies','api', 'intercom', 'me', 'account', 'userInfo', '$location', 'growl', 'subscriptionInfo', 'subscription', 'plans', 'confirmationDialog', 'playlistCategoryService',
  function($scope, $rootScope, $cookies, api, intercom, me, account, userInfo, $location, growl, subscriptionInfo, subscription, plans, confirmationDialog, playlistCategoryService) {
    bindSafeApply($scope);
    bindAlerts($scope, growl);
    $scope.loading = true;
    $scope.api = api;
    $scope.me = me;
    $scope.subscription = subscription;
    $scope.convertingTrial = false;
    $scope.plans = plans;
    $scope.ccmAccount;
    $scope.subscription.balance = 0;
    $scope.subscriptionInfo = {
      isPaused: subscriptionInfo.isPaused()
    };

    $scope.formData = {
      firstName: '',
      lastName: '',
      corporateAddress: '',
      corporateCity: '',
      corporateState: 'State/Province',
      corporatePostal: '',
      corporateCountry: 'Country',
      billingAddress: '',
      billingCity: '',
      billingState: 'State/Province',
      billingPostal: '',
      billingCountry: 'Country',
      timezone: $scope.me.user.timezone || '',
      useBillingAddressForCorporate: false
    };

    $scope.showStreamList = false;
    $scope.mainMenuSelection = '';
    $scope.isNavCollapsed = true;
    $scope.disableMainContainer = function() {
      if ($scope.trialExpired || $scope.convertingTrial || $scope.orderingBox || $scope.subscriptionExpired || $scope.updatingCard) {
        return true;
      } else {
        return false;
      }
    };

    if (BrowserDetect.isMobile.any()) {
      // if we are on a phone, (as opposed to tablet), then move intercom
      var intercomIcon = document.querySelector('iframe.intercom-launcher-frame');
      if (intercomIcon) {
        intercomIcon.setAttribute('style', 'bottom: 82px !important; right: 10px !important');
      }

      // if we have not yet received a notification, popup mobile explaining how to download mobile app
      if (!$cookies.get('hideMobileDownloadNotification')) {
        if (me.subscription.state !== 'trial' || !subscriptionInfo.getTrialStatus()) {
          // Subscription is valid or trial is valid.
          var downloadSite = 'https://play.google.com/store/apps/details?id=com.cloudcovermusic.player';
          if (BrowserDetect.isMobile.iOS()) {
            downloadSite = 'https://itunes.apple.com/us/app/cloud-cover-music/id1163777405';
          }
          else if (BrowserDetect.isMobile.Android() && BrowserDetect.isMobile.Amazon()) {
            downloadSite = 'https://www.amazon.com/Cloud-Cover-Music/dp/B07CYPHV55/';
          }
          confirmationDialog({
            windowClass: 'mobile-app-download-notification',
            hideCancelBtn: true,
            returnFormFields: true,
            downloadSite: downloadSite,
            backdrop: 'static',
            templateUrl: 'partials/mobile_app_download_notification.html'
          }, '', function(results) {
            if (results && results.dismissNotice) {
              // Angular < 1.4 doesn't allow us to set an expiration date using their $cookie object,
              // so we'll set it manually.
              // Don't do this =>   $cookies.hideMobileDownloadNotification = true;
              // And this won't work =>  $cookies.put('hideMobileDownloadNotification',true, {'expires': expiration});
              var now = new Date();
              var expiration = new Date(now.getFullYear()+1, now.getMonth(), now.getDate());
              document.cookie = 'hideMobileDownloadNotification=1; expires=' + expiration.toGMTString();
            }
          });
        }
      }
    }

    userInfo.getUserPerms(function(perms) {
      $scope.userPerms = perms;
      if (perms.isAccountOwner ||
          perms.canManageMusic ||
          perms.canManageMessages ||
          perms.isPaymentAdmin ||
          perms.canManageDevices
        ) {
        $scope.canAccessControlPanel = true;
      }
      if (perms.canSelectMusic) {
        getStatusDetails($scope, $rootScope, api);
      }
      $scope.messagesAllowed = perms.canSelectMessages && subscriptionInfo.messageQuantityAllowedPerPreset();
      $scope.messageQuantityAllowedPerPreset = subscriptionInfo.messageQuantityAllowedPerPreset();
    });

    $scope.$on('$stateChangeSuccess', function (event, toState) {
      var url = toState.url;

      if (url.match(/^\/admin/)) {
        $scope.mainMenuSelection = 'account';
      } else if (url.match(/^\/playlists\/messag/)) {
        $scope.mainMenuSelection = 'messaging';
      } else if (url.match(/^\/playlists/)) {
        $scope.mainMenuSelection = 'music';
      }
    });

    $scope.toggleMenu = function(ev) {
      if (ev.target.classList.contains('account-menu') || ev.target.classList.contains('drop-menu')) {
        if (ev.target.classList.contains('toggle-menu')) {
          $scope.isNavCollapsed = !$scope.isNavCollapsed;
        }
        else {
          $scope.isNavCollapsed = true;
        }
        ev.stopPropagation();
      }
    }
    $scope.hideMenu = function() {
      $scope.isNavCollapsed = true;
    }

    var fetchAccountInfo = function() {
      api.getAccount(api.userObject.account.custid, function(data) {
        $scope.ccmAccount = data.account;
        $scope.formData.corporateAddress = ($scope.ccmAccount.street_address) ? $scope.ccmAccount.street_address : '';
        $scope.formData.corporateCity = ($scope.ccmAccount.city) ? $scope.ccmAccount.city : '';
        $scope.formData.corporateState = ($scope.ccmAccount.state) ? $scope.ccmAccount.state : 'State/Province';
        $scope.formData.corporatePostal = ($scope.ccmAccount.zipcode) ? $scope.ccmAccount.zipcode : '';
        $scope.formData.corporateCountry = ($scope.ccmAccount.country) ? $scope.ccmAccount.country : 'Country';
        userInfo.getUserAddress(function(data) {
          $scope.userAddress = data;
        });
        if ($scope.ccmAccount.country && $scope.ccmAccount.country.length > 0) {
          $scope.formData.corporateCountry = $scope.ccmAccount.country;
        } else {
          if ($scope.formData.corporatePostal.length > 0) {
            if ($scope.formData.corporatePostal.match(/[A-Z]{1}[0-9]{1}[A-Z]{1}[-\s]*[0-9]{1}[A-Z]{1}[0-9]{1}/i)) {
              $scope.formData.corporateCountry = 'CA';
            } else if ($scope.formData.corporatePostal.match(/^[^A-Z]+$/i)) {
              $scope.formData.corporateCountry = 'US';
            } else {
              $scope.formData.corporateCountry = 'Country';
            }
          } else {
            $scope.formData.corporateCountry = 'Country';
          }
        }
        $scope.formData.timezone = $scope.me.user.timezone;
      });
    };

    fetchAccountInfo();
    $scope.openBillingForm = function() {
      $scope.convertingTrial = true;
    };

    $scope.$on('subscriptionRefreshed', function (event, data) {
      $scope.subscription = data.subscription;
      $scope.skipBillingUpdate = data.skipBillingUpdate;
      $scope.subscriptionInfo.isPaused = subscriptionInfo.isPaused();
    });

    $scope.$on('refreshPaymentInfo', function() {
      subscriptionInfo.refreshSubscription(function(subscription, skipBillingUpdate) {
        $scope.subscription = subscription;
        $scope.skipBillingUpdate = (skipBillingUpdate) ? true : false;
        $scope.subscriptionInfo.isPaused = subscriptionInfo.isPaused();

        $scope.$broadcast('refreshBillingCtrlPayment');
      });
    });

    $scope.$on('refreshAccountInfo', fetchAccountInfo);
    $scope.$on('showBillingForm', function() {
      $scope.orderingBox = true;
    });
    $scope.$on('showCardUpdateForm', function() {
      $scope.updatingCard = true;
    });
    $scope.$on('closeBillingForm', function() {
      $scope.convertingTrial = false;
      $scope.orderingBox = false;
      $scope.updatingCard = false;
    });

    // Should have user info at this point
    // Needs api to get the user hash
    intercom.login(api, me.user, account.account, me.subscription);

    api.getSubscription({ skipBilling: true }).then(function () {
      $scope.loading = false;
    }, function (error) {
      $location.path('/register/plan');
    });

    var openModalForm = function() {
      document.body.style.width = document.body.clientWidth+'px';
      document.body.style.height = document.body.clientHeight+'px';
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
    }

    // Check for subscription state
    if (me.subscription.state === 'trial') {
      $rootScope.trialExpired = subscriptionInfo.getTrialStatus();
      if ($rootScope.trialExpired) {
        openModalForm();
      }
    } else if (me.subscription.state === 'expired') {
      console.log("subscription is expired");
      $rootScope.subscriptionExpired = true;
      openModalForm();
    }

    // run satismeter code
    satismeter({
      writeKey: "uSIYsmN16tEeYLmV",
      userId: me.user.username,
      traits: {
        name: me.user.username,
        account: me.account.name,
        email: me.user.email,
        createdAt: me.user.created_at
      }
    });

  // Playlist Category Service needs the userId at startup
  playlistCategoryService.setUserId(me.user.userid);

}]);

app.controller('MediaDownloadWindowEditModal', MediaDownloadWindowEditModal);

MediaDownloadWindowEditModal.$inject = ['$modalInstance', 'apiTimeDataUtility', 'networkConstraints', 'networkConstraintsService'];

function MediaDownloadWindowEditModal($modalInstance, apiTimeDataUtility, networkConstraints, networkConstraintsService) {
  var vm = this;

  // Properties
  vm.form = {
    cleared: false,
    valid: false,
    options: {
      hours: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      minutes: ['00', '15', '30', '45']
    },
    fields: {
      start: {
        hours: undefined,
        minutes: undefined,
        period: undefined
      },
      stop: {
        hours: undefined,
        minutes: undefined,
        period: undefined
      }
    }
  };
  vm.isStopTimeInNextDay = false;
  vm.isWindowSet = false;
  vm.minWindowDuration = networkConstraintsService.getMinimumDownloadWindowDurationAsHours() + ' hour';
  vm.windowDurationHumanized = undefined;

  // Methods
  vm.cancel = cancel;
  vm.clearWindow = clearWindow;
  vm.onTimeChanged = onTimeChanged;
  vm.save = save;
  vm.updateStartHours = updateStartHours;
  vm.updateStartMinutes = updateStartMinutes;
  vm.updateStopHours = updateStopHours;
  vm.updateStopMinutes = updateStopMinutes;
  vm.validate = validate;

  init();

  function init() {
    buildViewModel();
    onTimeChanged();
  }

  // Public methods

  function cancel() {
    $modalInstance.dismiss({ canceled: true });
  }

  function clearWindow() {
    vm.form.cleared = true;
  }

  function onTimeChanged() {
    validate();
    updateWindowDuration();
  }

  function save() {
    validate();

    if (!vm.form.valid) {
      return;
    }

    var result;
    if (vm.form.cleared) {
      result = { deleteWindow: true };
    } else {
      result = {
        downloadStartTime: apiTimeDataUtility.convertTimePartsToApiTime(vm.form.fields.start),
        downloadStopTime: apiTimeDataUtility.convertTimePartsToApiTime(vm.form.fields.stop)
      };
    }

    $modalInstance.close(result);
  }

  function updateStartHours(hours) {
    vm.form.fields.start.hours = hours;
    onTimeChanged();
  }

  function updateStartMinutes(minutes) {
    vm.form.fields.start.minutes = minutes;
    onTimeChanged();
  }

  function updateStopHours(hours) {
    vm.form.fields.stop.hours = hours;
    onTimeChanged();
  }

  function updateStopMinutes(minutes) {
    vm.form.fields.stop.minutes = minutes;
    onTimeChanged();
  }

  function updateWindowDuration() {
    var startTimeMs = apiTimeDataUtility.convertTimePartsToMilliseconds(vm.form.fields.start);
    var stopTimeMs = apiTimeDataUtility.convertTimePartsToMilliseconds(vm.form.fields.stop);

    if (typeof startTimeMs === 'undefined' || typeof stopTimeMs === 'undefined') {
      vm.windowDurationHumanized = '';

      return;
    }

    var isStopTimeInNextDay = networkConstraintsService.isDownloadStopTimeInNextDay(vm.form.fields.start, vm.form.fields.stop);
    if (isStopTimeInNextDay) {
      stopTimeMs += 24 * 60 * 60 * 1000;
    }

    var durationMs = stopTimeMs - startTimeMs;
    var durationHours = Math.floor(durationMs / 1000 / 60 / 60);
    var durationMinutes = (durationMs / 1000 / 60) % 60;

    var durationHumanized = '';
    if (durationHours > 0) {
      durationHumanized += durationHours + ' hour' + (durationHours > 1 ? 's' : '');
    }

    if (durationMinutes > 0) {
      durationHumanized += (durationHours > 0 ? ' ' : '') + durationMinutes + ' minute' + (durationMinutes > 1 ? 's' : '')
    }

    vm.windowDurationHumanized = durationHumanized;
  }

  function validate() {
    if (vm.form.cleared) {
      vm.form.valid = true;

      return;
    }

    var startTime = vm.form.fields.start;
    var stopTime = vm.form.fields.stop;

    vm.form.valid = networkConstraintsService.validateDownloadWindow(startTime, stopTime);
    vm.isStopTimeInNextDay = networkConstraintsService.isDownloadStopTimeInNextDay(startTime, stopTime);
  }

  // Private methods

  function buildViewModel() {
    var startTime;
    var stopTime;
    var defaultDownloadWindow;

    vm.isWindowSet = networkConstraints && networkConstraints.downloadStartTime || networkConstraints.downloadStopTime;
    if (vm.isWindowSet) {
      startTime = networkConstraints.downloadStartTime;
      stopTime = networkConstraints.downloadStopTime;
    } else {
      defaultDownloadWindow = networkConstraintsService.getDefaultDownloadWindow();

      startTime = defaultDownloadWindow.downloadStartTime;
      stopTime = defaultDownloadWindow.downloadStopTime;
    }

    var startTimeParts = apiTimeDataUtility.convertApiTimeToTimeParts(startTime);
    startTimeParts.hours = startTimeParts.hours.toString();
    startTimeParts.minutes = startTimeParts.minutes < 10 ? '0' + startTimeParts.minutes : startTimeParts.minutes.toString();

    var stopTimeParts = apiTimeDataUtility.convertApiTimeToTimeParts(stopTime);
    stopTimeParts.hours = stopTimeParts.hours.toString();
    stopTimeParts.minutes = stopTimeParts.minutes < 10 ? '0' + stopTimeParts.minutes : stopTimeParts.minutes.toString();

    vm.form.fields.start = startTimeParts;
    vm.form.fields.stop = stopTimeParts;
  }
}
app.controller('PlanCtrl', ['$scope','api', function($scope, api) {
	api.getPlans(function (result) {
		$scope.plans = result;
		$scope.plans = result.map(function (item) {
			if (typeof item.description === 'string') {
				item.description = item.description.split('|');
			}

			return item;
		});
	});

	$scope.sort = 'recurring_cost';

	$scope.selectPlan = function (plan) {
		api.selectPlan(plan.code);
	};
}]);

app.filter('stationNameToFileName', function() {
  return function(stationName) {
    var name = stationName.replace(/[\&\/]+/g,'').replace(/[\s-]+/g,'_').toLowerCase();
    return name;
  };
});

// PLAYLIST CONTROLLER - handles display of CCM Stations, Mix Stations, and Dayparting Playlists.
// *NOTE* Messages are handled by PlaylistMessagingCtrl controller.
app.controller('PlaylistCtrl', playlistCtrl);

playlistCtrl.$inject = ['ENV','$modal', '$window','$location','$timeout','$scope', 'confirmationDialog', 'api', 'me', 'category', 'music','companyStations', 'musicSelection', 'playlistService', 'stationInfoPopup', 'deviceCommand', 'streamUpdateService', 'subscriptionInfo', 'userPerms', 'playerService', 'prefetchInfoService', 'playlistCategoryService', 'playerConfirmationModal', 'contentRatingService', 'userNotificationService', 'googleTagManager', 'favorites', 'intercom'];

function playlistCtrl(ENV, $modal, $window, $location, $timeout, $scope, confirmationDialog, api, me, category, music, companyStations, musicSelection, playlistService, stationInfoPopup, deviceCommand, streamUpdateService, subscriptionInfo, userPerms, playerService, prefetchInfoService, playlistCategoryService, playerConfirmationModal, contentRatingService, userNotificationService, googleTagManager, favorites, intercom) {

  var playlistStationFilter = {};
  var musicSelectionCategories = {};
  var popidx = -1;
  $scope.poplist = [];
  $scope.newestStations = [];
  $scope.pandoraList = [];

  $scope.parseKey = function (key) {
    return key.split('_').join(' ');
  };

  $scope.me = api.userObject;
  $scope.currentNav = category;
  $scope.isNavCollapsed = true;
  $scope.navType = 'music';
  $scope.allowSearch = true;
  $scope.showAll = true;
  $scope.userPerms = userPerms;
  $scope.stationArtUrl = ENV.stationArtUrl;
  var selectedStream = streamUpdateService.getSelectedStream() || api.userObject;
  var playlistMusic = {};

  if (!$scope.userPerms.canSelectMusic) {
    $scope.allowSearch = false;
  }

  if (!$scope.userPerms.canPlayMusic) {
    return $location.path('/admin/zones');
  }

  if (!$scope.userPerms.canSelectMusic) {
    if (subscriptionInfo.messageQuantityAllowedPerPreset() && userPerms.canSelectMessages) {
      return $location.path('/playlists/messaging');
    } else {
      return $location.path('/admin/zones');
    }
  }

  $scope.isMobile = false;
  if (BrowserDetect.mobile) {
    $scope.isMobile = true;
  }

  $scope.pageSize = 20;
  $scope.pageNum = 1;
  $scope.showSearch = false;
  $scope.query = '';
  $scope.showSearch = false;
  $scope.orderBy = 'name';
  $scope.reverse = false;
  $scope.sortDirection = 'up';

  $scope.order = function(orderBy) {
    return playlistService.order($scope,orderBy);
  };

  $scope.customSort = function() {
    return playlistService.customSort($scope);
  };

  $scope.jumpToStationListTop = function() {
    var stationListPanel = $('.station-and-filter-container .station-list');
    if (stationListPanel && stationListPanel[0]) {
      stationListPanel[0].scrollTop = 0;
    }
  };

  $scope.toggleSearch = function() {
    if ($scope.showSearch) {
      $scope.musicsearch = '';
      $scope.showSearch = false;
      $scope.filterDataset();
    } else {
      $scope.showSearch = true;
    }
  };

  $scope.updateSearch = function() {
    if ($scope.musicsearch && $scope.musicsearch.length > 0) {
      $scope.searchResults = true;
    } else $scope.searchResults = false;
  };

  $scope.toggleFilters = function() {
    if ($scope.filterMenuOpen) {
      $scope.filterMenuOpen = false;
    } else {
      $scope.filterMenuOpen = true;
    }
    $scope.musicsearch = '';
  };

  $scope.filterDataset = function(filterStatus, filterList, searchQuery) {
    if(searchQuery) {
      googleTagManager.push({
        event: 'searchPlaylist',
        data: {
          query: searchQuery
        }
      });
    }

    var intermediateList = [];
    var dataTitle = '';
    var dataIcon = '';
    var dataTitleImg = '';

    if (filterStatus) {
      // update playlistStationFilter to be used by Create Mix Station
      playlistStationFilter = filterStatus;
      musicSelectionCategories = filterList;

      if (filterStatus.popular) {
        intermediateList = $scope.poplist;
        dataTitle = 'Most Popular';
        dataIcon = 'fa-star-o';
        $scope.musicsearch = '';
      }
      else if (filterStatus.newest) {
        intermediateList = $scope.newestStations;
        dataTitle = 'Newest Releases';
        dataIcon = 'fa-clock-o';
        $scope.musicsearch = '';
      }
      else if (filterStatus.favorites) {
        $scope.resultsLoading = true;
        $scope.favoritesList()
          .then(function (favoritesList) {
            if(filterStatus.favorites) {
              $scope.filteredPlaylists = favoritesList.stations;
            }
          })
          .finally(function () {
            $scope.resultsLoading = false;
          });
        dataTitle = 'Favorites';
        dataIcon = 'fa-heart';
        $scope.musicsearch = '';
      }
      else if (filterStatus.recent) {
        intermediateList = $scope.recentList();
        dataTitle = 'Recent';
        dataIcon = 'fa-history';
        $scope.musicsearch = '';
      }
      else if (filterStatus.pandora) {
        intermediateList = $scope.pandoraList;
        dataTitle = 'Pandora';
        dataIcon = 'fa-music';
        dataTitleImg = '../images/pandora.svg';
        $scope.musicsearch = '';
      }
      else {
        var stationCategories = [].concat(filterStatus.business, filterStatus.mood, filterStatus.genre);

        if ($scope.currentNav == 'public' && ((stationCategories.length > 0) || (filterStatus.rating.length > 0) )) {

          intermediateList = $scope.dataset.filter(function (station) {
            var isFilteredByCategories = false;
            var isFilteredByRatings = false;

            if (filterStatus.rating.length) {
              isFilteredByRatings = filterStatus.rating.indexOf(station.content_rating_id) !== -1;
            } else {
              isFilteredByRatings = true;
            }

            if (stationCategories.length && station.categoryids) {
              var isStationInAllCategories = true;
              for (var i = 0; i < stationCategories.length; i++) {
                if (station.categoryids.indexOf(stationCategories[i]) === -1) {
                  isStationInAllCategories = false;
                  break;
                }
              }

              isFilteredByCategories = isStationInAllCategories;
            } else if (!stationCategories.length) {
              isFilteredByCategories = true;
            }

            return isFilteredByCategories && isFilteredByRatings;
          });

          dataTitle = stationCategories.length + filterStatus.rating.length + ' Filter(s)';
          dataIcon = 'fa-sliders';
        } else {
          intermediateList = $scope.dataset;
        }

        // filter with search query
        if (searchQuery && searchQuery.length > 0) {
          var testString = searchQuery.toLowerCase();
          var filteredPlaylists = intermediateList.filter(function (station) {
            var subject = [station.name, station.subname, station.featuredPlaylists].join(' ').toLowerCase();
            return subject.match(testString);
          });
          intermediateList = filteredPlaylists;
          if (stationCategories.length < 1) {
            dataTitle = 'Search Results';
          } else {
            dataTitle += ' with Search Results';
          }
          dataIcon = 'fa-search';
        }
      }

      if (dataTitle.length == 0) {
        if ($scope.me.has_company_stations) dataTitle = 'Company Selections';
        else dataTitle = "All";
        dataIcon = 'fa-th-large';
      }
      $scope.dataTitle = dataTitle;
      $scope.dataIcon = dataIcon;
      $scope.dataTitleImg = dataTitleImg;
      $scope.filteredPlaylists = intermediateList;
      $scope.jumpToStationListTop();
    }
    else {
      $scope.filteredPlaylists = $scope.dataset.sort(function (a, b) {
        return (a.name > b.name) ? 1 : -1;
      });
    }
  };

  $scope.isFilteredOut = function(station) {
    return (station.filteredOut) ? true : false;
  };

  $scope.popupStationInfo = function(event, id) {
    stationInfoPopup.show(event, id);
  };

  $scope.$watch(function () {
    return stationInfoPopup.queue;
  }, function (newQueue, oldQueue) {
    if (newQueue !== oldQueue) {
      return $scope.pushMedia(newQueue);
    }
  });

  var urlDecode = function(str) {
    // this is a reason I'm using :CODE: instead of regular html Entity Encoding.
    // Basically, Angulars $location.search() method doesn't properly parse the ampersand.
    // -FMadden
    return String(str).replace(':AMP:', '&').replace(':LT:', '<').replace(':GT:', '>').replace(':QUOTE:', '"');
  };

  var searchValue = musicSelection.getSearchValue();
  if (searchValue.length > 0) {
    $scope.musicsearch = urlDecode(searchValue);
    $scope.updateSearch();
    musicSelection.clearSearchValue();
  }

  $scope.clearSearchField = function() {
    $scope.musicsearch = '';
    musicSelection.clearSearchValue();
    $scope.updateSearch();
  };

  $scope.toggleMenu = function(ev) {
    if (ev.target.classList.contains('toggle-menu')) {
      $scope.isNavCollapsed = !$scope.isNavCollapsed;
    }
    else {
      $scope.isNavCollapsed = true;
    }
  };

  $scope.setTouchActive = function(musicid) {
    $scope.safeApply(function() {
      $scope.touchActive = musicid;
    });
  };

  $scope.checkActiveStation = function(station) {
    return $scope.touchActive === station;
  };

  var setPlaylistMusic = function() {
    if ($scope.me.has_company_stations && companyStations.companyStationDetails) {
      $scope.companyStationDetails = companyStations.companyStationDetails;
      $scope.companyStation = companyStations.companyStation[0];
      return companyStations;
    } else {
      return music;
    }
  }
  playlistMusic = setPlaylistMusic();

  $scope.checkPlaying = function (playlist) {
    if (typeof playlist !== 'undefined') {
      selectedStream = streamUpdateService.getSelectedStream();
      // TODO: Temp hack until Tune always has a selected stream
      var checkObj = selectedStream;
      if (!checkObj) {
        checkObj = musicSelection.getSelection();
      }
      //playlist.isPlaying = (selectedStream.music_type === playlist.type && selectedStream.music_id === playlist.musicid) {
      playlist.isPlaying = (checkObj.music_type === playlist.type && checkObj.music_id === playlist.musicid);
      return playlist.isPlaying;
    }
    return false;
  };

  $scope.isPrefetch = function() {
    var stream = streamUpdateService.getSelectedStream();
    return prefetchInfoService.isPrefetch($scope.me, stream);
  };

  $scope.prefetchTooltip = function() {
    return prefetchInfoService.prefetchTooltip();
  };

  // Need to decide which stream this should affect.
  $scope.playNext = function (playlist) {
    selectedStream = streamUpdateService.getSelectedStream();
    // if we are in remote control mode but the device id of the stream is assigned to our
    // browser, then prompt to play locally.
    if (!$scope.isMobile && api.userObject.device_id && (api.userObject.device_id == selectedStream.deviceid || selectedStream.deviceid == null) && playerService.isRemoteControlMode()) {
      playerConfirmationModal({
        stream: selectedStream,
        title: 'Play Here?',
        description: 'Would you like to begin streaming (<strong>' + selectedStream.streamname + '</strong>) in this browser now?',
      }, function (result) {
        playerService.setPlayingMode();
        playNowSubProcess(playlist);
      }).catch(angular.noop);
    } else {
      musicSelection.setSelection(playlist.type, playlist.musicid, playlist.name, 'next', function (succeeded, error) {
        if (succeeded) {
          api.getActiveDevicesForUser(me.user.userid, me.user.custid, function (result) {
            if (result.devices.length > 0) {
              var playlistLabel = ($scope.currentNav === 'mix') ? 'mix' : ($scope.currentNav === 'dayparting') ? 'daypart' : 'station';
              var baseMessage = 'The ' + playlistLabel + ' <b>"' + playlist.name + '"</b> is now selected. It will take effect ';
              if ($scope.isPrefetch())
                $scope.showSuccess(baseMessage + 'at the next media download window.');
              else
                $scope.showSuccess(baseMessage + 'on the next song.');
            }
          }, function (err) {
            console.error('Error retrieving active device list.', err);
          });
        } else {
          var errorMsg;

          if (error.message === 'Music selection not approved for company selections.') {
            errorMsg = '<strong>' + playlist.name + '</strong> has not been approved by your company. Please refresh the page.';
          } else {
            errorMsg = 'There was a problem changing the music selection, please try again.';
        }

          userNotificationService.addErrorMessage(errorMsg);
        }
      });
    }

    if(playlist.type === 'playlist' && playlist.playlistid) {
      playlistCategoryService.addToRecentList(playlist.playlistid);
    }
  };

  // Need to decide which stream this should affect.
  function playNowSubProcess(playlist) {
    musicSelection.setSelection(playlist.type, playlist.musicid, playlist.name, 'now', function (succeeded, error) {
      if (succeeded) {
        api.getActiveDevicesForUser(me.user.userid, me.user.custid, function (result) {
          if (!playerService.isRemoteControlMode() && result.devices.length == 0) {
            $scope.$emit('registerDevice');
          }
          else {
            for (var i=0; i<result.devices.length; i++) {
              var device = result.devices[i];
              selectedStream = streamUpdateService.getSelectedStream();
              // There should only be 1 active device for the stream whose music is being changed.
              if (device.deviceid == selectedStream.deviceid) {
                if (device['class'] && device.class === 'cloudbox') {
                  // CloudBox versions > 3.3.27 use the music selection change notification to figure
                  // out when to start playing the new selection. For older versions we send two skips.
                  if (device.cloudbox_uuid && device.appversion && !deviceCommand.versionGreaterThan(device.appversion, '3.3.27')) {
                    deviceCommand.skipDevice(device, function (message) {
                      if (message.errMessage) {
                        $scope.showWarning('There was a problem skipping the track, the station may not change immediately.');
                      }
                      else {
                        deviceCommand.skipDevice(device, function (message) {
                          if (message.successMessage) {
                            var playlistLabel = ($scope.currentNav === 'mix') ? 'mix' : ($scope.currentNav === 'dayparting') ? 'daypart' : 'station';
                            $scope.showSuccess('The ' + playlistLabel + ' <b>"' + playlist.name + '"</b> is selected on the CloudBox "' + device.name + '" and should begin playing now.');
                          }
                          if (message.errMessage) {
                            $scope.showWarning('There was a problem skipping the track, the station may not change immediately.');
                          }
                        });
                      }
                    });
                  }
                }
                // Mobile and Tune respond to the music selection changed message, no skips needed.
                // Don't need to look at the rest of the devices
                break;
              }
            }
          }
        }, function (err) {
          console.error('Error retrieving active device list.', err);
        });
      } else {
        var errorMsg;

        if (error.message === 'Music selection not approved for company selections.') {
          errorMsg = '<strong>' + playlist.name + '</strong> has not been approved by your company. Please refresh the page.';
        } else {
          errorMsg = 'There was a problem changing the music selection, please try again.';
        }

        userNotificationService.addErrorMessage(errorMsg);
      }
    });

  }

  $scope.playNow = function(playlist) {
    selectedStream = streamUpdateService.getSelectedStream();
    // if we are in remote control mode but the device id of the stream is assigned to our
    // browser, then prompt to play locally.
    if (!$scope.isMobile && api.userObject.device_id && (api.userObject.device_id == selectedStream.deviceid || selectedStream.deviceid == null) && playerService.isRemoteControlMode()) {
      playerConfirmationModal({
        stream: selectedStream,
        title: 'Play Here?',
        description: 'Would you like to begin streaming (<strong>' + selectedStream.streamname + '</strong>) in this browser now?',
      }, function(result) {
        playerService.setPlayingMode();
        playNowSubProcess(playlist);
      }).catch(angular.noop);
    } else {
      playNowSubProcess(playlist);
    }

    if(playlist.type === 'playlist' && playlist.playlistid) {
      playlistCategoryService.addToRecentList(playlist.playlistid);
    }
  };

  function markFavorites (favoritesIds) {
    for (var i = 0; i < $scope.dataset.length; i++) {
      if($scope.dataset[i].type === 'playlist') {
        $scope.dataset[i].isFavorite =
          favoritesIds.indexOf($scope.dataset[i].musicid) >= 0;
      }
    }
  }

  $scope.toggleFavorites = function(station) {
    if(station.type === 'playlist' && station.musicid) {
      var toggleFunction = station.isFavorite ? favorites.removeFavorites : favorites.addFavorites;
      toggleFunction($scope.me.user.userid, 'playlist', [station.musicid])
        .then(function (favoritesResource) {
          var favoritesIds = favoritesResource.map(function (favorite) {
            return favorite.id;
          });
          markFavorites(favoritesIds);
        }).catch(function () {
          $scope.showError('Failed to toggle favorite station.');
        });
    }

    intercom.sendEvent('Toggle favorite', { type: station.type, name: station.name, id: station.musicid, operation: station.isFavorite ? 'remove' : 'add' });
  };

  $scope.pageChanged = function(newPage) {
    $scope.pageNum = newPage;
    if (category === 'mix') {
      processMixDescriptions();
    } else if (category === 'dayparting') {
      processDaypartingDescriptions();
    }
  };

  var calculateVisibleStations = function () {
    if (!$scope.dataset) { return []; }

    var pageSize = $scope.pageSize;
    var pageNum = $scope.pageNum;
    var searchStr = $scope.musicsearch || '';

    return $scope.dataset.filter(function (station) {
      return station.name.indexOf(searchStr) >= 0 || station.username.indexOf(searchStr) >= 0;
    }).slice((pageNum-1)*pageSize, (pageNum)*pageSize);
  };

  var processMixDescriptions = function () {
    var mixIds = calculateVisibleStations()
      .map(function (mixStation) { return mixStation.mixid; });

    if (!mixIds || mixIds.length === 0) { return; }

    api.getMixDetailsBatch(mixIds)
      .then(function (mixDetails) {
        for (var i = 0; i < mixIds.length; i++) {
          var id = mixIds[i];
          $scope.playlistDetails[id] = mixDetails[id].playlists
            .map(function (mixStation) { return mixStation.name; })
            .join(', ');
        }
      });
  };

  var processDaypartingDescriptions = function () {
    var daypartingIds = calculateVisibleStations()
      .map(function (daypart) { return daypart.daypartingid; });

    if (!daypartingIds || daypartingIds.length === 0) { return; }

    api.getDayPartingDetailsBatch(daypartingIds)
      .then(function (daypartingDetails) {
        for (var i = 0; i < daypartingIds.length; i++) {
          var daypartingId = daypartingIds[i];
          var description = [];
          var playlists = daypartingDetails[daypartingId].playlists;
          for (var day in playlists) {
            for (var j=0; j<playlists[day].length; j++) {
              if (description.indexOf(playlists[day][j].name) == -1) {
                description.push(playlists[day][j].name);
              }
            }
          }
          description.sort();
          $scope.playlistDetails[daypartingId] = description.join(', ');
        }
      });
  };

  // ///////////// SETUP DATASET ////////////// //
  function initializePlaylistData() {
    $scope.playlistDetails = [];
    if ((category == 'all' || category == 'public') &&
    (playlistMusic['public'] && playlistMusic['public'].length)) {
      $scope.dataset = playlistMusic['public'];

      var newestStationIds = playlistCategoryService.getNewestReleases();
      $scope.newestStations = [];
      var tempNewestStations = {};

      var popListIds = playlistCategoryService.getMostPopular();
      $scope.poplist = [];
      var tempPopList = {};

      var pandoraListIds = playlistCategoryService.getPandoraList();
      $scope.pandoraList = [];
      var tempPandoraList = {};

      var idx;
      var popidx;
      var pandoraidx;

      stationInfoPopup.setStationList($scope.dataset);

      // it's quicker to traverse the full station list and generate an array of matches
      // and then sort the list afterwards then to try and load them into an array in order
      for (var i = 0; i < $scope.dataset.length; i++) {

        if ($scope.checkPlaying($scope.dataset[i])) {
          $scope.dataset[i].selected = true;
        }

        popidx = popListIds.indexOf($scope.dataset[i].playlistid);
        if (popidx > -1) {
          tempPopList[popidx] = $scope.dataset[i];
        }

        pandoraidx = pandoraListIds.indexOf($scope.dataset[i].playlistid);
        if (pandoraidx > -1) {
          tempPandoraList[pandoraidx] = $scope.dataset[i];
        }

        idx = newestStationIds.indexOf($scope.dataset[i].playlistid);
        if (idx > -1) {
          tempNewestStations[idx] = $scope.dataset[i];
        }

      }
      // create sorted arrays.
      // this filters out undefined stations.
      $scope.poplist = Object.values(tempPopList).filter(Boolean);
      $scope.newestStations = Object.values(tempNewestStations).filter(Boolean);
      $scope.pandoraList = Object.values(tempPandoraList).filter(Boolean)
        .sort(function (a, b) { return a.name.localeCompare(b.name); });
      $scope.recentList = function () {
        var recentListIds = playlistCategoryService.getRecentList();
        var recentidx;
        var tempRecentList = {};
        for (var i = 0; i < $scope.dataset.length; i++) {
          recentidx = recentListIds.indexOf($scope.dataset[i].playlistid);
          if (recentidx > -1) {
            tempRecentList[recentidx] = $scope.dataset[i];
          }
        }
        return Object.values(tempRecentList).filter(Boolean);
      };
      $scope.favoritesList = function () {
        return playlistCategoryService.getFavoritesPlaylist()
          .then(function (favoritesResource) {
            var idx;
            var tempList = {};
            var favoritesListIds = favoritesResource.map(function (favorite) {
              return favorite.id;
            });
            for (var i = 0; i < $scope.dataset.length; i++) {
              idx = favoritesListIds.indexOf($scope.dataset[i].playlistid);
              if (idx > -1) {
                tempList[idx] = $scope.dataset[i];
              }
            }
            return {
              ids: favoritesListIds,
              stations: Object.values(tempList).filter(Boolean)
                .sort(function (a, b) { return a.name.localeCompare(b.name); })
            };
          });
      };
      $scope.favoritesList().then(function (favoritesList) { markFavorites(favoritesList.ids); });
    }

    if (category == 'public') {
      // set up filter adjustment
      function adjustStationListDimensions() {
        var mediaTB = document.querySelector('.media-toolbar');
        var headerTB = document.querySelector('.header-toolbar');
        var searchTB = document.querySelector('.account-playlists.tabs');
        var playlistBlurb = document.querySelector('.playlist-blurb');
        var stationList = document.querySelector('.station-list');
        var stationFilter = document.querySelector('.playlist-ccm-station-filter .filter-main-screen');
        var minHeight = 100;

        var screenHt = window.innerHeight;
        var screenWd = window.innerWidth;
        if (mediaTB && headerTB && searchTB && screenHt) {

          // adjust height
          screenHt -= mediaTB.offsetHeight + headerTB.offsetHeight + searchTB.offsetHeight;
          if (playlistBlurb) screenHt -= playlistBlurb.offsetHeight;

          if (screenHt < minHeight) screenHt = minHeight;

          if (stationList) {
            stationList.style.height = screenHt + 'px';
          }
          if (stationFilter && !$scope.isMobile) {
            stationFilter.style.height = screenHt + 'px';
          }

          // adjust width
          if ($scope.me.has_company_stations || $scope.me.account.has_restricted_stations) {
            stationList.style.width = screenWd + 'px';
          } else if (stationFilter && !$scope.isMobile) {
            // offsetWidth includes width of element including padding,
            // border, and scrollbar
            stationList.style.width = (screenWd - stationFilter.offsetWidth) + 'px';
          }
        }
      }
      $scope.$on('playerBarReady', function() {
        adjustStationListDimensions();
      });
      $window.addEventListener('resize', adjustStationListDimensions);

      $timeout(adjustStationListDimensions, 0);

      $scope.resizeFilter = function() {
        var mediaTB = document.querySelector('.media-toolbar');
        if (mediaTB) {
          adjustFilterHeight();
        }
        return true;
      };
    }

    if ((category == 'all' || category == 'dayparting') &&
    (playlistMusic['dayparting'] && playlistMusic['dayparting'].length)) {
      $scope.dataset = playlistMusic['dayparting'].filter(function(item) {
        if (
          item.isGlobal                         ||
          $scope.userPerms.isMusicAdmin         ||
          $scope.me.has_company_stations        ||
          item.userid === $scope.me.user.userid ||
          selectedStream.music_type === 'dayparting' && selectedStream.music_id === item.daypartingid
        ) {
          return true;
        }
      });
      for (var i=0; i<$scope.dataset.length; i++) {
        $scope.dataset[i].description = '';
        if ($scope.checkPlaying($scope.dataset[i])) {
          $scope.dataset[i].selected = true;
        }
        var daypartingid = $scope.dataset[i].musicid;
        $scope.dataset[i].webid = daypartingid;
      }
    }

    if ((category == 'all' || category == 'mix') &&
    (playlistMusic['mix'] && playlistMusic['mix'].length)) {
      var mixid;
      $scope.dataset = playlistMusic['mix'].filter(function(item) {
        if (
          item.isGlobal                          ||
          $scope.userPerms.isAccountOwner        ||
          $scope.me.has_company_stations         ||
          item.userid === $scope.me.user.userid  ||
          selectedStream.music_type === 'mix' && selectedStream.music_id === item.mixid
        ) {
          return true;
        }
      });
      for (var i = 0; i < $scope.dataset.length; i++) {
        if ($scope.checkPlaying($scope.dataset[i])) {
          $scope.dataset[i].selected = true;
        }
        $scope.dataset[i].content_rating_list = JSON.parse($scope.dataset[i].content_ratings);
        mixid = $scope.dataset[i].musicid;
        $scope.dataset[i].webid = mixid;
      }
    }

    if (category == 'dayparting') {
      $scope.creationURL = '/#/admin/createpreset';
      $scope.creationLabel = 'Create Daypart';
      $scope.shortCreationLabel = 'Daypart';

      processDaypartingDescriptions();
    } else if (category == 'mix') {
      $scope.creationURL = '/#/admin/mix/create';
      $scope.creationLabel = 'Create Mix Station';
      $scope.shortCreationLabel = 'Mix Station';

      processMixDescriptions();
    }

    $scope.filteredPlaylists = $scope.dataset;
    $scope.dataTitle = "All";
    if (api.userObject.has_company_stations) $scope.dataTitle = 'Company Selections';

    $scope.dataIcon = 'fa-th-large';

    $scope.setDisplay = function(id) {
      $scope.showPlayButton = id;
    };

    $scope.clearDisplay = function() {
      $scope.showPlayButton = false;
    };
  }

  initializePlaylistData();
  $scope.$on('newStreamSet', function() {
    if ($scope.me.has_company_stations) {
      api.getMe().then(api.getCompanyStations.bind(api)).then(function(result) {
        playlistMusic = result;
        $scope.companyStationDetails = result.companyStationDetails;
        $scope.companyStation = result.companyStation[0];
        selectedStream = streamUpdateService.getSelectedStream();
        initializePlaylistData();
      });
    } else {
      api.getMusicIfUser().then(function(result) {
        playlistMusic = result;
        selectedStream = streamUpdateService.getSelectedStream();
        initializePlaylistData();
      });
    }
  });

  // ///////////// END SETUP DATASET ////////////// //

  $scope.removePlaylist = function(playlist) {
    // handle dayparting
    if ($scope.currentNav === 'dayparting')
      removeDayparting(playlist);
    else if ($scope.currentNav === 'mix')
      removeMix(playlist);
  };

  var removeDayparting = function(preset) {
    if ((musicSelection.getSelection().music_id === $scope.dataset.daypartingid) || $scope.dataset.isActive) {
      return $scope.showError('You cannot delete the Daypart: ' + preset.name + ', because it is currently in use.');
    }

    var message = 'Are you sure you want to delete the Daypart: ' + preset.name + '?';
    confirmationDialog({buttonText: 'Yes'}, message, function(){
      api.removeDayparting(preset.daypartingid, function(resp) {
        if (resp.error) {
          $scope.showError(resp.error);
        } else {
          $scope.showSuccess( 'Your Dayparting <b>"' + preset.name + '"</b> has been removed');
          $scope.dataset.splice($scope.dataset.indexOf(preset),1);
          var forceReload = true;
          api.getMusic(forceReload).then(function(result) {
            playlistMusic = music = result;
            initializePlaylistData();
          });
        }
      }, function(err){
        console.error("Error in removeDayparting called from " + $scope.currentNav + " playlist", err);
        $scope.showError('Unable to delete the Daypart');
      });
    });
  };

  var removeMix = function(mix) {
    if ((musicSelection.getSelection().music_id === mix.mixid) || mix.isActive) {
      return $scope.showError('You cannot delete the Mix Station: ' + mix.name + ', because it is currently in use. Make sure it is not assigned to any zones or used in any Dayparts, then try again.');
    }

    var message = 'Are you sure you want to delete the Mix Station: ' + mix.name + '?';
    confirmationDialog({buttonText: 'Yes'}, message, function(){
      api.removeMixPlaylist(mix.mixid, function(resp) {
        if (resp.error) {
          $scope.showError(resp.error);
        } else {
          $scope.showSuccess( 'Your Mix Station <b>"' + mix.name + '"</b> has been removed');
          $scope.dataset.splice($scope.dataset.indexOf(mix),1);
          var forceReload = true;
          api.getMusic(forceReload).then(function(result) {
            playlistMusic = music = result;
            initializePlaylistData();
          });
        }
      }, function(err){
        console.error("Error in removeMix called from " + $scope.currentNav + " playlist", err);
        $scope.showError('Unable to delete the Mix Station');
      });
    });
  };

  if (category == 'public') {
    $scope.$on('playlistFiltersInitialized', function(event, data) {
      $scope.filterDataset();
    })
  }

  $scope.openCreateMixStationFromFiltersModal = function () {
    $modal
      .open({
        templateUrl: 'partials/create_mix_station_from_filters_modal.html',
        windowClass: 'create-mix-station-from-filters',
        controller: 'CreateMixStationFromFiltersModal',
        controllerAs: 'vm',
        resolve: {
          activeFilters: function () {
            var filters = {};
            var ratingDetails = {};

            for (var category in musicSelectionCategories) {
              filters[category] = musicSelectionCategories[category]
                .filter(function (filter) {
                  return playlistStationFilter[category].indexOf(filter.id) > -1
                });
            }

            filters['rating'] = [];
            playlistStationFilter.rating.forEach(function(ratingId) {
              ratingDetails = contentRatingService.getContentRatingDetails(ratingId);
              if (ratingDetails) {
                filters.rating.push({ name: ratingDetails.rating });
              }
            })
            return filters;
          },
          filteredStations: function () {
            return $scope.filteredPlaylists;
          },
          me: function () {
            return me;
          },
          userPermissions: function () {
            return userPerms;
          }
        }
      })
      .result
      .catch(angular.noop);
  };

}

app.controller('PlaylistMessagingCtrl', ['$location','$scope', '$timeout', 'confirmationDialog', 'api', 'me', 'messages', 'playlistService', 'streamUpdateService', 'messageSelection', 'subscriptionInfo', 'userPerms', 'prefetchInfoService',
  function($location, $scope, $timeout, confirmationDialog, api, me, messages, playlistService, streamUpdateService, messageSelection, subscriptionInfo, userPerms, prefetchInfoService) {

  $scope.me = api.userObject;
  $scope.currentNav = 'messaging';
  $scope.navType = 'messaging';

  $scope.pageSize = 20;
  $scope.query = '';
  $scope.orderBy = 'name';
  $scope.reverse = false;
  $scope.sortDirection = 'up';
  $scope.order = function(orderBy) {
    return playlistService.order($scope,orderBy);
  };
  $scope.customSort = function() {
    return playlistService.customSort($scope);
  };

  $scope.isNavCollapsed = true;
  $scope.isMobile = false;
  if (BrowserDetect.mobile) {
    $scope.isMobile = true;
  }

  $scope.allowSearch = me.permissions.user.select_messages;
  $scope.isMessageAdmin = (me.permissions.account.owner || me.permissions.account.messages || me.permissions.user.manage_messages);
  $scope.userPerms = userPerms;
  $scope.messageQuantityAllowedPerPreset = subscriptionInfo.messageQuantityAllowedPerPreset();
  if (!$scope.messageQuantityAllowedPerPreset || !$scope.userPerms.canSelectMessages) {
    if ($scope.userPerms.canSelectMusic) {
      return $location.path('/playlists/public');
    } else {
      return $location.path('/admin/zones');
    }
  }
  var selectedStream = streamUpdateService.getSelectedStream() || api.userObject;

  $scope.toggleSearch = function() {
    if ($scope.showSearch) {
      $scope.musicsearch = '';
      $scope.showSearch = false;
    } else {
      $scope.showSearch = true;
    }
  }
  $scope.updateSearch = function() {
    if ($scope.musicsearch && $scope.musicsearch.length > 0) {
      $scope.searchResults = true;
    } else $scope.searchResults = false;
  };

  function initializeMessagePresetData() {
    $scope.dataset = messages.filter(function (item) {
      if (
        item.isGlobal ||
        $scope.userPerms.isMessageAdmin ||
        item.userid === $scope.me.user.userid ||
        selectedStream.message_preset === item.presetid
      ) {
        return true;
      }
    });

    if (selectedStream) {
      $scope.me.message_preset = selectedStream.message_preset;
    }

    $scope.messages_off = false;
    if (selectedStream.message_preset) {
      for (var i = 0; i < $scope.dataset.length; i++) {
        if ($scope.dataset[i].presetid === selectedStream.message_preset) {
          $scope.dataset[i].selected = true;
          break;
        }
      }
    } else {
      $scope.messages_off = true;
    }

    $scope.setTouchActive = function (presetid) {
      $scope.safeApply(function () {
        $scope.touchActive = presetid;
      });
    };

    $scope.checkMessagePreset = function (preset) {
      return ($scope.touchActive === preset.presetid) || (selectedStream.message_preset === preset.presetid);
    };

    $scope.checkMessages = function () {
      if ($scope.me && $scope.me.subscription && $scope.me.subscription.messages > 0 && $scope.me.permissions.user.select_messages && $scope.messages && $scope.messages.length > 0) {
        return 'col-sm-8';
      }

      return 'col-sm-12';
    };
  }

  $scope.isPrefetch = function() {
    var stream = streamUpdateService.getSelectedStream();
    return prefetchInfoService.isPrefetch($scope.me, stream);
  };

  $scope.prefetchTooltip = function() {
    return prefetchInfoService.prefetchTooltip();
  }

  initializeMessagePresetData();
  $scope.$on('newStreamSet', function() {
    api.getMessagesIfUser().then(function(result) {
      messages = result;
      selectedStream = streamUpdateService.getSelectedStream();
      initializeMessagePresetData();
    });
  });

  $scope.selectMessagePreset = function (preset) {
    var previousMessagesOff = $scope.messages_off;
    var previousMessagePreset = $scope.me.message_preset;

    $scope.messages_off = false;

    api.selectMessagePreset(preset.presetid, function (result) {
      var baseMessage = 'The message preset <b>"' + preset.name + '"</b> ';
      if ($scope.isPrefetch()) {
        $scope.showSuccess(baseMessage + ' will be active at the next media download window.');
      } else {
        $scope.showSuccess(baseMessage + 'is now active');
      }

      $scope.me.message_preset = result.stream.message_preset;
      streamUpdateService.setSelectedStream(result.stream);
      streamUpdateService.setStreamsUpdateFlag();
    }, function (err) {
      $timeout(function () {
        $scope.messages_off = previousMessagesOff;
        $scope.me.message_preset = previousMessagePreset;
      });

      console.error('Could not select the message preset.', err);
    });
  };

  $scope.removeMessagePreset = function () {
    var previousMessagePreset = $scope.me.message_preset;

    $scope.me.message_preset = null;

    api.removeMessagePreset(function (result) {
      var baseMessage = 'No messages will be playing';
      if ($scope.isPrefetch()) {
        $scope.showSuccess(baseMessage + ' starting at the next media download window.');
      } else {
        $scope.showSuccess(baseMessage);
      }

      $scope.me.message_preset = null;

      var stream = streamUpdateService.getSelectedStream();
      stream.message_preset = null;

      streamUpdateService.setSelectedStream(stream);
      streamUpdateService.setStreamsUpdateFlag();
      messageSelection.loadPresets();
    },function (err) {
      $scope.messages_off = false;
      $scope.me.message_preset = previousMessagePreset;

      console.error("Could not remove the message preset.", err);
    });
  };

  $scope.removePreset = function(preset) {
    if (preset.presetid === $scope.me.message_preset) {
      return $scope.showError('You cannot delete the preset: ' + preset.name + ', because it is currently in use.  First unselect the preset, and then you may delete it.');
    }

    var message = 'Are you sure you want to delete the message preset ' + preset.name + '?';
    confirmationDialog({buttonText: 'Yes'}, message, function(){
      api.removeMessagePresetById(preset.presetid, function(resp) {
        if (resp.error) {
          $scope.showError(resp.error);
        } else {
          $scope.showSuccess( 'Your preset <b>"' + preset.name + '"</b> has been removed');
          $scope.dataset.splice($scope.dataset.indexOf(preset),1);
          messageSelection.loadPresets();
        }
      },function(err) {
        $scope.showError('Unable to delete the preset <b>"'+preset.name+'"</b>');
      });
    });
  };

  $scope.toggleMenu = function(ev) {
    if (ev.target.classList.contains('toggle-menu')) {
      $scope.isNavCollapsed = !$scope.isNavCollapsed;
    }
    else {
      $scope.isNavCollapsed = true;
    }
  };

  $scope.$watch(function() {
    return streamUpdateService.getSelectedStream();
  }, function(newStream, oldStream) {
    if (newStream && newStream.streamid && (!oldStream || newStream.streamid !== oldStream.streamid || newStream.message_preset != oldStream.message_preset)) {
      var newStreamData = {
        messagePreset: newStream.message_preset,
        messageSchedule: newStream.schedule_id
      };
      messageSelection.setSelection(newStreamData);
      if (newStream.message_preset) {
        $scope.me.message_preset = newStream.message_preset;
        $scope.messages_off = false;
      } else {
        $scope.me.message_preset = null;
        $scope.messages_off = true;
      }
    }
  });

  $scope.$watch(function() {
    return messageSelection.checkPresetSelectionFlag();
  }, function(newSelection, oldSelection) {
    if (newSelection) {
      var selection = messageSelection.getSelection();
      if (selection.message_preset) {
        $scope.me.message_preset = selection.message_preset;
        $scope.messages_off = false;
      } else {
        $scope.me.message_preset = null;
        $scope.messages_off = true;
      }
      messageSelection.clearPresetSelectionFlag();
    }
  });

}]);

app.controller('PlaylistMessageUpgradeCtrl', ['$scope', function($scope) {
}]);

app.controller('PlaylistMessageScheduleCtrl', ['$location', '$scope', '$timeout', 'confirmationDialog', 'api', 'me', 'schedules', 'playlistService', 'editMessageScheduleService', 'streamUpdateService', 'messageSelection', 'subscriptionInfo', 'userPerms', 'prefetchInfoService', 'messageScheduleDuplicationService',
  function($location, $scope, $timeout, confirmationDialog, api, me, schedules, playlistService, editMessageScheduleService, streamUpdateService, messageSelection, subscriptionInfo, userPerms, prefetchInfoService, messageScheduleDuplicationService) {

  for (var i = 0; i < schedules.schedules.length; i++) {
    schedules.schedules[i].lastModified = (new Date(schedules.schedules[i].modified_at)).toString().replace(/\S+\s(\S+)\s(\d+)\s(\d+)\s.*/, '$1 $2, $3');
  }

  $scope.me = me;
  $scope.currentNav = 'messageschedules';
  $scope.navType = 'messaging';

  $scope.pageSize = 20;
  $scope.query = '';
  $scope.orderBy = 'name';
  $scope.reverse = false;
  $scope.sortDirection = 'up';
  $scope.order = function(orderBy) {
    return playlistService.order($scope,orderBy);
  };
  $scope.customSort = function() {
    return playlistService.customSort($scope);
  };

  $scope.isNavCollapsed = true;
  $scope.isMobile = false;
  if (BrowserDetect.mobile) {
    $scope.isMobile = true;
  }
  $scope.allowSearch = me.permissions.user.select_messages;
  $scope.userPerms = userPerms;
  $scope.messageQuantityAllowedPerPreset = subscriptionInfo.messageQuantityAllowedPerPreset();
  var selectedStream = streamUpdateService.getSelectedStream() || api.userObject;

  if (!$scope.messageQuantityAllowedPerPreset || !$scope.userPerms.canSelectMessages) {
    if ($scope.userPerms.canSelectMusic) {
      return $location.path('/playlists/public');
    } else {
      return $location.path('/admin/zones');
    }
  }

  $scope.toggleSearch = function() {
    if ($scope.showSearch) {
      $scope.musicsearch = '';
      $scope.showSearch = false;
    } else {
      $scope.showSearch = true;
    }
  }
  $scope.updateSearch = function() {
    if ($scope.musicsearch && $scope.musicsearch.length > 0) {
      $scope.searchResults = true;
    } else $scope.searchResults = false;
  };

  function initializeMessageScheduleData() {
    $scope.dataset = schedules.schedules.filter(function (item) {
      if (
        item.isGlobal ||
        $scope.userPerms.isMessageAdmin ||
        item.userid === $scope.me.user.userid ||
        selectedStream.schedule_id === item.scheduleid
      ) {
        return true;
      }
    });

    if (selectedStream) {
      $scope.me.schedule_id = selectedStream.schedule_id;
    }

    $scope.messages_off = false;
    if (selectedStream.schedule_id) {
      for (var i = 0; i < $scope.dataset.length; i++) {
        if ($scope.dataset[i].scheduleid === selectedStream.schedule_id) {
          $scope.dataset[i].selected = true;
          break;
        }
      }
    } else {
      $scope.messages_off = true;
    }

    $scope.setTouchActive = function (scheduleid) {
      $scope.safeApply(function () {
        $scope.touchActive = scheduleid;
      });
    };

    $scope.checkMessageSchedule = function (schedule) {
      return ($scope.touchActive === schedule.scheduleid) || (selectedStream.schedule_id === schedule.scheduleid);
    };

    $scope.checkMessages = function () {
      if ($scope.me && $scope.me.subscription && $scope.me.subscription.messages > 0 && $scope.me.permissions.user.select_messages && $scope.messages && $scope.messages.length > 0) {
        return 'col-sm-8';
      }
      return 'col-sm-12';
    };
  }

  initializeMessageScheduleData();
  $scope.$on('newStreamSet', function() {
    api.getMessageSchedules().then(function(result) {
      schedules = result;
      selectedStream = streamUpdateService.getSelectedStream();
      initializeMessageScheduleData();
    });
  });

  $scope.isPrefetch = function() {
    var stream = streamUpdateService.getSelectedStream();
    return prefetchInfoService.isPrefetch($scope.me, stream);
  };

  $scope.prefetchTooltip = function() {
    return prefetchInfoService.prefetchTooltip();
  }

  $scope.selectMessageSchedule = function (schedule) {
    var previousMessagesOff = $scope.messages_off;
    var previousScheduleId = $scope.me.schedule_id;

    $scope.messages_off = false;

    api.selectMessageSchedule(schedule.scheduleid, function (result) {
      var baseMessage = 'The message schedule <b>"' + schedule.name + '"</b> ';
      if ($scope.isPrefetch()) {
        $scope.showSuccess(baseMessage + ' will be active at the next media download window.');
      } else {
        $scope.showSuccess(baseMessage + 'is now active');
      }

      $scope.me.schedule_id = result.stream.schedule_id;
      streamUpdateService.setSelectedStream(result.stream);
      streamUpdateService.setStreamsUpdateFlag();
    },function (err) {
      $timeout(function () {
        $scope.messages_off = previousMessagesOff;
        $scope.me.schedule_id = previousMessageScheduleId;
      });

      console.error('Could not select the message schedule.', err);
    });
  };

  $scope.removeMessageSchedule = function () {
    var previousScheduleId = $scope.me.schedule_id;

    $scope.me.schedule_id = null;

    api.removeMessageSchedule(function (result) {
      var baseMessage = 'No scheduled messages will be playing';
      if ($scope.isPrefetch()) {
        $scope.showSuccess(baseMessage + ' starting at the next media download window.');
      } else {
        $scope.showSuccess(baseMessage);
      }
      messageSelection.loadSchedules();
      $scope.me.schedule_id = null;

      var stream = streamUpdateService.getSelectedStream();
      stream.schedule_id = null;

      streamUpdateService.setSelectedStream(stream);
      streamUpdateService.setStreamsUpdateFlag();
    },function (err) {
      $scope.messages_off = false;
      $scope.me.schedule_id = previousScheduleId;

      console.error("Could not remove the message schedule.", err);
    });
  };

  $scope.duplicateMessageSchedule = function(index, scheduleId) {
    if (me.permissions.user.manage_messages || me.permissions.account.owner || me.permissions.account.messages) {
      $scope.dataset[index].isDuplicating = true;
      $scope.showSuccess('Duplicating the message schedule <b>"' + $scope.dataset[index].name + '"</b>.');

      messageScheduleDuplicationService.duplicate($scope.me.user.userid, scheduleId)
        .then(function (result) {
          delete $scope.dataset[index].isDuplicating;

          var oldSchedule = $scope.dataset[index];

          $scope.dataset.splice(index+1, 0, {
            created_at: oldSchedule.created_at,
            isActive: false,
            isGlobal: false,
            lastModified: oldSchedule.lastModified,
            modified_at: oldSchedule.modified_at,
            name: result.name,
            scheduleid: result.scheduleid,
            userid: $scope.me.user.userid,
            username: $scope.me.user.username
          });
        })
        .catch(function (err) {
          delete $scope.dataset[index].isDuplicating;
          $scope.showError('There was an error attempting to duplicate ' + err.name + '.');
        });
    }
  };


  $scope.removeSchedule = function(schedule) {
    if (schedule.scheduleid === $scope.me.schedule_id) {
      return $scope.showError('You cannot delete the Message: ' + schedule.name + ', because it is currently in use.  First unselect the message, and then you may delete it.');
    }

    var message = 'Are you sure you want to delete the message schedule ' + schedule.name + '?';
    confirmationDialog({buttonText: 'Yes'}, message, function(){
      api.removeMessageScheduleById(schedule.scheduleid, function(resp) {
        if (resp.error) {
          $scope.showError(resp.error);
        } else {
          $scope.showSuccess( 'Your schedule <b>"' + schedule.name + '"</b> has been removed');
          $scope.dataset.splice($scope.dataset.indexOf(schedule),1);
          messageSelection.loadSchedules();
        }
      },function(err) {
        $scope.showError('Unable to delete the schedule <b>"'+schedule.name+'"</b>');
      });
    });
  };

  $scope.toggleMenu = function(ev) {
    if (ev.target.classList.contains('toggle-menu')) {
      $scope.isNavCollapsed = !$scope.isNavCollapsed;
    }
    else {
      $scope.isNavCollapsed = true;
    }
  };

  $scope.createMessageSchedule = function() {
    editMessageScheduleService.addNewSchedule(me.user.username,function(newName) {
      $location.url('/admin/messages/schedule/add/'+newName);
    });
  };

  $scope.$watch(function() {
    return streamUpdateService.getSelectedStream();
  }, function(newStream, oldStream) {
    if (newStream && newStream.streamid && (!oldStream || newStream.streamid !== oldStream.streamid || newStream.schedule_id != oldStream.schedule_id)) {
      var newStreamData = {
        messagePreset: newStream.message_preset,
        messageSchedule: newStream.schedule_id
      };
      messageSelection.setSelection(newStreamData);
      if (newStream.schedule_id) {
        $scope.me.schedule_id = newStream.schedule_id;
        $scope.messages_off = false;
      } else {
        $scope.me.schedule_id = null;
        $scope.messages_off = true;
      }
    }
  });

  $scope.$watch(function() {
    return messageSelection.checkScheduleSelectionFlag();
  }, function(newSelection, oldSelection) {
    if (newSelection) {
      var selection = messageSelection.getSelection();
      if (selection.schedule_id) {
        $scope.me.schedule_id = selection.schedule_id;
        $scope.messages_off = false;
      } else {
        $scope.me.schedule_id = null;
        $scope.messages_off = true;
      }
      messageSelection.clearScheduleSelectionFlag();
    }
  });

}]);

(function (app) {
  app.controller('ResetPasswordController', ResetPasswordController);

  ResetPasswordController.$inject = ['$state', '$stateParams', 'api', 'passwordResetUser', 'userNotificationService'];

  function ResetPasswordController($state, $stateParams, api, passwordResetUser, userNotificationService) {
    var vm = this;

    // Properties
    vm.formdata = {
      username: undefined,
      password: undefined
    };
    vm.isResetTokenExpired = undefined;
    vm.isResetTokenNotFound = undefined;
    vm.isResetTokenUnknownError = undefined;
    vm.passwordVerify = undefined;
    vm.resetTokenHasError = undefined;

    // Methods
    vm.submit = submit;

    // Startup
    init();

    function init() {
      vm.resetTokenHasError = passwordResetUser.isError;
      vm.isResetTokenExpired = passwordResetUser.isResetTokenExpired;
      vm.isResetTokenNotFound = passwordResetUser.isResetTokenNotFound;

      if (passwordResetUser.isError) {
        if (!passwordResetUser.isResetTokenExpired && !passwordResetUser.isResetTokenNotFound) {
          vm.isResetTokenUnknownError = true;
        }

        return;
      }

      vm.formdata.username = passwordResetUser.data.username;
    }

    function submit(formController) {
      if (formController.$invalid) {
        return;
      }

      api.resetPassword(vm.formdata.username, vm.formdata.password, $stateParams.token)
        .then(function () {
          userNotificationService.addSuccessMessage('Your password has been reset');
          $state.go('loggedout.login');
        })
        .catch(function (response) {
          var msg = response && response.data && response.data.message;
          if (!msg) {
            msg = 'An unknown error occurred. Error code: ' + response.status;
          }

          userNotificationService.addErrorMessage(msg);
        });
    }

  }

})(app);

(function (app) {
  app.controller('SonosLoginController', SonosLoginController);

  SonosLoginController.$inject = ['$state', 'api', 'authenticationService', 'linkCode', 'requirements'];

  function SonosLoginController($state, api, authenticationService, linkCode, requirements) {
    var vm = this;

    // Properties
    vm.duo = {
      isLoading: false,
      show: false
    };
    vm.errorMessage = undefined;
    vm.errors = {
      primaryAuthentication: undefined,
      secondaryAuthentication: undefined,
      authorization: undefined
    };
    vm.form = {
      password: '',
      username: undefined
    };
    vm.linkCode = linkCode;
    vm.isSubmitting = false;

    // Methods
    vm.onDuoLoaded = onDuoLoaded;
    vm.submit = submit;

    // Public methods

    function onDuoLoaded($event) {
      var iframe = $event.target;
      var isDuoInitialized = Boolean(iframe.getAttribute('src'));

      // The Duo `iframe` will emit a `load` event before Duo has been initialized
      if (isDuoInitialized) {
        vm.duo.show = true;
      }

      vm.duo.isLoading = false;
    }

    function submit() {
      if (!vm.form.username || !vm.form.password) {
        return vm.errorMessage = 'Please fill out all the fields';
      }

      vm.isSubmitting = true;

      authenticationService.login(vm.form.username, vm.form.password)
        .then(function (data) {
          if (data && data.signedRequest) {
            vm.errors.authentication = undefined;
            vm.isLoginSuccessful = true;
            vm.duo.isLoading = true;

            initDuo(data.signedRequest);
          } else {
            loadUserData();
          }
        })
        .catch(function (err) {
          vm.isSubmitting = false;

          var message = 'Unable to log in. Unknown error.';
          if (err && err.message) {
            message = err.message;
          }

          vm.errorMessage = message;
        })
        .finally(function () {
          vm.isSubmitting = false;
        });
    }

    function loadUserData() {
      api.getMe()
        .then(function (result) {
          api.checkAccountRequirements(result.user.custid, function (resultRequirements) {
            requirements.save(resultRequirements);

            api.getSubscription()
              .then(function () {
                api.getAccount(result.account.custid, function () {
                  var validUserActions = function () {
                    if (result.permissions.account.owner || result.permissions.user.can_play_music || result.permissions.account.music || result.permissions.account.messages) {
                      $state.go('sonos.registration', { linkcode: vm.linkCode });
                    } else {
                      vm.isSubmitting = false;
                      vm.errorMessage = 'The supplied account credentials are invalid.';
                    }
                  };

                  validUserActions();
                });
              });
          });
        });
    }

    // Private methods

    function buildAuthenticationErrorMessage(response) {
      var message;

      if (response.data && response.data.message) {
        message = response.data.message;
      } else if (response.status === -1) {
        message = 'The request was aborted.';
      } else {
        message = response.status;

        if (response.statusText) {
          message += ' - ' + response.statusText;
        }
      }

      return message;
    }

    function initDuo(signedDuoRequest) {
      authenticationService.initDuo(signedDuoRequest)
        .then(function () {
          loadUserData();
        })
        .catch(function (response) {
          var message = buildAuthenticationErrorMessage(response);

          vm.errors.secondaryAuthentication = {
            message: message
          };
        });
    }

  }

})(app);

(function (app) {
  app.controller('SonosRegistrationCtrl', SonosRegistrationController);

  SonosRegistrationController.$inject = ['api', 'linkCode', 'playerConfirmationModal', 'streams'];

  function SonosRegistrationController(api, linkCode, playerConfirmationModal, streamList) {
    var vm = this;

    // Properties
    vm.errorMessage = undefined;
    vm.form = {
      streamId: undefined
    };
    vm.formSuccess = false;
    vm.isSubmitting = false;
    vm.resultMessage = undefined;
    vm.streams = streamList.streams;

    // Methods
    vm.submit = submit;

    // Lifecycle hooks
    init();

    function init() {
      if (!linkCode) {
        vm.errorMessage = 'Your device could not be identified. Please try again.';
        vm.streams = [];
      }
    }

    // Public methods

    function submit() {
      var isStreamAssignedToDevice;
      var stream;

      if (!vm.form.streamId) {
        return;
      }

      vm.isSubmitting = true;

      vm.streams.forEach(function (s) {
        if (s.streamid === vm.form.streamId) {
          stream = s;
        }
      });

      isStreamAssignedToDevice = Boolean(stream.deviceid);

      if (isStreamAssignedToDevice) {
        playerConfirmationModal({
          stream: stream,
          title: 'Register Device',
        }, function () {
          initSonosDevice()
            .finally(function () {
              vm.isSubmitting = false;
            });
        });
      } else {
        initSonosDevice()
          .finally(function () {
            vm.isSubmitting = false;
          });
      }
    }

    // Private methods

    function initSonosDevice() {
      return api.initializeSonosDevice(linkCode, vm.form.streamId)
        .then(function () {
          vm.formSuccess = true;
          vm.resultMessage = 'Successfully registered device. Return to Sonos App to complete setup process.';
        })
        .catch(function (response) {
          vm.resultMessage = 'Error: ' + response.data.message;
        });
    }
  }

})(app);

app.service("googleTagManager", ["$window", function ($window) {
  this.push = function (data) {
    if($window.dataLayer) {
      $window.dataLayer.push(data);
    } else {
      console.error('window.dataLayer is not defined.');
    }
  };
}]);

app.factory('requirements', ['$cookies', '$location', '$rootScope', '$state', 'api', 'navigationService',
  function ($cookies, $location, $rootScope, $state, api, navigationService) {
    return {
      loaded: false,
      cache: {},
      fulfilled: false,
      showNotification: false,

      save: function (data) {
        this.loaded = true;
        this.cache = data.requirements;
      },

      reset: function () {
        this.loaded = false;
        this.cache = {};
        this.fulfilled = false;
      },

      check: function (stateChangeEvent, toState, toParams, callback) {
        var self = this;
        var allowPaths = [
          '/login',
          '/logout',
          '/error',
          '/password_request?linkcode',
          '/admin/terms',
          '/sonos/login?linkcode'
        ];
        var toUrl = toState.url || '';

        if (toState.name === 'sonos.registration') {
          if (!api.userObject.user) {
            stateChangeEvent.preventDefault();

            $cookies.remove('Authorization');
            $cookies.remove('Token');

            navigationService.stateChangeData.forceNextTransition = true;
            $state.go('sonos.login', toParams);

            return callback();
          }
        }

        if (this.fulfilled || allowPaths.indexOf(toUrl) >= 0 || (toUrl.indexOf('/webautologin/') === 0) || (toUrl.indexOf('/password_reset/') === 0)
          || (this.loaded && !this.cache.HasCorporateAddress && (toUrl == '/admin/corporateaddress/edit' || toUrl == '/admin/billing'))
          || (this.loaded && !this.cache.AllLocationsWithAddress && ((toUrl == '/admin/locations') || (toUrl.indexOf('/admin/locations/') === 0 && toUrl.indexOf('/edit') > 0)))
          || (this.loaded && !this.cache.HasAcceptedTerms && (toUrl == '/admin/terms'))
        ) {
          return callback();
        }

        var stateTransitionCancelled = false;
        if (this.loaded && (!this.cache.HasCorporateAddress || !this.cache.AllLocationsWithAddress)) {

          // Prevent the current state transition
          stateChangeEvent.preventDefault();

          stateTransitionCancelled = true;
        }

        api.getMe()
          .then(function (userObject) {
            if (self.loaded) {
              self.process(callback, userObject, toState, toParams, stateTransitionCancelled);
            } else {
              api.checkAccountRequirements(userObject.user.custid, function (data) {
                self.save(data);
                self.process(callback, userObject, toState, toParams, stateTransitionCancelled);
              });
            }
          })
          .catch(function () {

            // Prevent the current state transition
            stateChangeEvent.preventDefault();

            $state.go('error');
          });
      },

      process: function (callback, userObject, toState, toParams, stateTransitionCancelled) {
        $rootScope.loadingContent = false;

        if (userObject.permissions.account.owner && userObject.subscription.state === 'active') {
          if (!this.cache.HasCorporateAddress) {
            this.showNotification = true;

            if ($state.current.name !== 'account.admin.editCorporateAddress') {
              navigationService.stateChangeData.forceNextTransition = true;
              $state.go('account.admin.editCorporateAddress');
            }

            return;
          } else if (!this.cache.AllLocationsWithAddress) {
            this.showNotification = true;

            if ($state.current.name !== 'account.admin.locations') {
              navigationService.stateChangeData.forceNextTransition = true;
              $state.go('account.admin.locations');
            }

            return;
          }
        }

        this.showNotification = false;
        $rootScope.loadingContent = true;
        this.fulfilled = true;

        if (toState && stateTransitionCancelled) {
          navigationService.stateChangeData.forceNextTransition = true;
          $state.go(toState.name, toParams);
        }

        if (callback) {
          callback();
        }
      }
    };
  }
]);

app.factory('api',['$http', '$cookies', 'base64', '$q', '$location', '$state', 'ENV', 'Upload',
  function ($http, $cookies, base64, $q, $location, $state, ENV, Upload) {
    return {
      APIKey: $cookies.get('Token') || '',
      userObject: {},
      plans: null,
      groups: null,
      subscription: null,
      messagePresets: null,
      musicSelection: null,
      root: ENV.apiUrl,
      webUrl: ENV.webUrl,
      deviceStateUrl: ENV.deviceStateUrl,

      handleError: function (response) {
        console.log('Handling error', response);
      },

      registerToken: function (uuid, userid) {
        this.userObject = {};
        this.subscription = null;
        this.musicSelection = null;
        this.messagePresets = null;
        this.groups = null;
        $cookies.put('Token', uuid);
        this.APIKey = uuid;
        $cookies.put('Authorization', 'Basic ' + base64.encode(userid + ':' + uuid));
        window.location.href = '/#/playlists';
      },

      login: function (details, callback, error) {
        var self = this;

        // 2018-03-05 tbrown This cookie is set/updated by registerDevice()
        if ($cookies.get('Device')) {
          details.device_uuid = $cookies.get('Device');
        }

        $http({
          url: this.root + '/token',
          data: details,
          method: 'POST',
        }).then(function (response) {
          var data = response.data;

          // API endpoint does not return a token when MFA is enabled
          if (data && data.token) {
            $cookies.put('Token', data.token);
            self.APIKey = data.token;
            $cookies.put('Authorization', 'Basic ' + base64.encode(data.userid + ':' + data.token));
          }

          if (typeof callback !== 'undefined') {
            callback(data);
          }
        }).catch(function (response) {
          var data = response.data;

          if (!data) {
            data = 'Unknown error';
          }

          error(data);
        });
      },

      loginMfa: function (signedResponse) {
        var deferred = $q.defer();
        var url = this.root + '/token/mfa';
        var data = {
          sigResponse: signedResponse,
          from: 'internaladmin'
        };

        // This cookie is set/updated by registerDevice()
        if ($cookies.get('Device')) {
          data.device_uuid = $cookies.get('Device');
        }

        $http.post(url, data)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response);
          });

        return deferred.promise;
      },

      impersonateUser: function (username) {
        var url = this.root + '/token/impersonation';
        var data = {
          username: username
        };

        // This cookie is set/updated by registerDevice()
        if ($cookies.get('Device')) {
          data.device_uuid = $cookies.get('Device');
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      logout: function (details, callback, error) {
        var self = this;

        $http({
          url: this.root + '/token',
          method: 'DELETE',
        }).then(function (response) {
          $cookies.remove('Authorization');
          $cookies.remove('Token');
          self.userObject = {};
          self.subscription = null;
          self.musicSelection = null;
          self.messagePresets = null;
          self.groups = null;
          if (typeof callback !== 'undefined') {
            callback(response.data);
          }
        }).catch(function (response) {
          error(response.data);
        });
      },

      checkAPIStatus: function () {
        var defer = $q.defer();

        $http.get(this.root + '/status')
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getMe: function (forceReload) {
        var defer = $q.defer();
        var self = this;

        if (this.userObject && this.userObject.user && this.userObject.device_id && forceReload != 1) {
          defer.resolve(self.userObject);
        } else {
          if (this.getMeRequest) {
            return this.getMeRequest;
          }

          this.getMeRequest = defer.promise;

          $http.get(this.root + '/me')
            .then(function (response) {
              var data = response.data;

              self.userObject = {
                user: data.user,
                streamid: data.streamid,
                account: data.account,
                active_player: data.active_player,
                device_id: data.device_id,
                music_id: data.music_id,
                music_type: data.music_type,
                message_preset: data.message_preset,
                schedule_id: data.schedule_id,
                permissions: data.permissions,
                recurly: {
                  account_code: data.account.recurly
                },
                company_station: data.company_station,
                has_company_stations: data.has_company_stations,
                subscription: data.subscription,
                allow_ad_network: data.allow_ad_network,
                impersonation: data.impersonation
              };

              defer.resolve(self.userObject);
              self.getMeRequest = null;
            })
            .catch(function (response) {
              var data = response.data;
              defer.reject(response.data);

              self.getMeRequest = null;

              if (data && data.code === 'NotAuthorized') {
                $cookies.remove('Authorization');
                $cookies.remove('Token');
                $state.go('loggedout.login');
              }
            });
        }

        return defer.promise;
      },

      // 2018-01-04 tbrown  This is currently only used to remove a group!
      removeItem: function (item) {
        var defer = $q.defer();

        $http({
          url: this.root + item,
          method: 'DELETE',
        })
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      activatePlayer: function (callback) {
        $http.put(this.root + '/activate?token=' + this.APIKey)
          .then(function (response) {
            callback(null, response.data);
          })
          .catch(function (response) {
            callback(response.status, response.data);
          });
      },

      getPayment: function (forceReload) {
        var defer = $q.defer();
        var self = this;

        if (this.userObject.payment && forceReload !== 1) {
          defer.resolve(self.userObject.payment);
        } else {
          if (!this.userObject.permissions.account.owner && !this.userObject.permissions.account.payment) {
            defer.resolve({});
          } else {
            $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/payment')
              .then(function (response) {
                var data = response.data;

                self.userObject.payment = data.billing;
                defer.resolve(data.billing);
              })
              .catch(function (response) {
                defer.resolve(response.data.message);
              });
          }
        }

        return defer.promise;
      },

      getSubscription: function (params) {
        var defer = $q.defer();
        var self = this;
        var requestConfig = null;

        var useCachedSubscription =
          this.userObject.subscription
          && ((this.userObject.recurly && this.userObject.recurly.state) || (params && params.skipBilling));

        if (useCachedSubscription) {
          defer.resolve(self.userObject.subscription);
        } else {
          if (params && params.skipBilling) {
            requestConfig = {
              params: { skipBilling: true }
            };
          }

          $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/subscription', requestConfig)
            .then(function (response) {
              var data = response.data;

              self.userObject.subscription = data.subscription;

              if (data.recurly) {
                var accountCode = self.userObject.recurly.account_code;

                self.userObject.recurly = data.recurly;
                self.userObject.recurly.account_code = accountCode;
              }
              defer.resolve(data.subscription);
            })
            .catch(function (response) {
              defer.reject(response.data);
            });
        }

        return defer.promise;
      },

      getAccountCouponRedemptions: function () {
        var defer = $q.defer();
        var self = this;

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/coupons')
          .then(function (response) {
            var redemptions = response.data.redemptions;

            self.userObject.recurly.subscription_coupon = redemptions;
            defer.resolve(redemptions);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getAccountInvoices: function () {
        return $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/invoices')
          .then(function (response) {
            var invoices = response.data.invoices;
            return invoices;
          });
      },

      getHostedToken: function () {
        return $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/hosted-token')
          .then(function (response) {
            return response.data.token;
          });
      },

      downloadInvoicePdf: function (invoiceNumber) {
        return $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/invoices/' + invoiceNumber + '/pdf',
          { responseType: 'arraybuffer' }
        )
          .then(function (response) {
            var blob = new Blob([response.data], { type: 'application/pdf' });
            var objectUrl = URL.createObjectURL(blob);
            return objectUrl;
          });
      },

      getBalance: function (custid) {
        var defer = $q.defer();

        $http.get(this.root + '/accounts/' + custid + '/recurlybalance')
          .then(function (response) {
            defer.resolve(response.data.balance_in_cents);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getContentRatings: function () {
        var url = this.root + '/content-ratings';
        var deferred = $q.defer();

        $http.get(url)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(deferred.reject);

        return deferred.promise;
      },

      removeMessagePreset: function (callback, error) {
        $http({
          url: this.root + '/streams/' + this.userObject.streamid + '/message_preset',
          method: 'DELETE',
        })
          .then(function (response) {
            if (typeof callback !== 'undefined') {
              callback(response.data);
            }
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      removeMessageSchedule: function (callback, error) {
        $http({
          url: this.root + '/streams/' + this.userObject.streamid + '/schedule',
          method: 'DELETE',
        })
          .then(function (response) {
            if (typeof callback !== 'undefined') {
              callback(response.data);
            }
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkMessageScheduleNameEdit: function (name, messageScheduleId, callback, error) {
        var url = this.root + '/messageScheduleCheck/checkNameEdit';
        var config = {
          params: {
            name: name
          }
        };

        if (messageScheduleId) {
          config.params.scheduleid = messageScheduleId;
        }

        $http.get(url, config)
          .then(function (response) {
              callback(response.data);
          })
          .catch(function (response) {
              error(response.data);
          });
      },

      getUserDetails: function (id, callback, error) {
        $http.get(this.root + '/users/' + id)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      postUserFavorites: function (userId, action, resources) {
        var body = {
          action: action,
          resources: resources
        };
        return $http.post(this.root + '/users/' + userId + '/favorites', body)
          .then(function (response) {
            return response.data;
          })
          .catch(function (error) {
            return error;
          });
      },

      addUserFavorites: function (userId, resources) {
        return this.postUserFavorites(userId, 'add', resources);
      },

      removeUserFavorites: function (userId, resources) {
        return this.postUserFavorites(userId, 'remove', resources);
      },

      getUserFavorites: function (userId) {
        return $http.get(this.root + '/users/' + userId + '/favorites')
          .then(function (response) {
            return response.data;
          })
          .catch(function (error) {
            return error;
          });
      },

      searchArtist: function (userId, query) {
        return $http.get(this.root + '/artistRadio/' + userId + '/searchArtist?query=' + query)
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      getMostLikedArtists: function (userId) {
        return $http.get(this.root + '/artistRadio/' + userId + '/mostLikedArtists')
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      postArtistRadioStation: function (userId, stationId, command) {
        command.deviceUuid = $cookies.get('Device');
        return $http.post(this.root + '/artistRadio/' + userId + '/stations/' + stationId, command)
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      getArtistRadioStations: function (userId) {
        return $http.get(this.root + '/artistRadio/' + userId + '/stations')
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      createArtistRadioStation: function (userId, pandoraId) {
        return $http.post(this.root + '/artistRadio/' + userId + '/stations', { pandoraId: pandoraId })
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      removeArtistRadioStation: function (userId, stationId) {
        return $http.delete(this.root + '/artistRadio/' + userId + '/stations/' + stationId)
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      postArtistRadioFeedback: function (userId, feedback) {
        var body = {
          operation: feedback.operation,
          contextId: feedback.contextId,
          targetId: feedback.targetId,
          trackToken: feedback.trackToken,
          deviceUuid: $cookies.get('Device'),
          value: feedback.value
        };
        return $http.post(this.root + '/artistRadio/' + userId + '/feedback', body)
          .then(function (response) {
            if (response.status === 200) {
              return response.data;
            } else {
              throw new Error(response);
            }
          });
      },

      getDeviceDetails: function (id) {
        var defer = $q.defer();

        $http.get(this.root + '/devices/' + id + '?token=' + this.APIKey)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getCloudBoxDetails: function (id) {
        var defer = $q.defer();

        $http.get(this.root + '/cloudbox/id/' + id)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      selectMusic: function (type, id, streamid, when, callback, error) {
        if (!streamid) {
          return error({
            code: 'MissingParameterError',
            message: 'No streamid'
          });
        }

        var data = {
          music_type: type,
          music_id: id,
          when: when
        };

        $http.put(this.root + '/streams/' + streamid + '/music', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getMusicSelectionCategories: function () {
        var defer = $q.defer();

        $http.get(this.root + '/public/music/categories')
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getMusic: function (forceReload) {
        var defer = $q.defer();
        var self = this;

        if (this.musicSelection && !forceReload) {
          defer.resolve(this.musicSelection);

          return defer.promise;
        }

        $http.get(this.root + '/music')
          .then(function (response) {
            var data = response.data;

            if (data.mix && data.mix.length) {
              data.mix = data.mix.map(function (item) {
                item.type = 'mix';
                item.musicid = item.mixid;

                return item;
              });
            }

            if (data.dayparting && data.dayparting.length) {
              data.dayparting = data.dayparting.map(function (item) {
                item.type = 'dayparting';
                item.musicid = item.daypartingid;

                return item;
              });
            }

            if (data['public'] && data['public'].length) {
              data['public'] = data['public'].map(function (item) {
                item.type = 'playlist';
                item.musicid = item.playlistid;

                return item;
              });
            } else {
              data['public'] = [];
            }

            self.musicSelection = data;

            defer.resolve(data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      /*
       * Looks like this method isn't used anywhere in Tune -fmadden 02/14/20
       */
      issueCommand: function (command, callback, error) {
        var target;
        if (command.target) {
          target = command.target;
        } else {
          target = this.userObject.user.userid;
        }

        var data = {
          command: command.command,
          custid: this.userObject.account.custid,
          target: target
        };

        $http.post(this.root + '/users/' + this.userObject.user.userid + '/commands', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      toggleAdNetwork: function(streamid, enableAdNetwork) {
        var deferred = $q.defer();

        var data = {
          ad_network: enableAdNetwork
        };

        $http.put(this.root + '/streams/' + streamid + '/ad_network', data)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response.data);
          });

        return deferred.promise;
      },

      selectMessagePreset: function (presetid, callback, error) {
        var data = {
          message_preset: presetid
        };

        $http.put(this.root + '/streams/' + this.userObject.streamid + '/message_preset', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      selectMessageSchedule: function (scheduleid, callback, error) {
        var data = {
          schedule_id: scheduleid
        };

        $http.put(this.root + '/streams/' + this.userObject.streamid + '/schedule', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getMessageRequests: function () {
        var defer = $q.defer();

        $http.get(this.root + '/messages/requests')
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      editUser: function (data, callback, error) {
        $http.put(this.root + '/users/' + data.userid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      editRegion: function (data, callback, error) {
        $http.put(this.root + '/groups/' + data.groupid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      addNewUser: function (data, callback, error) {
        $http.post(this.root + '/accounts/' + this.userObject.account.custid + '/users', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      requestMessage: function (data, callback, error) {
        data.custid = this.userObject.account.custid;

        $http.post(this.root + '/messages/requests', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      privatizeRequest: function (id, data, callback) {
        var self = this;

        $http.put(this.root + '/accounts/privatize/' + id, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      submitCancellation: function (data, callback, error) {
        $http.put(this.root + '/accounts/' + this.userObject.account.custid + '/cancel', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getCancellation: function (id, callback, error) {
        $http.get(this.root + '/accounts/' + id + '/cancellation')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      addRegion: function (data, callback, error) {
        data.custid = this.userObject.account.custid;

        $http.post(this.root + '/groups', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      /*
       * Looks like this method isn't used anywhere in Tune -fmadden 02/14/20
       */
      getRegionDetails: function (id, callback, error) {
        $http.get(this.root + '/groups/' + id)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getAccount: function (id, callback, error) {
        var self = this;

        $http.get(this.root + '/accounts/' + id)
          .then(function (response) {
            if (callback) {
              callback(response.data);
            }
          })
          .catch(function (response) {
            self.handleError(response.data);

            if (error) {
              error(response);
            }
          });
      },

      editAccount: function (id, data, callback, error) {
        $http.put(this.root + '/accounts/' + id, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      /*
       * Looks like this method isn't used anywhere in Tune -fmadden 02/14/20
       */
      getAccountCoupons: function (id, callback) {
        var self = this;

        $http.get(this.root + '/accounts/' + id + '/coupons')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      setManualBilling: function (id, data, callback) {
        var self = this;

        $http.put(this.root + '/accounts/' + id + '/manualbilling', data)
          .then(function (response) {
            self.userObject.recurly.collection_method = data.manual_bill ? 'manual' : 'automatic';

            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      getPlans: function () {
        var self = this;
        var deferred = $q.defer();
        var url = this.root + '/plans';

        if (this.plans) {
          deferred.resolve(this.plans);
        } else {
          $http.get(url)
            .then(function (response) {
              var data = response.data;

              self.plans = data.plans;
              deferred.resolve(data);
            })
            .catch(deferred.reject);
        }

        return deferred.promise;
      },

      getEnterprisePlans: function () {
        var self = this;
        var deferred = $q.defer();
        var url = this.root + '/plans/enterprise';

        $http.get(url)
          .then(function (response) {
            var data = response.data;

            self.enterprise_plans = data.enterprise;
            deferred.resolve(data);
          })
          .catch(deferred.reject);

        return deferred.promise;
      },

      //  TODO: cleanup
      getGroups: function (callback) {
        var self = this;

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/groups')
          .then(function (response) {
            var data = response.data;

            self.groups = data;
            if (typeof callback !== 'undefined') {
              callback(data);
            }
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      createMixPlaylist: function (data, callback, error) {
        $http.post(this.root + '/mix', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      editMixPlaylist: function (data, callback, error) {
        $http.put(this.root + '/mix/' + data.mixid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getMixPlaylists: function (page) {
        var deferred = $q.defer();

        page = page || 1;

        // TODO: custid sent here grab privates from api side
        var url = this.root + '/accounts/' + this.userObject.account.custid + '/mix';
        var config = {
          params: {
            page: page
          }
        };

        $http.get(url, config)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(deferred.reject);

        return deferred.promise;
      },

      getMixDetails: function (mixid) {
        var defer = $q.defer();

        $http.get(this.root + '/mix/' + mixid)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(defer.reject);

        return defer.promise;
      },

      getMixDetailsBatch: function (mixids) {
        var defer = $q.defer();

        var url = this.root + '/mix/';
        var config = { params: { mixid: mixids.join(',') } };

        $http.get(url, config)
          .then(function (response) {
            var data = response.data;

            if (mixids.length === 1 && data.mix_playlist && data.mix_playlist.mixid) {
              var out = {};
              out[data.mix_playlist.mixid] = data.mix_playlist;
              defer.resolve(out);
            } else {
              defer.resolve(data);
            }

          })
          .catch(defer.reject);

        return defer.promise;
      },

      removeMixPlaylist: function (mixid, callback, error) {
        $http({
          url: this.root + '/mix/' + mixid,
          method: 'DELETE',
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      createDayparting: function (data, callback, error) {
        data.timeUnits = 'minutes';

        $http.post(this.root + '/dayparting', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      editDayparting: function (data, callback, error) {
        data.timeUnits = 'minutes';

        $http.put(this.root + '/dayparting/' + data.daypartingid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getDayPartingPresets: function (page) {
        var defer = $q.defer();

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/dayparting?page=' + (page || 1))
          .then(function (response) {
            defer.resolve(response.data);
          });

        return defer.promise;
      },

      getDayPartingDetails: function (daypartingid) {
        var defer = $q.defer();

        $http.get(this.root + '/dayparting/' + daypartingid + '?timeUnits=minutes')
          .then(function (response) {
            defer.resolve(response.data);
          });

        return defer.promise;
      },

      getDayPartingDetailsBatch: function (daypartingIds) {
        var defer = $q.defer();
        var url = this.root + '/dayparting/';
        var config = {
          params: {
            daypartingid: daypartingIds.join(','),
            timeUnits: 'minutes'
          }
        };

        $http.get(url, config)
          .then(function (response) {
            var data = response.data;

            if (daypartingIds.length === 1 && data.day_parting && data.day_parting.daypartingid) {
              var out = {};
              out[data.day_parting.daypartingid] = data.day_parting;
              defer.resolve(out);
            } else {
              defer.resolve(data);
            }

          })
          .catch(defer.reject);

        return defer.promise;
      },


      removeDayparting: function (daypartingid, callback, error) {
        $http({
          url: this.root + '/dayparting/' + daypartingid,
          method: 'DELETE',
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getCompanyStations: function (data) {
        var defer = $q.defer();

        $http.get(this.root + '/accounts/' + data.account.custid + '/companyStations')
          .then(function (response) {
            var data = response.data;

            data.public = [];
            data.mix = [];
            data.dayparting = [];

            if (!data.companyStationDetails) {
              return defer.resolve(data);
            }

            for (var i = 0; i < data.companyStationDetails.length; i++) {
              if (data.companyStationDetails[i].type === 'playlist' && data.companyStationDetails[i].isActive) {
                data.public.push(data.companyStationDetails[i]);
              } else if (data.companyStationDetails[i].type === 'mix') {
                if (data.companyStationDetails[i].mixDeleted) {
                  data.companyStationDetails.splice(i--,1);
                } else {
                  data.mix.push(data.companyStationDetails[i]);
                }
              } else if (data.companyStationDetails[i].type === 'dayparting') {
                if (data.companyStationDetails[i].dpDeleted) {
                  data.companyStationDetails.splice(i--,1);
                } else {
                  data.dayparting.push(data.companyStationDetails[i]);
                }
              }
            }

            defer.resolve(data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      createCompanyStation: function (data) {
        var url = this.root + '/companyStation';

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      editCompanyStation: function (data) {
        var url = this.root + '/companyStations/' + data.companyStationid;

        return $http.put(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      limitAllLocations: function (data) {
        var defer = $q.defer();

        $http.put(this.root + '/companyStations/' + data.account.custid + '/limitAllLocations', data)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      undoLimitAllLocations: function (data) {
        var defer = $q.defer();

        $http.put(this.root + '/companyStations/' + data.account.custid + '/undoLimitAllLocations', data)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      toggleLimitLocation: function (custId, userId) {
        var defer = $q.defer();

        var data = {
          companyStationid: custId,
          user: {
            userid: userId
          }
        };

        $http.put(this.root + '/companyStations/' + data.companyStationid + '/toggleLimitLocation', data)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getDevices: function (userid, callback, error) {
        $http.get(this.root + '/users/' + userid + '/devices')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getActiveDevicesForUser: function (userid, custid, callback, error) {
        $http.get(this.root + '/users/' + userid + '/activeDevices?custid=' + custid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getUserCloudBox: function (userid, callback) {
        var self = this;

        $http.get(this.root+'/users/' + userid + '/cloudboxStatus')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      // TODO: cleanup
      activateDevice: function (deviceid, streamid, callback) {
        var userObj = this.userObject;

        $http.put(this.root + '/devices/' + deviceid + '/activate', { streamid: streamid, appversion: ENV.version })
          .then(function (response) {
            userObj.streamid = streamid;

            callback(null, response.data);
          })
          .catch(function (response) {
            callback(response.status, response.data);
          });
      },

      // TODO: cleanup
      registerDevice: function (callback) {
        var data = {
          name: BrowserDetect.browser + ' browser App',
          description: navigator.userAgent,
          uuid: chance.guid(),
          type: 'pc',
          custid: this.userObject.account.custid,
          userid: this.userObject.user.userid,
          isUnregistered: 0,
          appversion: ENV.version
        };

        $http.post(this.root + '/devices', data)
          .then(function (response) {
            document.cookie = 'Device=' + data.uuid + '; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/';

            callback(null, response.data);
          })
          .catch(function (response) {
            callback(response.status, response.data);
          });
      },

      initializeSonosDevice: function (linkCode, streamId) {
        var deferred = $q.defer();
        var url = this.root + '/sonos/initializeDevice';
        var data = {
          linkcode: linkCode,
          streamid: streamId
        };

        $http.post(url, data)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response);
          });

        return deferred.promise;
      },

      getMusicIfUser: function () {
        var self = this;
        var reload = $location.search().reg ? 1 : null;

        return self.getMe(reload)
          .then(function (data) {

            // TODO: Decouple routing logic from API request logic.
            var isUserAllowedToAccessMusicArea =
              (
                data.permissions.account.owner
                ||
                (
                  data.permissions.user.can_play_music
                  && (data.permissions.user.select_music || data.permissions.user.manage_music)
                )
              );
            var isUserAllowedToAccessAccountArea =
              data.permissions.account.owner
              || data.permissions.account.payment
              || data.permissions.account.music
              || data.permissions.account.messages;
            if (!isUserAllowedToAccessMusicArea && isUserAllowedToAccessAccountArea) {
              $state.go('account.admin.streams');
            }

            var isUserAllowedToAccessMusic =
              data.permissions.account.owner
              || (data.permissions.user.can_play_music && (data.permissions.user.select_music || data.permissions.user.manage_music));
            if (isUserAllowedToAccessMusic) {
              return self.getMusic();
            }
          });
      },

      getMessagesIfUser: function () {
        var self = this;

        return self.getMe()
          .then(function (data) {
            var isUserAllowedToAccessMessages =
              data.permissions.account.owner
              || (data.permissions.user.can_play_music && (data.permissions.user.select_messages || data.permissions.user.manage_messages));
            if (isUserAllowedToAccessMessages) {
              return self.getPresets(1)
                .then(function (data) {
                  return data.presets;
                });
            }
          });
      },

      getMyCompanyStations: function () {
        var self = this;
        var defer = $q.defer();

        self.getMe()
          .then(self.getCompanyStations.bind(self))
          .then(function (data) {
            defer.resolve(data);
          });

        return defer.promise;
      },

      getUsers: function (page, callback, error) {
        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/users?page=' + (page || 1))
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getMediaLikeBatch: function (mediaLikes) {
        var url = this.root + '/media-likes/batch-get';
        var data = {
          mediaLikes: mediaLikes
        };

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      createMediaLike: function (userId, mediaId, playlistId, playlistName) {
        var url = this.root + '/media-likes';
        var data = {
          userId: userId,
          mediaId: mediaId,
          playlistId: playlistId
        };

        if (!playlistId) {
          data.playlistName = playlistName;
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      deleteMediaLike: function (userId, mediaId, playlistId, playlistName) {
        var url = this.root + '/media-likes';
        var config = {
          params: {
            userId: userId,
            mediaId: mediaId,
            playlistId: playlistId
          }
        };

        if (!playlistId) {
          config.params.playlistName = playlistName;
        }

        return $http.delete(url, config)
          .then(function (response) {
            return response.data;
          });
      },

      getRemoved: function (callback, error) {
        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/media_removed')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      restoreRemoved: function (data, callback, error) {
        $http.post(this.root + '/media_removed/' + data.removeid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      removedApplyToAccount: function (removeid, mediaid, callback, error) {
        var data = {
          isGlobal: 1,
          mediaid: mediaid
        };

        $http({
          url: this.root + '/media_removed/' + removeid,
          method: 'PUT',
          data: data
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getStreamHistory: function (streamId, limit) {
        var url = this.root + '/streams/' + streamId + '/streamHistory';
        var config = {
          params: {
            token: this.APIKey,
            limit: limit
          }
        };

        return $http.get(url, config)
          .then(function (response) {
            return response.data;
          });
      },

      addStreamHistory: function (streamid, streamHistory) {
        var url = this.root + '/streams/' + streamid + '/streamHistory';
        var data = {
          history: streamHistory
        };
        var config = {};

        // 2021-02-19 rporczak -- This endpoint is authenticated on the API. From the client side, it was relying on the
        //  Authorization header being set in http.js's authorizationInjector. However, these cookie values do not exist
        //  for Auto Logins. Therefore, we check to see if those cookie values exist, and if they do not, we manually
        //  construct the Authorization token to pass in via the header.
        if (!$cookies.get('Token') && !$cookies.get('Authorization') && (!!this.APIKey)) {
          config.headers = {
            Authorization: 'Basic ' + base64.encode(this.userObject.user.userid + ':' + this.APIKey)
          };
        }

        return $http.post(url, data, config)
          .then(function (response) {
            return response.data;
          });
      },

      /*
       * Looks like this method isn't used anywhere in Tune -fmadden 02/14/20
       */
      sendMassCommand: function (data, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/users/commands',
          method: 'POST',
          data: data
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateMassGroupId: function (data, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/streams/group',
          method: 'PUT',
          data: data
        })
          .then(function () {
            if (typeof callback !== 'undefined') {
              callback();
            }
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateMassMessagePreset: function (data, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/streams/message_preset',
          method: 'PUT',
          data: data
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateMassMessageSchedule: function (data, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/streams/schedule',
          method: 'PUT',
          data: data
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateMassMusic: function (streamIds, musicType, musicId) {
        var deferred = $q.defer();
        var url = this.root + '/accounts/' + this.userObject.account.custid + '/streams/music';
        var data = {
          streams: streamIds,
          music_type: musicType,
          music_id: musicId
        };

        $http.put(url, data)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(deferred.reject);

        return deferred.promise;
      },

      updateMassGroupMusic: function (data, callback, error) {
        $http.put(this.root + '/accounts/' + this.userObject.account.custid + '/groups/music', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateMassGroupMessagePreset: function (data, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/groups/message_preset',
          method: 'PUT',
          data: data
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateMassGroupMessageSchedule: function (data, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/groups/schedule',
          method: 'PUT',
          data: data
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      removeSong: function (data, callback, error) {
        var url = this.root + '/media_removed';

        data.custid = this.userObject.account.custid;

        $http.post(url, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkUsername: function (name, callback, error) {
        $http.get(this.root + '/users/checkname/' + name)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      /*
       * Looks like this getAdmins method isn't used anywhere in Tune -fmadden 02/14/20
       * It is referenced in admin controller in getUserPage(), but that function isn't
       * called anywhere either.
       */
      getAdmins: function (page, callback, error) {
        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/admins?page=' + page || 1)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      upgradeSubscription: function (data, callback, error) {
        var self = this;

        $http.put(this.root + '/accounts/' + this.userObject.account.custid + '/subscriptions', data)
          .then(function (response) {
            var data = response.data;

            self.userObject.subscription = data.subscription;
            callback(data.subscription);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getPresets: function (page) {
        var self = this;
        var defer = $q.defer();

        if (typeof page !== 'number') {
          page = 1;
        }

        $http.get(this.root + '/messages/presets?page=' + (page || 1))
          .then(function(response) {
            var data = response.data;

            self.messagePresets = data;

            // This is a hack to fix the fact that the API improperly returns
            // the message details as a comma separated list with no spaces
            // after the comma       --fmadden 01/09/17
            for (var i = 0; i < data.presets.length; i++) {
              if (data.presets[i].messages !== null) {
                data.presets[i].messages = data.presets[i].messages.split(',').join(', ');
              } else {
                data.presets[i].messages = '';
              }
            }

            defer.resolve(data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getMessagePresetDetails: function (id) {
        var defer = $q.defer();

        $http.get(this.root + '/messages/presets/' + id)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      addMessagePreset: function (data, callback, error) {
        $http.post(this.root + '/messages/presets', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      editMessagePreset: function (data, callback, error) {
        $http.put(this.root + '/messages/presets/' + data.presetid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      removeMessagePresetById: function (presetid, callback, error) {
        $http({
          url: this.root + '/messages/presets/' + presetid + '/' + this.userObject.account.custid,
          method: 'DELETE',
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      removeMessageScheduleById: function (scheduleid, callback, error) {
        $http({
          url: this.root + '/accounts/' + this.userObject.account.custid + '/messageSchedule/' + scheduleid,
          method: 'DELETE',
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getMessageSchedules: function () {
        var defer = $q.defer();

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/messageSchedules')
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject('error', response.data);
          });

        return defer.promise;
      },

      postMessageSchedule: function (scheduleName, callback, error) {
        var data = {
          name: scheduleName,
          userid: this.userObject.user.userid,
          scheduleitems: [],
          token: this.APIKey
        };

        $http.post(this.root + '/accounts/' + this.userObject.account.custid + '/messageSchedules', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      putMessageSchedule: function (scheduleId, scheduleData, callback, error) {
        $http.put(this.root + '/accounts/' + this.userObject.account.custid + '/messageSchedule/' + scheduleId, scheduleData)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getMessageScheduleDetails: function (scheduleId) {
        var defer = $q.defer();

        var opts = {
          params: {
            userid: this.userObject.user.userid
          }
        };

        // 2021-02-19 rporczak -- This endpoint is authenticated on the API. From the client side, it was relying on the
        //  Authorization header being set in http.js's authorizationInjector. However, these cookie values do not exist
        //  for Auto Logins. Therefore, we check to see if those cookie values exist, and if they do not, we manually
        //  construct the Authorization token to pass in via the header.
        if (!$cookies.get('Token') && !$cookies.get('Authorization') && (!!this.APIKey)) {
          opts.headers = {
            Authorization: 'Basic ' + base64.encode(this.userObject.user.userid + ':' + this.APIKey)
          }
        }

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/messageSchedule/' + scheduleId, opts)
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      getMessageScheduleEvents: function (scheduleId, startDate, endDate, callback, error) {
        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/messageScheduleEvents/' + scheduleId + '?start=' + startDate + '&end=' + endDate + '&userid=' + this.userObject.user.userid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getUserMessageScheduleEvents: function (startDate, endDate, callback, error) {
        var params = {
          userid: this.userObject.user.userid,
          token: this.APIKey
        };

        if (startDate && endDate) {
          params.start = startDate;
          params.end = endDate;
        }

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/messageScheduleEvents', { params: params })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      postMessageScheduleItem: function (scheduleId, scheduleItemData, callback, error) {
        $http.post(this.root + '/accounts/' + this.userObject.account.custid + '/messageSchedule/' + scheduleId + '/scheduleItem', scheduleItemData)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      // Should really be called something like getMessageQueue
      requestScheduleUpdates: function (userId, deviceId) {
        var url = this.root + '/streams/requestScheduleUpdates';
        var data = {
          userid: userId,
          deviceid: deviceId
        };
        var config = {};

        // 2021-02-19 rporczak -- This endpoint is authenticated on the API. From the client side, it was relying on the
        //  Authorization header being set in http.js's authorizationInjector. However, these cookie values do not exist
        //  for Auto Logins. Therefore, we check to see if those cookie values exist, and if they do not, we manually
        //  construct the Authorization token to pass in via the header.
        if (!$cookies.get('Token') && !$cookies.get('Authorization') && (!!this.APIKey)) {
          config.headers = {
            Authorization: 'Basic ' + base64.encode(this.userObject.user.userid + ':' + this.APIKey)
          };
        }

        return $http.post(url, data, config)
          .then(function (response) {
            return response.data;
          });
      },

      getMessages: function () {
        var defer = $q.defer();

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/messages')
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject('error', response.data);
          });

        return defer.promise;
      },

      getMessagesWithStatus: function () {
        var defer = $q.defer();

        $http.get(this.root + '/accounts/' + this.userObject.account.custid + '/messagesWithStatus')
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject('error', response.data);
          });

        return defer.promise;
      },

      uploadMessage: function (file, data, progressCallback, finishCallback) {
        var self = this;

        Upload.upload({
          method: 'POST',
          url: this.root + '/messages',
          headers: {
            'Authorization': $cookies.get('Authorization'),
            'Content-Type': 'multipart/form-data',
          },
          file: file,
          data: data,
        })
          .progress(function (evt) {
            var percent = parseInt(100.0 * evt.loaded / evt.total, 10);
            progressCallback(percent);
          })
          .then(function (response) {
            finishCallback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      editMessage: function (data, callback, error) {
        $http.put(this.root + '/messages/' + data.messageid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      deleteMessage: function (messageid, callback, error) {
        $http({
          url: this.root + '/messages/' + messageid,
          method: 'DELETE',
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      selectPlan: function (plan, coupon, callback) {
        var data = {
          plan: plan,
          coupon: coupon
        };

        var url = this.root + '/accounts/' + this.userObject.account.custid + '/subscriptions';

        $http({
          url: url,
          data: data,
          method: 'PUT'
        })
          .then(function (response) {
            callback(response.data);
          });
      },

      validateCoupon: function (coupon, callback, error) {
        $http.get(this.root + '/coupons/' + coupon)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      submitCoupon: function (coupon_code, isSubscription, callback, error) {
        var data = {
          coupon_code: coupon_code
        };

        if (isSubscription) {
          $http.post(this.root + '/accounts/' + this.userObject.account.custid + '/subscription_coupon', data)
            .then(function (response) {
              callback(response.data);
            })
            .catch(function (response) {
              error(response.data);
            });
        } else {
          $http.post(this.root + '/accounts/' + this.userObject.account.custid + '/coupon', data)
            .then(function (response) {
              callback(response.data);
            })
            .catch(function (response) {
              error(response.data);
            });
        }
      },

      subscribe: function (plan, coupon_code, callback, error) {
        var data = {
          plan: plan,
          coupon_code: coupon_code,
          custid: this.userObject.account.custid
        };

        $http.post(this.root + '/subscription/create', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getNextMedia: function (streamId, streamHistory, currentMedia) {
        var url = this.root + '/streams/' + streamId + '/next-media';
        var data = {};
        var config = {};

        if (streamHistory && streamHistory.length > 0) {
          data.history = streamHistory;
        }

        if (currentMedia !== undefined && currentMedia !== null) {
          data.trackIndex = currentMedia.index;
        }
        data.deviceUuid = $cookies.get('Device');

        // 2021-02-19 rporczak -- This endpoint is authenticated on the API. From the client side, it was relying on the
        //  Authorization header being set in http.js's authorizationInjector. However, these cookie values do not exist
        //  for Auto Logins. Therefore, we check to see if those cookie values exist, and if they do not, we manually
        //  construct the Authorization token to pass in via the header.
        if (!$cookies.get('Token') && !$cookies.get('Authorization') && (!!this.APIKey)) {
          config.headers = {
            Authorization: 'Basic ' + base64.encode(this.userObject.user.userid + ':' + this.APIKey)
          };
        }

        return $http.post(url, data, config)
          .then(function (response) {
            var data = response.data;

            if (data && data.code && data.code === 'InActivePlayer' && !BrowserDetect.mobile) {
              return { err: data };
            }

            if (data && data.error) {
              return { err: data.error };
            }

            var media = {
              id: '',
              name: '',
              description: '',
              mediaType: '',
              mediaUrl: '',
              imageUrl: ''
            };

            if (data.song) {
              media.id = data.song.uuid;
              media.name = data.song.name;
              media.description = data.artist.name + ' / ' + data.album.name;
              media.artist = data.artist.name;
              media.playlistid = data.song.playlistid;
              media.station = data.song.playlist;
              media.media_station = data.song.playlist;
              media.mix = data.song.mix;
              media.daypart = data.song.daypart;
              media.mediaid = data.song.mediaid;
              media.mediaType = 'song';
              media.mediaUrl = data.song.uri['mp4'].replace('http:', 'https:');
              media.imageUrl = data.album.thumb_url.replace('http:', 'https:');
              media.liked = data.song.liked;
              media.trackIndex = data.song.trackIndex;
              media.trackToken = data.song.trackToken;
              media.stationId = data.song.stationId;
              media.feedbackValue = data.song.feedbackValue;

              if (data.song.daypartid) {
                media.music_type = 'dayparting';
              } else if (data.song.mixid) {
                media.music_type = 'mix';
              } else {
                media.music_type = 'playlist';
              }
            } else if (data.message) {
              media.id = data.message.message_uuid;
              media.name = data.message.message_name;
              media.description = '';
              media.artist = '';
              media.station = 'Playing Promotional Message';
              media.media_station = 'Promotional Message';
              media.mediaType = 'message';
              media.mediaUrl = data.message.uri.mp3;
              media.messageid = data.message.messageid;
              media.message_preset_detail_id = data.message.message_preset_detail_id;
              media.imageUrl = '';
              media.mix = null;
              media.daypart = null;
              media.collection_type = null;
              media.extra = data.message.extra;
            }

            return { data: media };
          });
      },

      /*
       * Looks like this method isn't used anywhere in Tune -fmadden 02/14/20
       */
      createAccount: function (data, callback, error) {
        var self = this;

        $http.post(this.root + '/accounts', data)
          .then(function (response) {
            var data = response.data;

            $cookies.put('Token', data.token);
            self.APIKey = data.token;
            $cookies.put('Authorization', 'Basic ' + base64.encode(data.user.userid + ':' + data.token));

            self.userObject = {
              user: data.user,
              account: data.account,
              payment: {
                signature: data.signature,
                account_code: data.account.recurly
              }
            };

            callback(data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      createBillingAccount: function (data, callback, error) {
        $http.post(this.root + '/account/billing', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateBillingInfo: function(data, callback, error) {
        $http.put(this.root + '/billingInfo/' + data.custid + '/edit', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      createBoxOrder: function (data) {
        return ($http.post(this.root + '/deviceorder', data)
          .then(function (response) {
            return response.data;
          }));
      },

      getDeviceOrderHistory: function (id, callback) {
        var self = this;

        $http.get(this.root + '/users/' + id + '/deviceOrderHistory')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      requestPassword: function (data, callback, error) {
        $http.post(this.root + '/password_request', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      resetPassword: function (username, password, resetToken) {
        var url = this.root + '/password_reset';
        var data = {
          username: username,
          password: password,
          reset_token: resetToken
        };

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      checkDaypartingNameAdd: function (name, callback, error) {
        $http.get(this.root + '/daypartingCheck/checkNameAdd?name=' + encodeURIComponent(name))
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkDaypartingNameEdit: function (data, callback, error) {
        $http.get(this.root + '/daypartingCheck/checkNameEdit?name=' + encodeURIComponent(data.name) + '&daypartingid=' + data.daypartingid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkStationNameAdd: function (name, callback, error) {
        $http.get(this.root + '/playlistCheck/checkNameAdd?name=' + encodeURIComponent(name))
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkStationNameEdit: function (data, callback, error) {
        $http.get(this.root + '/playlistCheck/checkNameEdit?name=' + encodeURIComponent(data.name) + '&mixid=' + data.mixid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkMessageNameAdd: function (name, callback, error) {
        $http.get(this.root + '/presetCheck/checkNameAdd?name=' + encodeURIComponent(name))
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      checkMessageNameEdit: function (data, callback, error) {
        $http.get(this.root + '/presetCheck/checkNameEdit?name=' + encodeURIComponent(data.name) + '&presetid=' + data.presetid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getUserName: function (userid, callback, error) {
        $http.get(this.root + '/user/' + userid + '/getUserName')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getAutoLoginRegister: function (accesskey, callback, error) {
        $http.post(this.root + '/autologin/register/' + accesskey)
          .then(function (response) {
            var data = response.data;

            self.userObject = {
              user: data.user,
              account: data.account
            };

            callback(data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      updateAutologinInfo: function (data, callback, error) {
        $http.post(this.root + '/autologin/update', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      generateAutoLoginURL: function (data, callback, error) {
        var accesskey = base64.encode(data.userid + ':' + data.custid + ':' + Math.random());
        accesskey = accesskey.replace('==', '');
        data.access_key = accesskey.replace('=', '');
        data.autologin_apiurl = this.webUrl + '/#/apiautologin/' + data.access_key;
        data.autologin_weburl = this.webUrl + '/#/webautologin/' + data.access_key;

        $http.post(this.root + '/generateAutoLoginURL', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getAutoLoginURL: function (stream, callback, error) {
        var data = {
          userid: stream.userid,
          custid: stream.custid,
          streamid: stream.streamid
        };

        $http.get(this.root + '/getAutoLoginURL?userid=' + data.userid + '&custid=' + data.custid + '&streamid=' + data.streamid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      registerAutoLoginDevice: function (accesskey, callback) {
        var data = {
          name: BrowserDetect.browser + ' browser App',
          description: navigator.userAgent,
          uuid: chance.guid(),
          type: 'pc',
          access_key: accesskey,
          custid: this.userObject.account.custid,
          userid: this.userObject.user.userid
        };

        $http.post(this.root + '/autoLoginDevices', data)
          .then(function (response) {
            document.cookie = 'Device=' + data.uuid + '; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/';

            callback(null, response.data);
          })
          .catch(function (response) {
            callback({
              code: response.status,
              message: response.data
            });
          });
      },

      // Strikingly similar to the activateDevice call somewhere up above.
      autoLoginActivateDevice: function (data) {
        var deferred = $q.defer();
        var url = this.root + '/devices/' + data.device_id + '/activate?token=' + this.APIKey;

        data.appversion = ENV.version;

        $http.put(url, data)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response);
          });

        return deferred.promise;
      },

      autoLoginGetNext: function (token, callback, error) {
        $http.get(this.root + '/media/next?token=' + token)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getAutoLoginMe: function (data) {
        var defer = $q.defer();
        var self = this;

        if (this.getMeRequest) {
          return this.getMeRequest;
        }

        this.getMeRequest = defer.promise;

        $http.get(this.root + '/getAutoLoginMe?access_key=' + data.token)
          .then(function (response) {
            var data = response.data;

            self.userObject = {
              user: data.user,
              account: data.account,
              active_player: data.active_player,
              device_id: data.device_id,
              streamid: data.streamid,
              music_id: data.music_id,
              music_type: data.music_type,
              message_preset: data.message_preset,
              schedule_id: data.schedule_id,
              permissions: data.permissions,
              recurly: {
                account_code: data.account.recurly
              }
            };

            defer.resolve(self.userObject);
            self.getMeRequest = null;
          })
          .catch(function (response) {
            var data = response.data;

            self.getMeRequest = null;
            if (data && data.code === 'NotAuthorized') {
              return $scope.showError('You are not authorized.');
            }
          });

        return defer.promise;
      },

      validateAutoLogin: function (data, callback, error) {
        $http.post(this.root + '/autologin/validate', data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getSelfServeWebAutoLoginUrlPath: function (apikey, uuid) {
        var defer = $q.defer();

        $http({
          method: 'GET',
          url: this.root + '/selfserve/webautologinurlpath',
          headers: {
            Authorization: 'APIKEY ' + apikey + ',' + uuid,
          },
        })
          .then(function (response) {
            defer.resolve(response.data);
          })
          .catch(function (response) {
            defer.reject(response.data);
          });

        return defer.promise;
      },

      updateCorporateAddress: function (custid, data, callback) {
        var self = this;

        $http.put(this.root + '/updateCorporateAddress/' + custid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      getActiveAccountStreams: function (custid, callback, error) {
        $http.get(this.root + '/streams/active/' + custid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getBillingAccountInfo: function (custid, callback) {
        var self = this;

        $http.get(this.root + '/account/' + custid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      createStreamStatusReport: function (options) {
        var url = this.root + '/reports/streamStatus';
        var data = {
          start: options.startAt,
          end: options.endAt,
          timezone: options.timezone
        };

        if (options.usernames && options.usernames.length) {
          data.usernames = options.usernames;
        }

        if (options.status) {
          data.status = options.status;
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      createStreamingReport: function (options) {
        var url = this.root + '/reports/streaming';
        var data = {
          start: options.startAt,
          end: options.endAt,
          timezone: options.timezone
        };

        if (options.userIds && options.userIds.length) {
          data.userIds = options.userIds;
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      createMessageReport: function (options) {
        var url = this.root + '/reports/message';
        var data = {
          start: options.startAt,
          timezone: options.timezone
        };

        if (options.usernames && options.usernames.length) {
          data.usernames = options.usernames;
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      createLocationsAddedReport: function (options) {
        var url = this.root + '/reports/locationsAdded';
        var data = {
          start: options.startAt,
          end: options.endAt,
          timezone: options.timezone
        };

        if (options.usernames && options.usernames.length) {
          data.usernames = options.usernames;
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      createCurrentActivityReport: function (options) {
        var url = this.root + '/reports/current-activity';
        var data = {
          timezone: options.timezone
        };

        if (options.usernames && options.usernames.length) {
          data.usernames = options.usernames;
        }

        return $http.post(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      getRecurringReports: function (userId) {
        var url = this.root + '/users/' + userId + '/recurring-reports';

        return $http.get(url)
          .then(function (response) {
            return response.data;
          });
      },

      updateRecurringReport: function (userId, reportId, frequency, active, recipients) {
        var url = this.root + '/users/' + userId + '/recurring-reports/' + reportId;

        var isValidRequest = userId && reportId && frequency && typeof active === 'boolean';
        if (!isValidRequest) {
          return $q.reject();
        }

        var data = {
          reportId: reportId,
          frequency: frequency,
          active: active
        };

        if (recipients) {
          data.recipients = recipients;
        }

        return $http.put(url, data)
          .then(function (response) {
            return response.data;
          });
      },

      checkAccountRequirements: function (custid, callback) {
        var self = this;

        $http.get(this.root + '/accounts/'+ custid + '/checkAccountRequirements')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            self.handleError(response.data);
          });
      },

      /*
       * Looks like this acceptTerms method isn't used anywhere in Tune -fmadden 02/14/20
       */
      acceptTerms: function (signature, callback, error) {
        $http.post(this.root + '/accounts/'+ this.userObject.account.custid + '/acceptTerms?signature=' + signature)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getApiVersion: function () {
        var deferred = $q.defer();
        var url = this.root + '/';

        $http.get(url)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response);
          });

        return deferred.promise;
      },

      getHMAC: function (intercomId, callback) {
        $http.get(this.root + '/HMAC?intercomId=' + intercomId)
          .then(function (response) {
            callback(response.data);
          });
      },

      getPasswordResetUser: function (resetToken) {
        var url = this.root + '/password_reset/user/' + resetToken;

        return $http.get(url)
          .then(function (response) {
            return response.data;
          });
      },

      sendCloudBoxCommand: function (data, callback, error) {
        $http.put(this.root + '/cloudbox/command/' +  data.uuid, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getStreamsWithDevice: function (page, callback, error) {
        $http.get(this.root + '/streams/enhanced?page=' + (page || 1))
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getStreamsSubsetWithDevice: function (streamids, callback, error) {
        if (!streamids || !streamids.length) {
          if (error) {
            error();
          }

          return;
        }

        var url = this.root + '/streams/subset';
        var config = {
          params: {
            streamids: streamids.join(',')
          }
        };

        $http.get(url, config)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getStreamsForAccount: function (callback, error) {
        $http.get(this.root + '/streams/account')
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getStreamsForUser: function (userid, callback, error) {
        $http.get(this.root + '/streams?userid=' + userid + '&token=' + this.APIKey)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response);
          });
      },

      getMediaPlayingForStream: function (streamid, callback) {
        return ($http.get(this.root + '/streams/' + streamid + '/playing?token=' + this.APIKey)
          .then(function (response) {
            callback(null, response.data);
          }, function (response) {
            callback(response.data, null);
          }));
      },

      addStreamToUser: function (data) {
        return ($http.post(this.root + '/streams', data)
          .then(function (response) {
            return response.data;
          }));
      },

      removeStream: function (streamid) {
        return ($http.delete(this.root + '/streams/' + streamid)
          .then(function (response) {
            return response.data;
          }));
      },

      editStream: function (data) {
        var url = this.root + '/streams/' + data.streamid + '/edit';
        var requestData = {
          streamname:           data.streamname,
          userid:               data.userid
        };

        return $http.put(url, requestData)
          .then(function (response) {
            return response.data;
          });
      },

      getLocsWithStreamCounts: function (custid) {
        return ($http.get(this.root + '/streams/locations/' + custid)
          .then(function (response) {
            return response.data;
          }));
      },

      checkUniqueStreamname: function (data) {
        return ($http.get(this.root + '/streamCheck/checkNameEdit?streamname=' + encodeURIComponent(data.streamname) + '&userid=' + data.userid)
          .then(function (response) {
            return response.data;
          }));
      },

      getAccountStreamCounts: function (custid) {
        return ($http.get(this.root + '/streams/accountStreamCounts/' + custid)
          .then(function (response) {
            return response.data;
          }));
      },

      getShippingRates: function () {
        return ($http.get(this.root + '/deviceorders/shippingRates')
          .then(function(response) {
            return response.data;
          }));
      },

      calculateTaxAmount: function (orderData) {
        var url = this.root + '/deviceorders/calculateTaxAmount';
        var config = {
          params: {
            amount: orderData.amount,
            street: orderData.street,
            city: orderData.city,
            state: orderData.state,
            zipcode: orderData.zipcode,
            country: orderData.country
          }
        };

        return $http.get(url, config)
          .then(function (response) {
            return response.data;
          });
      },

      // Account API Key management for self serve Devices such as Hypersign
      /*
        Method: getSelfServeAPIKey

        fetch apikey

        GET /apikey?token=bcf7b8d55761e9b5ec1b90896311263920f6c8b4&custid=271

        {
          "apikey": "02b99fe9811d6be9316d1d836afd22802dec8247"
        }
      */
      getSelfServeAPIKey: function (callback, error) {
        console.log('retrieving self serve API Key');

        $http.get(this.root + '/apikey?token=' + this.APIKey + '&custid=' + this.userObject.account.custid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      getSelfServeAPIKeyHistory: function (callback, error) {
        $http.get(this.root + '/apikey/history?token=' + this.APIKey + '&custid=' + this.userObject.account.custid)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      createSelfServeAPIKey: function (callback, error) {
        $http.post(this.root + '/apikey?token=' + this.APIKey, {})
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      revokeSelfServeAPIKey: function (data, callback, error) {
        $http.post(this.root + '/apikey/disabled?token=' + this.APIKey, data)
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      /*
        Method: getSelfServeDevices

        GET /selfserve?token=bcf7b8d55761e9b5ec1b90896311263920f6c8b4&custid=271
        {
          token: 'bcf7b8d55761e9b5ec1b90896311263920f6c8b4',
          custid: '271'
        }

        Data returned:
        {
          "deviceid": 177235,
          "uuid": "decaffcafe",
          "custid": 271,
          "userid": 5578,
          "autologinid": 3186,
          "name": "clown_fishmodifed",
          "appversion": "1"
        }
      */
      getSelfServeDevices: function () {
        return ($http.get(this.root + '/selfserve?token=' + this.APIKey + '&custid=' + this.userObject.account.custid)
          .then(function (response) {
            return response.data;
          }));
      },

      /*
        Method: assignSelfServeDevice

        POST /selfserve/decaffcafe/assignment
        {
          token: 'bcf7b8d55761e9b5ec1b90896311263920f6c8b4',
          userid: '5578',
          streamid: '5263'
        }
      */
      assignSelfServeDevice: function (data, callback, error) {
        $http.post(this.root + '/selfserve/' + data.uuid + '/assignment', {
          token: this.APIKey,
          userid: data.userid,
          streamid: data.streamid
        })
          .then(function (response) {
            callback(response.data);
          })
          .catch(function (response) {
            error(response.data);
          });
      },

      // Takes an array of device ids
      getDeviceState: function (ids) {
        if (!ids || !ids.length) {
          return $q.reject();
        }

        var deferred = $q.defer();
        var url = this.deviceStateUrl + '/device/list';
        var config = {
          headers: {
            Authorization: this.APIKey
          },
          params: {
            ids: ids.join(',')
          }
        };

        $http.get(url, config)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response);
          });

        return deferred.promise;
      },

      sendDeviceState: function (deviceInfo) {
        var deferred = $q.defer();
        var url = this.deviceStateUrl + '/device/' + deviceInfo.id;
        var config = {
          headers: {
            Authorization: this.APIKey
          }
        };

        $http.put(url, deviceInfo, config)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject(response);
          });

        return deferred.promise;
      },

      deleteDeviceNetworkConstraintsDownloadWindow: function () {
        var deferred = $q.defer();
        var custId = this.userObject.account.custid;
        var url = this.root + '/accounts/' + custId + '/networkConstraints/downloadWindow';

        $http.delete(url)
          .then(function () {
            deferred.resolve();
          })
          .catch(function (response) {
            deferred.reject({
              status: response.statusText,
              data: response.data
            });
          });

        return deferred.promise;
      },

      getDeviceNetworkConstraints: function () {
        var deferred = $q.defer();
        var custId = this.userObject.account.custid;
        var url = this.root + '/accounts/' + custId + '/networkConstraints';

        $http.get(url)
          .then(function (response) {
            var networkConstraints = response.data.networkConstraints;
            var data = {
              downloadStartTime: networkConstraints.download_start_time,
              downloadStopTime: networkConstraints.download_stop_time
            };

            deferred.resolve(data);
          })
          .catch(function (response) {
            deferred.reject({
              status: response.statusText,
              data:   response.data
            });
          });

        return deferred.promise;
      },

      updateDeviceNetworkConstraints: function (data) {
        var deferred = $q.defer();
        var custId = this.userObject.account.custid;
        var url = this.root + '/accounts/' + custId + '/networkConstraints';

        $http.put(url, data)
          .then(function (response) {
            deferred.resolve(response.data);
          })
          .catch(function (response) {
            deferred.reject({
              status: response.statusText,
              data: response.data
            });
          });

        return deferred.promise;
      },

      refreshCloudBox: function (streamid) {
        var deferred = $q.defer();
        var url = this.root + '/streams/' + streamid + '/refreshCloudBox';

        $http.get(url)
          .then(function (response) {
            deferred.resolve(response);
          })
          .catch(function (err) {
            deferred.reject(err);
          });

        return deferred.promise;
      },

      getStreamAudioLinks: function (permanentOrEphemeralStreamId) {
        var url = this.root + '/streams/' + permanentOrEphemeralStreamId + '/audio-links';

        return $http.get(url)
          .then(function (response) {
            return response.data;
          });
      },

      updateStreamAudioLink: function (permanentStreamId, ephemeralStreamId) {
        var url = this.root + '/streams/' + permanentStreamId + '/audio-links/' + ephemeralStreamId;

        return $http.put(url)
          .then(function (response) {
            return response.data;
          });
      },

      deleteStreamAudioLink: function (permanentStreamId, ephemeralStreamId) {
        var url = this.root + '/streams/' + permanentStreamId + '/audio-links/' + ephemeralStreamId;

        return $http.delete(url)
          .then(function (response) {
            return response.data;
          });
      }

    };
  }
]);

app.factory('apiTimeDataUtility', apiTimeDataUtility);

function apiTimeDataUtility() {

  return {
    
    // Methods
    convertApiTimeToDate: convertApiTimeToDate,
    convertApiTimeToTimeParts: convertApiTimeToTimeParts,
    convertTimePartsToApiTime: convertTimePartsToApiTime,
    convertTimePartsToMilliseconds: convertTimePartsToMilliseconds
  };

  // Public methods

  function convertApiTimeToDate(time) {
    var timeParts = time.split(':');
    
    var hours = parseInt(timeParts[0], 10);
    var minutes = parseInt(timeParts[1], 10);

    var date  = new Date();
    date.setHours(hours);
    date.setMinutes(minutes);

    return date;
  }

  function convertApiTimeToTimeParts(time) {
    var timePartsArray = time.split(':');

    var hours = parseInt(timePartsArray[0], 10);
    var minutes = parseInt(timePartsArray[1], 10);
    var period = hours < 12 ? 'am' : 'pm';

    if (hours === 0) {
      hours = 12;
    } else if (hours > 12) {
      hours -= 12;
    }

    return {
      hours: hours,
      minutes: minutes,
      period: period
    };
  }

  function convertTimePartsToApiTime(timeParts) {
    var hours = parseInt(timeParts.hours, 10);
    var minutes = parseInt(timeParts.minutes, 10);
    var seconds = parseInt(timeParts.seconds, 10);
    var period = timeParts.period;

    var hoursStr;
    var minutesStr;
    var secondsStr;

    var mapTimePartToApiTimePart = function mapTimePartToApiTimePart(part) {
      if (isNaN(part)) {
        return '00';
      }

      return part < 10 ? '0' + part : part.toString();
    };

    var mapTimeHourToApiTimeHour = function mapTimeHourToApiTimeHour(hours, period) {
      if (period) {
        if (period === 'am' && hours === 12) {
          hours = 0;
        } else if (period === 'pm' && hours !== 12) {
          hours += 12;
        }
      }

      return hours;
    };

    hoursStr = mapTimePartToApiTimePart(mapTimeHourToApiTimeHour(hours, period));
    minutesStr = mapTimePartToApiTimePart(minutes);
    secondsStr = mapTimePartToApiTimePart(seconds);

    return hoursStr + ':' + minutesStr + ':' + secondsStr;
  }
  
  function convertTimePartsToMilliseconds(timeParts) {
    var hours = parseInt(timeParts.hours, 10);
    var minutes = parseInt(timeParts.minutes, 10);
    
    if (Number.isNaN(hours) || Number.isNaN(minutes)) {
      return;
    }

    if (timeParts.period === 'am' && hours === 12) {
      hours = 0;
    } else if (timeParts.period === 'pm' && hours !== 12) {
      hours += 12;
    }
  
    return (hours * 60 + minutes) * 60 * 1000;
  }
}
app.factory('authenticationService', authenticationService);

authenticationService.$inject = ['$cookies', '$http', '$q', 'api', 'base64', 'Duo', 'ENV'];

function authenticationService($cookies, $http, $q, api, base64, Duo, ENV) {
  var DUO_IFRAME_ID = 'duo-iframe';
  var DUO_API_HOSTNAME = ENV.duo.apiHostname;

  return {

    // Methods
    impersonateUser: impersonateUser,
    initDuo: initDuo,
    login: login
  };

  // Public methods

  function impersonateUser(username) {
    return api.impersonateUser(username);
  }

  function initDuo(signedRequest) {
    var deferred = $q.defer();

    Duo.init({
      iframe: DUO_IFRAME_ID,
      host: DUO_API_HOSTNAME,
      sig_request: signedRequest,
      submit_callback: function (form) {
        var signedResponse = form.elements.sig_response.value;

        verifyDuoResponse(signedResponse)
          .then(function () {
            deferred.resolve();
          })
          .catch(function (response) {
            deferred.reject(response);
          });
      }
    });

    return deferred.promise;
  }

  function login(username, password) {
    var deferred = $q.defer();

    api.login({
      username: username,
      password: password
    }, function (data) {
      deferred.resolve(data);
    }, function (response) {
      deferred.reject(response);
    });

    return deferred.promise;
  }

  function logout() {
    $state.go('/logout');
  }

  // Private methods

  function buildAuthorizationHeaderValue(userId, token) {
    var type = 'Basic';
    var creds = userId + ':' + token;

    return type + ' ' + base64.encode(creds);
  }

  function storeAuthorizationCredentials(userId, token) {
    var authHeaderValue = buildAuthorizationHeaderValue(userId, token);

    api.APIKey = token;

    $cookies.put('Authorization', authHeaderValue);
    $cookies.put('Token', token);
  }

  function verifyDuoResponse(signedResponse) {
    var deferred = $q.defer();

    api.loginMfa(signedResponse)
      .then(function (data) {
        var userId = data.userid;
        var token = data.token;

        storeAuthorizationCredentials(userId, token);

        deferred.resolve();
      })
      .catch(function (response) {
        deferred.reject(response);
      });

    return deferred.promise;
  }
}

/* --- Made by justgoscha and licensed under MIT license --- */

var app = angular.module('autocomplete', []);

app.directive('autocomplete', function() {
  var index = -1;

  return {
    restrict: 'E',
    scope: {
      searchParam: '=ngModel',
      suggestions: '=data',
      onType: '=onType',
      onEnter: '=onEnter',
      onSelect: '=onSelect'
    },
    controller: ['$scope', function($scope){
      // the index of the suggestions that's currently selected
      $scope.selectedIndex = -1;

      // set new index
      $scope.setIndex = function(i){
        $scope.selectedIndex = parseInt(i);
      };

      this.setIndex = function(i){
        $scope.setIndex(i);
        $scope.$apply();
      };

      $scope.getIndex = function(i){
        return $scope.selectedIndex;
      };

      // watches if the parameter filter should be changed
      var watching = true;

      // autocompleting drop down on/off
      $scope.completing = false;

      // starts autocompleting on typing in something
      $scope.$watch('searchParam', function(newValue, oldValue){
        $scope.enteredVal=newValue;
        if (oldValue === newValue || !oldValue) {
          return;
        }

        if(watching && $scope.searchParam) {
          $scope.completing = true;
          $scope.searchFilter = $scope.searchParam;
          $scope.selectedIndex = -1;
        }

        // function thats passed to on-type attribute gets executed
        if($scope.onType)
          $scope.onType($scope.searchParam);
      });

      // for hovering over suggestions
      this.preSelect = function(suggestion){

        watching = false;

        // this line determines if it is shown
        // in the input field before it's selected:
        //$scope.searchParam = suggestion;

        $scope.$apply();
        watching = true;

      };

      $scope.preSelect = this.preSelect;

      this.preSelectOff = function(){
        watching = true;
      };

      $scope.preSelectOff = this.preSelectOff;

      // selecting a suggestion with RIGHT ARROW or ENTER
      $scope.select = function(suggestion){
        if(suggestion){
          $scope.searchParam = suggestion;
          $scope.searchFilter = suggestion;
          if($scope.onSelect)
            $scope.onSelect(suggestion);
        }
        watching = false;
        $scope.completing = false;
        setTimeout(function(){watching = true;},1000);
        $scope.setIndex(-1);
      };


    }],
    link: function(scope, element, attrs){

      var attr = '';

      // Default atts
      scope.attrs = {
        "placeholder": "start typing...",
        "class": "",
        "id": "",
        "inputclass": "",
        "inputid": ""
      };

      for (var a in attrs) {
        attr = a.replace('attr', '').toLowerCase();
        // add attribute overriding defaults
        // and preventing duplication
        if (a.indexOf('attr') === 0) {
          scope.attrs[attr] = attrs[a];
        }
      }

      if (attrs.clickActivation) {
        element[0].onclick = function(e){
          if(!scope.searchParam){
            scope.completing = true;
            scope.$apply();
          }
        };
      }

      scope.doOnEnterSearchA=function()
      {
          if(scope.onEnter)
          {
              scope.onEnter(scope.enteredVal);
          }
      }

      var key = {left: 37, up: 38, right: 39, down: 40 , enter: 13, esc: 27, tab: 9};

      document.addEventListener("keydown", function(e){
        var keycode = e.keyCode || e.which;

        switch (keycode){
          case key.esc:
            // disable suggestions on escape
            scope.select();
            scope.setIndex(-1);
            scope.$apply();
            e.preventDefault();
          break;
              /* case key.enter:
                $('#enterSearchAutoCmplt').trigger('click');
              if(scope.onEnter)
                {
                    scope.onEnter(scope.enteredVal);
                }
             break;*/
        }
      }, true);

      document.addEventListener("blur", function(e){
        // disable suggestions on blur
        // we do a timeout to prevent hiding it before a click event is registered
        setTimeout(function() {
          scope.select();
          scope.setIndex(-1);
          scope.$apply();
        }, 200);
      }, true);

      element[0].addEventListener("keydown",function (e){
        var keycode = e.keyCode || e.which;

        var l = angular.element(this).find('li').length;

        // implementation of the up and down movement in the list of suggestions
        switch (keycode){
          case key.up:

            index = scope.getIndex()-1;
            if(index<-1){
              index = l-1;
            } else if (index >= l ){
              index = -1;
              scope.setIndex(index);
              scope.preSelectOff();
              break;
            }
            scope.setIndex(index);

            if(index!==-1) {
              scope.preSelect(angular.element(angular.element(this).find('li')[index]).text());
            }

            scope.$apply();

            break;
          case key.down:
            index = scope.getIndex()+1;
            if(index<-1){
              index = l-1;
            } else if (index >= l ){
              index = -1;
              scope.setIndex(index);
              scope.preSelectOff();
              scope.$apply();
              break;
            }
            scope.setIndex(index);

            if(index!==-1) {
              scope.preSelect(angular.element(angular.element(this).find('li')[index]).text());
            }

            break;
          case key.left:
            break;
            case key.right:
                index = scope.getIndex();
                if(index !== -1) {
                    scope.select(angular.element(angular.element(this).find('li')[index]).text());
                    if(keycode == key.enter) {
                        e.preventDefault();
                    }
                } else {
                    if(keycode == key.enter) {
                        scope.select();
                    }
                }
                scope.setIndex(-1);
                scope.$apply();

                break;

            case key.enter:
            case key.tab:
                index = scope.getIndex();
                if(index !== -1) {
                    scope.select(angular.element(angular.element(this).find('li')[index]).text());
                    if(keycode == key.enter) {
                        e.preventDefault();
                    }
                } else {
                    if(keycode == key.enter) {
                        scope.select();
                    }
                }
                scope.setIndex(-1);
                scope.$apply();
                break;
          case key.esc:
            scope.select();
            scope.setIndex(-1);
            scope.$apply();
            e.preventDefault();
            break;
          default:
            return;
        }

      });
    },
    template: '\
    <div class="form-group" id="{{attrs.id}}">\
      <div class="input-group input-group-sm" style="max-width: 300px;">\
        <input type="text" id="{{ attrs.inputid }}" class="form-control" ng-model="searchParam" ng-enter="doOnEnterSearchA()" placeholder="search for..." search-field >\
        <span class="input-group-btn"><button class="btn btn-default" type="button" ng-click="doOnEnterSearchA()" id="enterSearchAutoCmplt"><i class="glyphicon glyphicon-search"></i></button></span>\
      </div>\
      <ul ng-show="completing && suggestions.length > 0">\
      <li suggestion\
        ng-repeat="suggestion in suggestions | filter:searchFilter | orderBy:\'toString()\' track by $index"\
        index="{{ $index }}"\
        val="{{ suggestion }}"\
        ng-class="{ active: ($index === selectedIndex) }"\
        ng-click="select(suggestion)"\
        ng-bind-html="suggestion | highlight:searchParam">{{ suggestion }}</li>\
      </ul>\
    </div>'
  };
});

app.filter('highlight', ['$sce', function ($sce) {
  return function (input, searchParam) {
    if (typeof input === 'function') return '';
    if (searchParam) {
      var words = '(' +
            searchParam.split(/\ /).join(' |') + '|' +
            searchParam.split(/\ /).join('|') +
          ')',
          exp = new RegExp(words, 'gi');
      if (words.length) {
        input = input.replace(exp, "<span class=\"highlight\">$1</span>");
      }
    }
    return $sce.trustAsHtml(input);
  };
}]);

app.directive('suggestion', function(){
  return {
    restrict: 'A',
    require: '^autocomplete', // ^look for controller on parents element
    link: function(scope, element, attrs, autoCtrl){
      element.bind('mouseenter', function() {
        autoCtrl.preSelect(attrs.val);
        autoCtrl.setIndex(attrs.index);
      });

      element.bind('mouseleave', function() {
        autoCtrl.preSelectOff();
      });
    }
  };
});

app.directive('datepicker', function() {
    return {
        restrict: 'A',
        require : 'ngModel',
        link : function (scope, element, attrs, ngModelCtrl) {
            $(function(){
                element.datepicker({
                    dateFormat:'yy-mm-dd',
                    minDate: 0,
                    onSelect:function (date) {
                        scope.$apply(function () {
                            ngModelCtrl.$setViewValue(date);
                        });
                    }
                });
            });
        }
    }
});

app.service("autoLoginUrlModal", ["$modal", "api", function($modal, api) {
  var modalOptions = {};
  var modalModel = {};

  var modalDefaults = {
    templateUrl: "partials/autologin_url_modal.html",
    backdrop: true,
    keyboard: true,
    modalFade: true,
    windowClass: "autologin-url-modal"
  };

  var modalOptions = {
    modalDialog: true,
    actionButtonText: "Close",
    headerText: "Auto Login URL",
  };

  this.show = function(stream) {
    modalDefaults.controller = ['$scope', '$modalInstance', function($scope, $modalInstance) {
      $scope.modalModel = modalModel;
      $scope.modalOptions = modalOptions;
      $scope.url = '';
      $scope.streamName = stream.streamname;

      $scope.generateUrl = function(hideStatus) {
        var data = {
          streamid: stream.streamid,
          userid: stream.userid,
          custid: stream.custid
        };
        api.generateAutoLoginURL(data, function(result) {
          $scope.url = result.urldetail.autologin_weburl;
          if (!hideStatus) $scope.statusMessage = "Successfully generated a new Auto Login URL";
        }, function(err) {
          console.error("Could not generate Auto Login URL", err);
        });
      }

      if (stream.autologin_weburl) {
        $scope.url = stream.autologin_weburl;
      } else {
        $scope.generateUrl(true);
      }

      $scope.ok = function() {
        $modalInstance.close({autoLoginUrl: $scope.url});
        $scope.url = '';
      };

      $scope.copySuccess = function(evt) {
        $scope.statusMessage = "Successfully copied to clipboard";
      }

      $scope.copyError = function(evt) {
        $scope.statusMessage = "Could not copy to clipboard. Click Edit in your browser's menu, and select Copy.";
      }

      $scope.cancel = function() {
        $scope.url = '';
        $modalInstance.dismiss("cancel");
      };

      $scope.handleEnterKey = function(ev) {
        if (ev.keyCode == 13) {
          $scope.ok();
        }
      };

    }];
    return $modal.open(modalDefaults).result;
  };
}]);

(function (AWS, app) {
  app.factory('awsService', awsService);

  awsService.$inject = ['$log', '$timeout', 'api', 'ENV'];

  function awsService($log, $timeout, api, ENV) {
    var sqs;

    return {
      // Methods
      configureAws: configureAws,
      getQueueInfo: getQueueInfo,
      getSqsMessages: getSqsMessages,
      purgeSqsQueue: purgeSqsQueue,
      sendCommand: sendCommand
    };

    function configureAws(region, cognitoRegion, identityPoolId, callback) {
      AWS.config.region = region;

      var cognitoClientConfig = {};
      if (cognitoRegion) {
        cognitoClientConfig.region = cognitoRegion;
      }

      AWS.config.credentials = new AWS.CognitoIdentityCredentials({
        IdentityPoolId: identityPoolId
      }, cognitoClientConfig);

      sqs = new AWS.SQS({ retryDelayOptions: { base: 1000 } });

      var sqsService = function() {
        var isPollingInterrupted = false;

        function interruptPolling() {
          isPollingInterrupted = true;
        }

        function resetPolling() {
          isPollingInterrupted = false;
        }

        function getIsPollingInterrupted() {
          return isPollingInterrupted;
        }

        return {
          interruptPolling: interruptPolling,
          resetPolling: resetPolling,
          getIsPollingInterrupted: getIsPollingInterrupted
        }
      };
      if (typeof callback === 'function') {
        callback(sqsService());
      }

    }

    function deleteSqsMessage(queueUrl, receiptHandle) {
      var deleteParams = {
        QueueUrl: queueUrl,
        ReceiptHandle: receiptHandle
      };

      sqs.deleteMessage(deleteParams, function (err) {
        if (err) {
          $log.error('Error deleting SQS message', err);
        }
      });
    }

    function receiveSqsMessage(queueUrl, callback) {
      var params = {
        QueueUrl: queueUrl,
        AttributeNames: ['All'],
        MaxNumberOfMessages: 10,
        MessageAttributeNames: ['All'],
        VisibilityTimeout: 1
      };

      sqs.receiveMessage(params, function (err, data) {
        if (err) {
          if (err.name === 'RequestAbortedError') {
            $log.debug('[SQS] Aborted polling for messages');
          } else {
            $log.error('[SQS] Error receiving messages', err);
          }

          callback(err, null);
        } else {
          var parsedResponse = '';

          if (data.Messages.length && data.Messages[0].Body) {
            if (ENV.debug) {
              $log.debug('[SQS] Received ' + data.Messages.length + ' message(s).', parseSqsMessageBodies(data.Messages));
            }

            if (isJson(data.Messages[0].Body)) {
              var response = JSON.parse(data.Messages[0].Body).Message;
              if (isJson(response)) {
                parsedResponse = JSON.parse(response);
              } else {
                parsedResponse = response;
              }
            } else {
              parsedResponse = data.Messages[0].Body;
            }
          }

          if (data.Messages && data.Messages[0]) {
            deleteSqsMessage(queueUrl, data.Messages[0].ReceiptHandle);
          }

          if (typeof callback === 'function') {
            callback(null, parsedResponse);
          }
        }
      });
    }

    function getSqsMessages(queueUrl, sqsService, callback) {
      if (!sqsService.getIsPollingInterrupted()) {
        receiveSqsMessage(queueUrl, function (err, result1) {
          if (!err) {
            if (typeof callback === 'function' && !sqsService.getIsPollingInterrupted()) {
              callback(result1);
            }
            getSqsMessages(queueUrl, sqsService, callback);
          } else {

            // Don't want to spin through errors
            $timeout(function() {
              getSqsMessages(queueUrl, sqsService, callback);
            }, 10 * 1000);
          }
        });
      }
    }

    function sendSqsMessage(queueUrl, message, callback) {
      var params = {
        QueueUrl: queueUrl,
        MessageBody: message,
        DelaySeconds: 0
      };

      sqs.sendMessage(params, function (err, data) {
        if (err) {
          $log.error('[SQS] Error sending message', err);
          callback(err, null);
        } else {
          callback(null, data);
        }
      });
    }

    function purgeSqsQueue(queueUrl) {
      var params = {QueueUrl: queueUrl};

      sqs.purgeQueue(params, function (err) {
        if (err && err.message && err.code !== 'AWS.SimpleQueueService.PurgeQueueInProgress') {
          $log.error(err.message);
        }
      });
    }

    function getQueueInfo(userId, deviceId) {
      return api.requestScheduleUpdates(userId, deviceId)
        .catch(function (err) {
          $log.error(err);

          throw err;
        });
    }

    function sendCommand(queueUrl, command) {
      if (queueUrl && command) {
        sendSqsMessage(queueUrl, command, function (err) {
          if (err) {
            $log.error('sendCommand, sendSqsMessage failed: ', err);
          }
        });
      } else {
        $log.error('awsService:sendCommand - invalid parameters: "' + queueUrl + '", "' + command + '"');
      }
    }

    // Private

    function isJson(data) {
      try {
        JSON.parse(data);
      } catch (err) {
        return false;
      }

      return true;
    }

    function parseSqsMessageBodies(messages) {
      var messageBodies = messages
        .map(function (msg) {
          var messageBody;

          if (isJson(msg.Body)) {
            messageBody = JSON.parse(msg.Body).Message;

            if (isJson(messageBody)) {
              return JSON.parse(messageBody);
            } else {
              return messageBody;
            }
          } else {
            return msg.Body;
          }
        });

      return messageBodies;
    }
  }

})(AWS, app);

app.factory('base64', ['$window', function($window) {
    return {

        name: 'base64',
        readonly: false,

        _base64_encode: function  (data) {
			var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
			var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			enc = "",
			tmp_arr = [];

			if (!data) {
			return data;
			}

			do { // pack three octets into four hexets
				o1 = data.charCodeAt(i++);
				o2 = data.charCodeAt(i++);
				o3 = data.charCodeAt(i++);

				bits = o1 << 16 | o2 << 8 | o3;

				h1 = bits >> 18 & 0x3f;
				h2 = bits >> 12 & 0x3f;
				h3 = bits >> 6 & 0x3f;
				h4 = bits & 0x3f;

				// use hexets to index into b64, and append result to encoded string
				tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
			} while (i < data.length);

			enc = tmp_arr.join('');

			var r = data.length % 3;

			return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

		},

		_base64_decode: function(data) {

			var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
			var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			dec = "",
			tmp_arr = [];

			if (!data) {
			return data;
			}

			data += '';

			do { // unpack four hexets into three octets using index points in b64
				h1 = b64.indexOf(data.charAt(i++));
				h2 = b64.indexOf(data.charAt(i++));
				h3 = b64.indexOf(data.charAt(i++));
				h4 = b64.indexOf(data.charAt(i++));

				bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

				o1 = bits >> 16 & 0xff;
				o2 = bits >> 8 & 0xff;
				o3 = bits & 0xff;

				if (h3 == 64) {
					tmp_arr[ac++] = String.fromCharCode(o1);
				} else if (h4 == 64) {
					tmp_arr[ac++] = String.fromCharCode(o1, o2);
				} else {
					tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
				}
			} while (i < data.length);

			dec = tmp_arr.join('');

			return dec;
		},

        encode: function(input) {
        	if (typeof $window.btoa === 'function') {
        		return $window.btoa(input);	
        	} else {
        		return this._base64_encode(input);
        	}
            
        },

        decode: function(input) {
        	if (typeof $window.atob === 'function') {
        		return $window.atob(input);	
        	} else {
        		return this._base64_decode(input);
        	}
            
        }

    };

}]);
app.factory('boxOrderService', ['api', '$q', 'confirmationDialog', function(api, $q, confirmationDialog) {
  var statesProvinces = window.statesProvinces;

  function generateAddress(user, shipToCorporate, corporateAddress) {
    var address = {};
    if (shipToCorporate && corporateAddress) {
      address.street = corporateAddress.street_address;
      address.city = corporateAddress.city;
      address.state = corporateAddress.state.toUpperCase();
      address.zipcode = corporateAddress.zipcode;
      address.phone = corporateAddress.phone;
    } else if (user && user.state) {
      address = {
        street: user.street,
        city: user.city,
        state: user.state.toUpperCase(),
        zipcode: user.zipcode,
        phone: user.phone
      };
      if (user.street2) {
        address.street2 = user.street2;
      }
    }
    return address;
  }

  function calculateTax(shippingAddress, amount) {
    var country = statesProvinces.filter(function(item) {
      return item.abbreviation === shippingAddress.state;
    })[0].country;
    if (shippingAddress.street2) {
      shippingAddress.street = shippingAddress.street + ' ' + shippingAddress.street2;
    }
    var orderData = {
      street: shippingAddress.street,
      city: shippingAddress.city,
      state: shippingAddress.state,
      zipcode: shippingAddress.zipcode,
      country: country,
      amount: amount
    };
    return api.calculateTaxAmount(orderData).then(function(result) {
      return result;
    }, function(err) {
      return $q.reject(err);
    });
  }

  function formatCloudBoxPrice() {
    return Number((api.userObject.subscription.cloudbox_amount_in_cents / 100).toFixed(2));
  }

  function checkContinentalShipping(state, callback) {
    if (!state) return;
    var continentalShipping = true;
    var country = statesProvinces.filter(function(item) {
      return item.abbreviation === state;
    })[0].country;
    var shippingDest = '';
    if (state === 'PR' || state === 'AK' || state === 'HI' || country === 'CA') {
      continentalShipping = false;
    }
    if (state === 'PR') {
      shippingDest = 'Puerto Rico';
    } else if (state === 'AK') {
      shippingDest = 'Alaska';
    } else if (state === 'HI') {
      shippingDest = 'Hawaii';
    } else if (country === 'CA') {
      shippingDest = 'Canada';
    }
    callback(continentalShipping, shippingDest);
  }

  function confirmNextDayShipping() {
    var message = "All Next Day Shipping orders must be submitted by 2pm Pacific to qualify for delivery the following day.";
    confirmationDialog({hideCancelBtn: true}, message, function() {
      return;
    });
  }

  return {
    generateAddress: generateAddress,
    calculateTax: calculateTax,
    formatCloudBoxPrice: formatCloudBoxPrice,
    checkContinentalShipping: checkContinentalShipping,
    confirmNextDayShipping: confirmNextDayShipping
  };
}]);

/**
 * Standard Confirmation Dialog
 *
 * This confirmation dialog was enhanced to avoid the need to write a new script for
 * every modal.
 *
 * The following options are available for dialog customization
 * windowClass:      CSS class to supply to the modal dialog for styling.
 * hideCancelBtn:    Cancel button will be hidden from Modal button bar.
 * buttonText:       OK button will contain the given label.  Default is 'OK'
 * templateUrl:      Supply an alternate dialog body content in a template
 * returnFormFields: Return values entered into form in body of dialog when dialog is confirmed.
 *
 * @author: Fritz Madden fritz.madden@gmail.com
 *
 * @param  options               Options to configure dialog
 * @param  message               Optional message to display in body of confirmation dialog.
 *                               This is only needed if you are not using a custom template
 * @param  confirmationCallback  Callback called when dialog has been confirmed
 * @param  dismissCallback       Callback called when dialog has been canceled
 */
app.factory('confirmationDialog', ['$modal', function($modal) {
  return function(options, message, confirmationCallback, dismissCallback) {
    var modalDefaults = {};
    modalDefaults.windowClass = (options.windowClass) ? options.windowClass : '';
    modalDefaults.templateUrl = (options.templateUrl) ? options.templateUrl : 'partials/generic_confirmation_modal.html';
    modalDefaults.backdrop = (options.backdrop) ? options.backdrop : true;
    modalDefaults.keyboard = (options.keyboard) ? options.keyboard : true;
    modalDefaults.modalFade = (options.modalFade) ? options.modalFade : true;

    modalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.modalOptions = options;
      if (!options.buttonText) {
        $scope.modalOptions.buttonText = 'OK';
      }
      $scope.confirmationMessage = message;
      if (options.hideCancelBtn) {
        $scope.hideCancelBtn = true;
      } else {
        $scope.hideCancelBtn = false;
      }
      $scope.ok = function (result) {
        $modalInstance.close(result);
        if (options.returnFormFields) {
          confirmationCallback($scope.formData);
        } else {
          confirmationCallback();
        }
      };
      $scope.cancel = function (result) {
        $modalInstance.dismiss('cancel');
        if (dismissCallback) dismissCallback();
      };
    }];
    return $modal.open(modalDefaults).result;
  };
}]);

(function (angular, app) {
  app.factory('contentRatingInfoModalService', contentRatingInfoModalService);

  contentRatingInfoModalService.$inject = ['$modal'];

  function contentRatingInfoModalService($modal) {
    var opts = {
      templateUrl: 'partials/content_ratings_explanation_popup.html',
      controller: ContentRatingsExplanationController,
      controllerAs: 'vm',
      windowClass: 'content-ratings-explanation-popup'
    };

    return {

      // Methods
      open: open
    };

    function open() {
      return $modal.open(opts).result;
    }
  }

  ContentRatingsExplanationController.$inject = ['contentRatingService'];

  function ContentRatingsExplanationController(contentRatingService) {
    var vm = this;

    // Properties
    vm.ratings = contentRatingService.getAllContentRatingDetails();
  }

})(window.angular, app);

(function (app) {
  app.factory('contentRatingService', contentRatingService);

  contentRatingService.$inject = ['$q', 'api'];

  function contentRatingService($q, api) {
    var contentRatingsById = {};
    var currentRefreshContentRatingsPromise = null;
    var data = {
      contentRatings: null
    };

    return {

      // Methods
      getAllContentRatingDetails: getAllContentRatingDetails,
      getContentRatingDetails: getContentRatingDetails,
      getContentRatingLabel: getContentRatingLabel,
      refreshContentRatings: refreshContentRatings
    };

    function getAllContentRatingDetails() {
      return contentRatingsById;
    }

    function getContentRatingDetails(id) {
      return contentRatingsById[id];
    }

    function getContentRatingLabel(id) {
      return contentRatingsById[id].rating;
    }

    function refreshContentRatings(forceRefresh) {
      var deferred = $q.defer();
      var hasFetchedData = Boolean(data.contentRatings);

      // Don't refresh data when a request is already in progress
      if (!forceRefresh && currentRefreshContentRatingsPromise) {
        return currentRefreshContentRatingsPromise;
      }

      if (!forceRefresh && hasFetchedData) {
        deferred.resolve(data.contentRatings);
      } else {
        currentRefreshContentRatingsPromise = api.getContentRatings()
          .then(function (contentRatings) {
            data.contentRatings = contentRatings;
            contentRatings.forEach(function (cr) {
              contentRatingsById[cr.id] = cr;
            });

            deferred.resolve(contentRatings);
          })
          .catch(deferred.reject)
          .finally(function () {
            currentRefreshContentRatingsPromise = null;
          });
      }

      return deferred.promise;
    }
  }

})(app);

app.factory('couponService', ['api', function(api) {
  var prepareCouponFeedback = function(coupon) {
    switch (coupon.discount_type) {
      case 'percent':
        coupon.discount_amount = coupon.discount_percent + '% discount';
        break;
      case 'dollars':
        coupon.discount_amount = '$' + (parseInt(coupon.discount_in_cents) / 100) + ' discount';
        break;
      case 'free_trial':
        coupon.discount_amount = coupon.free_trial_amount + ' ' + coupon.free_trial_unit + '(s) free';
        break;
    } 
    return coupon;
  };

  return {
    prepareCouponFeedback: prepareCouponFeedback,
    updateCouponCode: function(options, callback) {
      var coupon = null;
      var coupon_error = null;
      var couponCode = "";
      var subscriptionRequired = false;
      if (typeof options === "object") {
        couponCode = (options.coupon_code) ? options.coupon_code : "";
        subscriptionRequired = (options.redemption_type === 'subscription');
      } else {
        console.error("options supplied to updateCouponCode are of invalid format.  Expecting options.coupon_code.");
      }

      if (couponCode.length == 0) {
        callback(coupon, coupon_error);
      } else {
        api.validateCoupon(couponCode, function (result) {
          if (subscriptionRequired) {
            if (result.redemption_resource !== 'subscription') {
              coupon_error = "The supplied coupon is not a subscription coupon.";
              callback(coupon, coupon_error);
            } else {
              coupon = prepareCouponFeedback(result);
              callback(coupon, coupon_error);
            }
          }
          else if (result.coupon_code) {
            coupon = prepareCouponFeedback(result);
            callback(coupon, coupon_error);
          }
        }, function(err) {
          // no-op
          console.log(err.message);
          if (err.message == "invalid coupon") {
            coupon_error = "Not a valid coupon code";
          } else {
            coupon_error = err.message;
          }
          callback(coupon, coupon_error);
        });
      }
    }
  }
}]);


app.factory('dataCacher', function() {
  var cachedData = null;
  function setData(data) {
    cachedData = data;
  }

  function getData() {
    return cachedData;
  }

  function clearData() {
    cachedData = null;
  }

  return {
    getData: getData,
    setData: setData,
    clearData: clearData
  };
});

app.service('daypartToolbarService', daypartToolbarService);

daypartToolbarService.$inject = ['$rootScope'];

function daypartToolbarService ($rootScope) {
  var service = this;
  var ratingsMap = {};

  var options = {
    id: null,
    isHovering: false,
    x: 0,
    y: 100,
    day: 0,
    ratingList: [],
  };

  service.display = false;
  service.updateLocation = false;
  service.trigger = {};

  service.setLocation = function(point) {
    options.x = point.x;
    options.y = point.y;
    service.updateLocation = true;
  }

  service.getLocation = function() {
    service.updateLocation = false;
    return { x: options.x, y: options.y };
  }

  service.setTrigger = function(trigger) {
    service.trigger = {
      day: options.day,
      action: trigger,
      id: options.id,
    }
    $rootScope.$emit('triggerDaypartToolbarAction', service.trigger);
  }

  service.setHovering = function(hovering) {
    options.isHovering = hovering;
  }

  service.isHovering = function() {
    return options.isHovering;
  }

  service.show = function (day,slotId,stationId) {
    options.day = day;
    options.id = slotId;
    options.ratingList = (ratingsMap[stationId]) ? ratingsMap[stationId] : [];
    service.display = true;
    $rootScope.$emit('showDaypartToolbarPopup');
  }

  service.hide = function () {
    options.isHovering = false;
    options.slotId = null;
    service.display = false;
  }

  service.setRatingsMap = function (map) {
    if (map) {
      ratingsMap = map;
    }
  }

  service.getRatingList = function () {
    return options.ratingList;
  }

}

app.service('daypartUpdateModal', ['$modal', 'subscriptionInfo', '$window', '$timeout', function ($modal, subscriptionInfo, $window, $timeout) {
  var modalOptions = {};
  var modalModel = {};

  // code to adjust height of station select dropdown
  function adjustStationDropdownHeight() {
    var mediaTB = document.querySelector('.media-toolbar');
    var headerTB = document.querySelector('.header-toolbar');

    var screenHt = window.innerHeight;
    var stationSelector = document.querySelector('.modal .modal-dialog .scheduler-popup .daypart-edit-form .playlist.station .dropdown-menu ul.inner');
    var ddTop = 330; // offset of dropdown list from top of page.
    var chunks = 0;
    if (mediaTB && headerTB && stationSelector && screenHt) {
      screenHt -= mediaTB.clientHeight + headerTB.clientHeight + ddTop;
      var maxHeight = ( stationSelector.children.length * 26 );
      if ((screenHt % 26) > 0) {
        chunks = parseInt(screenHt / 26);
        if (chunks < 1) chunks = 1;
        screenHt = (chunks * 26) - 10;
      }
      if (screenHt > maxHeight) screenHt = maxHeight;
      stationSelector.style.height = screenHt + 'px';
    }
  }

  $window.addEventListener('resize', function() {
    adjustStationDropdownHeight();
  });

  var getStartTimeList = function() {
    var startTimeList = [];
    var ampm = '';
    var hours = 0;
    var mins = 0;
    for (var i=0, e=0; i<=1435; i += 15) {
      hours = Math.floor(i / 60);
      mins = ("0" + (i % 60)).slice(-2);
      if (hours == 0 || hours == 24) {
        hours = 12;
        ampm = 'am';
      } else if (hours == 12) {
        ampm = 'pm';
      } else if (hours > 12) {
        hours -= 12;
        ampm = 'pm';
      } else {
        ampm = 'am';
      }
      startTimeList.push({id:i, time: hours+':'+mins+' '+ampm});
    }
    return startTimeList;
  }

  var getEndTimeList = function(start) {
    var endTimeList = [];
    var ampm = '';
    var hours = 0;
    var mins = 0;
    var startTime = 15;
    if (start) {
      startTime = parseInt(start);
      startTime += 15;
    }
    for (var i=startTime; i<=1440; i += 15) {
      hours = Math.floor(i / 60);
      mins = ("0" + (i % 60)).slice(-2);
      if (hours == 0 || hours == 24) {
        hours = 12;
        ampm = 'am';
      } else if (hours == 12) {
        ampm = 'pm';
      } else if (hours > 12) {
        hours -= 12;
        ampm = 'pm';
      } else {
        ampm = 'am';
      }
      endTimeList.push({id:i, time: hours+':'+mins+' '+ampm});
    }
    return endTimeList;
  }

  var entStatus = subscriptionInfo.getEnterpriseStatus();

  var modalDefaults = {
    backdrop: true,
    keyboard: true,
    modalFade: true,
    windowClass: 'daypart-update',
    templateUrl: 'partials/daypart_scheduler_modal.html'
  };

  var defaultModalOptions = {
    modalDialog: true,
    closeButtonText: 'Cancel',
    actionButtonText: 'Done',
    headerText: 'Create Daypart',
    bodyText: 'Perform this action?',
    daypartType: 'playlist',
    startTimeList: getStartTimeList(),
    endTimeList: {}
  };

  this.setOptions = function(customModalOptions) {
    for (var key in customModalOptions) {
      if (customModalOptions.hasOwnProperty(key)) {
        modalOptions[key] = customModalOptions[key];
      }
    }
  }

  this.getOptions = function() {
    return modalOptions;
  }

  this.setModel = function(customModalModel) {
    modalModel = customModalModel;
  }

  this.show = function () {
    var tempModalOptions = {};
    var tempModalDefaults = {};

    angular.extend(tempModalOptions, defaultModalOptions, modalOptions);
    tempModalDefaults = modalDefaults;
    if (tempModalOptions.templateUrl && tempModalOptions.templateUrl.length > 0)
      tempModalDefaults.templateUrl = tempModalOptions.templateUrl;

    tempModalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.modalOptions = tempModalOptions;
      $scope.modalModel = modalModel;
      $scope.buttonEnabled = false;
      if ($scope.modalOptions.stationList.length) {
        $scope.stationTitle = "Select a Station";
      } else if (entStatus.isEnterprise) {
        $scope.stationTitle = "No company approved Stations";
        $scope.stationDisabled = true;
      }
      if ($scope.modalOptions.mixStationList.length) {
        $scope.mixStationTitle = "Select a Mix Station";
      } else if (entStatus.isEnterprise) {
        $scope.mixStationTitle = "No company approved Mix Stations";
        $scope.mixStationDisabled = true;
      }

      $scope.selectDaypartType = function(daypartType) {
        $scope.modalOptions.daypartType = daypartType;
        checkButton();
      }
      $scope.selectDaypart = function(daypartType) {
        checkButton();
      }
      $scope.updateEndTimeList = function() {
        $scope.modalOptions.endTimeList = getEndTimeList($scope.modalModel.startTime);
        if ($scope.modalModel.endTime < $scope.modalOptions.endTimeList[0].id) {
          $scope.modalModel.endTime = $scope.modalOptions.endTimeList[0].id;
        }
      }
      $scope.ok = function () {
        if ($scope.modalOptions.daypartType === 'mix') {
          $scope.modalModel.station = '';
        } else {
          $scope.modalModel.mixstation = '';
        }
        $modalInstance.close($scope.modalModel);
        modalModel = {};
      };
      $scope.cancel = function (result) {
        $modalInstance.dismiss('cancel');
        $scope.modalModel = {};
        modalModel = {};
      };
      $scope.handleEnterKey = function(ev) {
        if (ev.keyCode == 13 && $scope.buttonEnabled === true) {
          $scope.ok();
        }
      };
      var checkButton = function() {
        if (($scope.modalOptions.daypartType == 'playlist' && modalModel.station) || ($scope.modalOptions.daypartType == 'mix' && modalModel.mixstation)) {
          $scope.buttonEnabled = true;
        } else $scope.buttonEnabled = false;
      }
      checkButton();

      $scope.updateEndTimeList();

      $scope.$watch('$viewContentLoaded', function() {
        $timeout(function() {
          adjustStationDropdownHeight();
        }, 500);
      });
    }];

    return $modal.open(tempModalDefaults).result;
  };

}]);

app.factory('deviceCommand', ['api', 'awsService',
  function(api, awsService) {

    // Collection of devices types that do not support device commands
    var DEVICE_COMMAND_UNSUPPORTED_DEVICE_TYPES = ['sonos'];

    function deviceSupportsCommands(deviceType) {
      return DEVICE_COMMAND_UNSUPPORTED_DEVICE_TYPES.indexOf(deviceType) === -1;
    }

    function sendQueueCommand(device, command) {
      return awsService.getQueueInfo(device.userid, device.deviceid)
        .then(function (data) {
          return awsService.sendCommand(data.QueueUrl, command);
        });
    }

    function mapToWebsocketCommand(sqsCommand) {
      var commandMap = {
        'skip': 'command-skip',
        'pause': 'command-pause',
        'unpause': 'command-play'
      };
      return commandMap[sqsCommand] || sqsCommand;
    }

    function sendWebsocketCommand(device, command, displayName, callback) {
      var cloudBox = {
        uuid: device.uuid,
        command: mapToWebsocketCommand(command)
      };
      api.sendCloudBoxCommand(cloudBox, function() {
        callback({successMessage: 'The CloudBox should ' + displayName + ' soon.'});
      }, function() {
        callback({errMessage: 'Could not ' + displayName + ', please try again.'});
      });
    }

    function sendDeviceCommand(device, command, displayName, callback) {
      if (device.type === 'cloudbox') {

        // Can remove this call once we don't need to check version and get uuid for websocket
        api.getCloudBoxDetails(device.deviceid)
          .then(function (cbox) {
            if (cbox) {
              device.uuid = cbox.uuid;

              if (!versionGreaterThan(cbox.appversion, '3.3.27')) {
                sendWebsocketCommand(device, command, displayName, function (message) {
                  callback(message);
                });
              } else {
                sendQueueCommand(device, command)
                  .then(function () {
                    callback({ successMessage: 'The device should ' + displayName + ' soon.' });
                  })
                  .catch(angular.noop);
              }
            } else {
              callback({ errMessage: 'Could not find this CloudBox to control it' });
            }
          });
      } else if (!deviceSupportsCommands(device.type)) {
        callback({ errMessage: 'Cannot ' + command + ' device type ' + device.type });
      } else {
        sendQueueCommand(device, command)
          .then(function () {
            callback({ successMessage: 'The device should ' + displayName + ' soon.' });
          })
          .catch(angular.noop);
      }
    }

    function adjustDeviceVolume(device, volumeAdjustment, callback) {
      var command = 'adjust volume ' + volumeAdjustment;

      if (!callback) {
        callback = angular.noop;
      }

      sendDeviceCommand(device, command, 'change volume', callback);
    }

    function skipDevice(device, callback) {
      sendDeviceCommand(device, 'skip', 'skip a track', callback);
    }

    function pauseDevice(device, callback) {
      sendDeviceCommand(device, 'pause', 'pause', callback);
    }

    function unpauseDevice(device, callback) {
      sendDeviceCommand(device, 'unpause', 'play', callback);
    }

    function updateSchedule(device, callback) {
      sendDeviceCommand(device, 'update schedule', 'download media', callback);
    }

    // Capture version check logic here, since it's typically used with device commands,
    // and is needed across multiple controllers.
    function versionGreaterThan(ver1, ver2) {
      var va1 = ver1.split('.');
      var va2 = ver2.split('.');
      if (va1[0] && va2[0]) {
        if (va1[0] < va2[0]) return false;
        else if (va1[0] > va2[0]) return true;
        else if (va1[1]) {
          if (!va2[1] || (va1[1] > va2[1])) return true;
          else if (va1[1] < va2[1]) return false;
          else if (va1[2]) {
            if (!va2[2] || (va1[2] > va2[2])) return true;
          }
        }
      }
      return false;
    }

    function versionGreaterThanOrEqual(ver1, ver2) {
      return versionGreaterThan(ver1, ver2) || ver1 === ver2;
    }

    return {
      adjustDeviceVolume: adjustDeviceVolume,
      deviceSupportsCommands: deviceSupportsCommands,
      skipDevice: skipDevice,
      pauseDevice: pauseDevice,
      unpauseDevice: unpauseDevice,
      updateSchedule: updateSchedule,
      versionGreaterThan: versionGreaterThan,
      versionGreaterThanOrEqual: versionGreaterThanOrEqual
    };

  }
]);

app.factory('editDaypartService', editDaypartService);

function editDaypartService () {
  var service = this;

  service.dow = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

  service.getModalStationList = function(stations) {
    var modalStationList = [];
    for (var i=0; i<stations.length; i++) {
      modalStationList.push (
        {
          id: stations[i].musicid,
          name: stations[i].name,
          ratingList: stations[i].ratingList,
        }
      )
    }
    return modalStationList;
  }

  service.mapToSlot = function(day, playlist, dow) {
    var dayNum = dow.indexOf(day);
    var id = 0;
    var stationType = '';
    if (playlist.mixid) {
      id = playlist.mixid;
      stationType = 'mix';
    }
    else if (playlist.playlistid) {
      id = playlist.playlistid;
      stationType = 'playlist';
    }

    return {
      start: playlist.start,
      stop: playlist.end,
      day: dayNum,
      stationType: stationType,
      stationId: id,
      stationName: playlist.name,
      freq: playlist.freq
    }
  }
  service.mapSlotsToPlaylist = function(slots,dow) {
    var playlist = {};
    var slot = {};
    var item = {};
    var day = '';
    for(var i=0; i<dow.length; i++) {
      day = dow[i];
      playlist[day] = [];
    }
    for(var i=0; i<slots.length; i++) {
      slot = slots[i];
      if (Object.keys(slot).length < 1) continue;
      day = dow[slot.day];
      item = {
        start: slot.start,
        end: slot.stop,
        name: slot.stationName,
        freq: 100 // slot.freq, - For now this is always 100
      };
      if (slot.stationType == 'mix') item.mixid = slot.stationId;
      else item.playlistid = slot.stationId;

      playlist[day].push(item);
    }

    return playlist;
  }

  service.getDaysSlots = function(index, slots) {
    var result = [];
    for(var i=0; i< slots.length; i++) {
      if (slots[i].day == index) {
        result.push(slots[i]);
      }
    }
    return result;
  }

  service.copyDay = function(slots) {
    var newSlot = {};
    var newSlotArray = [];
    for (var i = 0; i < 7; i++) {
      for (var j = 0; j < slots.length; j++) {
        newSlot = angular.copy(slots[j])
        newSlot.day = i;
        newSlotArray.push(newSlot);
      }
    }
    return newSlotArray;
  }

  return service;
}



app.service("favorites", ["api", function (api) {

  this.getPlaylist = function (userId, type) {
    return api.getUserFavorites(userId);
  };

  this.addFavorites = function (userId, type, favoritesIds) {
    var favorites = favoritesIds.map(function (favoritesId) {
      return { type: type, id: favoritesId };
    });
    return api.addUserFavorites(userId, favorites);
  };

  this.removeFavorites = function (userId, type, favoritesIds) {
    var favorites = favoritesIds.map(function (favoritesId) {
      return { type: type, id: favoritesId };
    });
    return api.removeUserFavorites(userId, favorites);   
  };

}]);

(function (angular, app) {
  app.factory('formEditService', formEditService);

  formEditService.$inject = ['$location', '$rootScope', '$state', 'confirmationDialog', 'navigationService'];

  function formEditService($location, $rootScope, $state, confirmationDialog, navigationService) {
    var defaultMessage = 'Your changes have not been saved. Do you wish to proceed?';
    var confirmMessage;

    return {

      // Methods
      checkEdited: checkEdited,
      confirmNavigation: confirmNavigation,
      confirmRouteNavigation: confirmRouteNavigation
    };

    function confirmNavigation(scope, isEdited, path, message) {
      confirmMessage = message ? message : defaultMessage;

      if (isEdited) {
        confirmationDialog(scope, confirmMessage, function () {
          $rootScope.confirmLocationSwitch = false;
          $location.path(path);
        }).catch(angular.noop);
      } else {
        $rootScope.confirmLocationSwitch = false;
        $location.path(path);
      }
    }

    function confirmRouteNavigation(scope, isEdited, stateName, message) {
      confirmMessage = message ? message : defaultMessage;

      if (isEdited) {
        confirmationDialog(scope, confirmMessage, function () {
          $rootScope.confirmLocationSwitch = false;
          navigationService.stateChangeData.forceNextTransition = true;
          $state.go(stateName);
        }).catch(angular.noop);
      } else {
        $rootScope.confirmLocationSwitch = false;
        $state.go(stateName);
      }
    }

    function checkEdited(oldItem, newItem, message) {
      confirmMessage = message ? message : defaultMessage;

      if (angular.equals(oldItem, newItem)) {
        $rootScope.confirmLocationSwitch = false;

        return false;
      } else {
        $rootScope.confirmLocationSwitch = confirmMessage;

        return true;
      }
    }
  }

})(window.angular, app);
// Support functions to use Intercom
// Note:  Location of intercom launcher is found in inilization code in
//        index.html.template

app.factory('intercom', ['ENV', '$rootScope',
  function(ENV, $rootScope) {
    $rootScope.intercomAppId = ENV.intercomAppId;
    return {
      login: function(api, user, account, subscription) {
        if (window.Intercom) {
          var bootData = {
            app_id: ENV.intercomAppId,
            custom_launcher_selector: '.intercom-launcher',
            hide_default_launcher: true
          };
          if (user) {
            bootData.user_id = user.username;
            bootData.email = user.email;
            bootData.name = user.username; // Don't have full name
            bootData.created_at = new Date(user.created_at) / 1000; // Signup date (at CCM) as a Unix timestamp
          }
          if (account) {
            bootData.companies = [
              {
                company_id: account.custid,
                name: account.name,
                remote_created_at: new Date(account.created_at) / 1000,
              }
            ]
          }
          if (subscription) {
            var noUnder = subscription.vendor_code.replace(/_/g, ' ');
            var titleCase = noUnder.replace(/(^| )(\w)/g, function(x) {
              return x.toUpperCase();
            });
            bootData.companies[0].plan = titleCase;
            bootData.companies[0].Status = subscription.state;
            // Needs to end in "_at" for Intercom to recognize as a date.  Convert from millis to seconds.
            bootData.companies[0].Trial_ends_at = new Date(subscription.trial_ends_at) / 1000;
          }

          if (api && user && user.username) {
            // get launcher
            const launcher = document.querySelector('.intercom-launcher');
            const unreadCount = launcher.querySelector('.intercom-unread-count');

            // Get the username hash from the api for secure mode
            api.getHMAC(encodeURIComponent(user.username), function (result) {
              bootData.user_hash = result.HMAC;
              window.Intercom('boot', bootData);
              window.Intercom('onShow', function() {
                // so we are setting the class of the launcher in script because if we use Angular, it doesn't update properly.
                // However, we still want to set the rootscope value because we use it somewhere else in the interface to check if intercom is open.
                launcher.classList.add('intercom-open');
                $rootScope.$apply(function(){
                  $rootScope.intercomLauncherOpen = true;
                });
              });
              window.Intercom('onHide', function() {
                launcher.classList.remove('intercom-open');
                $rootScope.$apply(function(){
                  $rootScope.intercomLauncherOpen = false;
                });
              });
              window.Intercom('onUnreadCountChange', function(count) {
                unreadCount.textContent = count;
                if (count) {
                  unreadCount.classList.add('active');
                } else {
                  unreadCount.classList.remove('active');
                }
              });
            });
          }
          else {
            // This is the case when the user hasn't logged in yet.
            window.Intercom('boot', bootData);
          }
        }
      },

      logout: function() {
        // Shutdown and reset for Acquire
        window.Intercom('shutdown');
      },

      sendEvent: function(eventName, metadata) {
        if (window.Intercom) {
          window.Intercom('trackEvent', eventName, metadata);
        }
      },
      sendAttributeUpdate: function(user, data) {
        if (user.username && window.Intercom) {
          data.user_id = user.username;
          window.Intercom('update', data);
        }
      },
    };
  }
]);

app.service("localStorage", ["$window", function ($window) {
  var ls = $window.localStorage;
  var dbKey = 'ccm.tune';

  this.getItem = function (key) {
    return JSON.parse(ls.getItem(dbKey) || '{}')[key];
  };

  this.setItem = function (key, value) {
    var db = JSON.parse(ls.getItem(dbKey) || '{}');
    db[key] = value;
    ls.setItem(dbKey, JSON.stringify(db));
  };

}]);

app.factory('messageScheduleDuplicationService', ['$q', 'api', function($q, api) {

  function duplicate(userid, scheduleId) {
    var deferred = $q.defer();

    api.getMessageScheduleDetails(scheduleId)
      .then(function (getResponse) {
        var sourceSchedule = getResponse.schedule;

        api.postMessageSchedule(sourceSchedule.name + ' (Copy)', function (newSchedule) {
          var data = {
            custid: sourceSchedule.custid,
            name: sourceSchedule.name + ' (Copy)',
            type: 'messageSchedule',
            userid: userid
          };

          data.scheduleitems = sourceSchedule.scheduleitems.map(function (item) {
            return {
              messageid: item.messageid,
              start_at: item.start_at,
              end_at: item.end_at,
              recurInfo: item.recurInfo,
              scheduleid: null
            };
          });

          api.putMessageSchedule(newSchedule.scheduleid, data, function () {
            deferred.resolve({ name: data.name, scheduleid: newSchedule.scheduleid });

          }, function (err) {
            console.error('Error copying schedule information: ', err);
            deferred.reject({ name: sourceSchedule.name });
          });

        }, function (err) {
          console.error('Error creating duplicate schedule: ', err);
          deferred.reject({ name: sourceSchedule.name });
        });

      });

    return deferred.promise;
  }

  return {
    duplicate: duplicate
  };

}]);

app.service('messageSchedulerModal', ['$modal', '$q', 'confirmationDialog', '$window', '$timeout', function ($modal, $q, confirmationDialog, $window, $timeout) {
  var modalOptions = {};
  var modalModel = {};
  var dow = ['MO','TU','WE','TH','FR','SA','SU'];
  var hourInputString = null;
  var hourList = ['1','2','3','4','5','6','7','8','9','10','11','12'],
      minuteList = ['00','15','30','45'],
      playCountList = [];

  for (var i=1; i < 31; i++) {
    playCountList.push(''+i);
  }

  // code to adjust height of station select dropdown
  function adjustMessageDropdownHeight() {
    var mediaTB = document.querySelector('.media-toolbar');
    var headerTB = document.querySelector('.header-toolbar');

    var screenHt = window.innerHeight;
    var stationSelector = document.querySelector('.modal .modal-dialog .scheduler-popup .daypart-edit-form .messageSelect .dropdown-menu ul.inner');
    var ddTop = 280; // offset of dropdown list from top of page.
    var chunks = 0;
    if (mediaTB && headerTB && stationSelector && screenHt) {
      screenHt -= mediaTB.clientHeight + headerTB.clientHeight + ddTop;
      var maxHeight = ( stationSelector.children.length * 26 );
      if ((screenHt % 26) > 0) {
        chunks = parseInt(screenHt / 26);
        if (chunks < 1) chunks = 1;
        screenHt = (chunks * 26) - 10;
      }
      if (screenHt > maxHeight) screenHt = maxHeight;
      stationSelector.style.height = screenHt + 'px';
    }
  }

  $window.addEventListener('resize', function() {
    adjustMessageDropdownHeight();
  });

  var modalDefaults = {
    backdrop: true,
    keyboard: true,
    modalFade: true,
    templateUrl: 'partials/modal.html',
    windowClass: 'message-scheduler',
    daysOfWeek: [],
  };

  var defaultModalOptions = {
    modalDialog: true,
    selectScope: false,
    actionButtonText: 'Save',
    headerText: 'Add Message Event',
    hourList: hourList,
    minuteList: minuteList,
    playCountList: playCountList,
  };

  this.setOptions = function(customModalOptions) {
    for (var key in customModalOptions) {
      if (customModalOptions.hasOwnProperty(key)) {
        modalOptions[key] = customModalOptions[key];
      }
    }
  }

  this.getOptions = function() {
    return modalOptions;
  }

  this.setModel = function(customModalModel) {
    modalModel = customModalModel;
  }

  this.show = function () {
    var tempModalOptions = {};
    var tempModalDefaults = {};

    angular.extend(tempModalOptions, defaultModalOptions, modalOptions);
    tempModalDefaults = modalDefaults;
    if (tempModalOptions.templateUrl && tempModalOptions.templateUrl.length > 0)
      tempModalDefaults.templateUrl = tempModalOptions.templateUrl;

    tempModalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.modalOptions = tempModalOptions;
      $scope.modalModel = modalModel;
      if (!$scope.modalModel.scope) {
        $scope.modalModel.scope = 'series';
      }
      $scope.datePickerVisible = false;
      $scope.buttonEnabled = false;
      $scope.selectedMessageName = 'Select a Message';
      if ($scope.modalModel.message) {
        for (var i=0; i<$scope.modalOptions.messageList.length; i++) {
          if ($scope.modalOptions.messageList[i].id === $scope.modalModel.message) {
            $scope.selectedMessageName = $scope.modalOptions.messageList[i].name;
            break;
          }
        }
      }
      var pad = function(n,width) {
        return ("0"+n).slice(-width);
      }
      var get24Hour = function(hour, ampm) {
        if(ampm == 'pm' && parseInt(hour) < 12) {
          return parseInt(hour) + 12;
        }
        else if(ampm == 'am' && parseInt(hour) == 12) {
          return 0;
        }
        return hour;
      }

      if (typeof $scope.modalModel.startMinute != 'undefined')
        $scope.modalModel.startMinute = pad($scope.modalModel.startMinute,2);

      var startDatePickerIsOpen = false;
      var endDatePickerIsOpen = false;
      if (!$scope.modalModel.startAmpm) {
        $scope.modalModel.startAmpm = 'am';
      }
      if (!$scope.modalModel.repeatType || $scope.modalModel.repeatType.length < 1) {
        $scope.modalModel.repeatType = 'none';
      }
      if ($scope.modalModel.repeatType == 'DAILY') {
        if ($scope.modalModel.daysOfWeek && $scope.modalModel.daysOfWeek.length > 0) {
          $scope.modalModel.repeatType = 'weekly';
        } else {
          $scope.modalModel.repeatType = 'daily';
        }
      }
      if (!$scope.modalModel.endRepeatType) {
        $scope.modalModel.endRepeatType = 'afterPlays';
      }
      if ($scope.modalModel.endRepeatType == 'afterPlays') {
        $scope.modalModel.endDate = '';
        $scope.modalModel.playCount = parseInt($scope.modalModel.playCount);
      } else {
        $scope.modalModel.playCount = '';
      }
      // temporary until we finish exception handling
      $scope.modalOptions.selectScope = false;
      $scope.modalOptions.deleteButtonText = "Delete Series";
      if ($scope.modalModel.repeatType == 'none') {
        $scope.modalOptions.selectScope = false;
        $scope.modalOptions.deleteButtonText = "Delete Event";
      }
      $scope.changeRepeatType = function() {
        if ($scope.modalModel.repeatType != 'none') {
          $scope.modalOptions.deleteButtonText = "Delete Series";
          if ($scope.modalModel.repeatType == 'daily') {
            $scope.modalModel.daysOfWeek = [];
          }
        } else {
          $scope.modalOptions.deleteButtonText = "Delete Event";
        }
        $scope.checkButton();
      }

      $scope.toggleStartDatePicker = function() {
        $scope.startDatePickerVisible = !$scope.startDatePickerVisible;
      }
      $scope.toggleEndDatePicker = function() {
        $scope.endDatePickerVisible = !$scope.endDatePickerVisible;
      }
      $scope.closeStartDatePicker = function() {
        if (startDatePickerIsOpen) {
          $scope.startDatePickerVisible = false;
          $scope.checkButton();
          startDatePickerIsOpen = false;
        } else {
          startDatePickerIsOpen = $scope.startDatePickerVisible;
        }
      }
      $scope.closeEndDatePicker = function() {
        if (endDatePickerIsOpen) {
          $scope.endDatePickerVisible = false;
          endDatePickerIsOpen = false;
        } else {
          endDatePickerIsOpen = $scope.endDatePickerVisible;
        }
      }

      $scope.filterHours = function(input) {
        /*
        hourInputString = input;
        var filter = $q.defer();
        var normalisedInput = input.toLowerCase();

        var filteredArray = hourList.filter(function(hour) {
          return hour.toLowerCase().indexOf(normalisedInput) === 0;
        });

        filter.resolve(filteredArray);
        return filter.promise;
        */
      }

      $scope.filterMinutes = function(input) {
        /*
        minuteInputString = input;
        var filter = $q.defer();
        var normalisedInput = input.toLowerCase();

        var filteredArray = minuteList.filter(function(min) {
          return min.toLowerCase().indexOf(normalisedInput) === 0;
        });

        filter.resolve(filteredArray);
        return filter.promise;
        */
      }

      $scope.del = function() {
        confirmationDialog($scope,
          'Are you sure you want to delete this message event series?',
          function() {
            var startDate = $scope.modalModel.exStartDate.split('/');
            var dateString = pad(startDate[2],4)+'-'+pad(startDate[0],2)+'-'+pad(startDate[1],2)+'T00:00:00.000Z';
            //var exclude_at = new Date($scope.modalModel.exStartDate);
            var exclude_at = new Date(dateString);
            var result = {
              scope: $scope.modalModel.scope,
              modalStatus: 'delete',
              date: exclude_at
            };
            $modalInstance.close(result);
            $scope.modalModel = {};
            modalModel = {};
          }
        );
      }

      $scope.formatDate = function(date) {
        return moment(date).format('MM/DD/YYYY');
      }

      $scope.ok = function () {
        var cleanStartDate = $scope.modalModel.startDate.replace(/[^ -~]/g,'');
        var cleanEndDate = $scope.modalModel.endDate.replace(/[^ -~]/g,'');
        if ($scope.modalModel.scope == 'solo') {
          var startHour = get24Hour($scope.modalModel.startHour, $scope.modalModel.startAmpm);
          var date = $scope.modalModel.exStartDate.split('/');
          var dateString = pad(date[2],4)+'-'+pad(date[0],2)+'-'+pad(date[1],2)+'T'+pad(startHour,2)+':'+pad($scope.modalModel.startMinute,2)+':00.000Z';
          var start_at = new Date(dateString);
          var result = {
            scope: $scope.modalModel.scope,
            modalStatus: 'ok',
            date: start_at
          };
        } else if ($scope.modalModel.scope == 'series') {
          var days = [];
          if (!$scope.modalModel.startMinute) $scope.modalModel.startMinute = 0;
          if (!$scope.modalModel.startHour) $scope.modalModel.startHour = 12;
          var startHour = pad(get24Hour($scope.modalModel.startHour, $scope.modalModel.startAmpm),2);
          $scope.modalModel.startMinute = pad($scope.modalModel.startMinute,2);
          var startDate = cleanStartDate.split('/');
          var start_at = pad(startDate[2],4)+pad(startDate[0],2)+pad(startDate[1],2)+'T'+startHour+$scope.modalModel.startMinute+'00';
          var end_at = '';
          var endDate = 0;
          var endPlays = 0;
          var recurInfo = '';
          var itemid = Math.floor(Math.random()*900000) + 100000;
          if ($scope.modalModel.repeatType != 'none') {
            if ($scope.modalModel.endRepeatType == 'afterPlays') {
              if (!$scope.modalModel.playCount) {
                var rule = new RRule({
                  freq: RRule.DAILY,
                  byweekday: $scope.modalModel.daysOfWeek,
                });
              }
              else {
                endPlays = $scope.modalModel.playCount;
                var rule = new RRule({
                  freq: RRule.DAILY,
                  byweekday: $scope.modalModel.daysOfWeek,
                  count: endPlays
                });
              }
              recurInfo = rule.toString();
            }
            else if ($scope.modalModel.endRepeatType == 'onDate') {
              if (cleanEndDate.length > 0) {
                var endDate = cleanEndDate.split('/');
                end_at = pad(endDate[2],4)+pad(endDate[0],2)+pad(endDate[1],2)+'T235959';
              }
              var rule = new RRule({
                freq: RRule.DAILY,
                byweekday: $scope.modalModel.daysOfWeek
              });
              recurInfo = rule.toString();
            }
          }
          if ($scope.modalModel.itemid) {
            itemid = $scope.modalModel.itemid;
          }

          var result = {
            scope: $scope.modalModel.scope,
            series: {
              itemid: itemid,
              scheduleid: $scope.modalModel.scheduleid,
              messageid: $scope.modalModel.message,
              recurInfo: recurInfo,
              start_at: start_at,
              end_at: end_at,
            },
            modalStatus: 'ok'
          };
        }
        $modalInstance.close(result);
        modalModel = {};
      };
      $scope.$on('day selected',function(ev,data) {
        $scope.checkButton();
      });
      $scope.cancel = function (result) {
        $modalInstance.dismiss('cancel');
        $scope.modalModel = {};
        modalModel = {};
      };
      $scope.handleEnterKey = function(ev) {
        if (ev.keyCode == 13 && $scope.buttonEnabled === true) {
          $scope.ok();
        }
      };
      $scope.checkButton = function() {
        if ($scope.modalModel.message && $scope.modalModel.startDate && $scope.modalModel.startHour && $scope.modalModel.startMinute) {
          if (
            typeof $scope.modalModel.startHour == 'string' && typeof $scope.modalModel.startMinute == 'string' &&
            ($scope.modalModel.startHour.match(/^[1-9]{1}$/) || $scope.modalModel.startHour.match(/^1[0-2]{1}$/)) &&
            $scope.modalModel.startMinute.match(/^[0-5][0-9]$/)
          )
            $scope.buttonEnabled = true;
          else
            $scope.buttonEnabled = false;
        } else $scope.buttonEnabled = false;
        if ($scope.modalModel.repeatType == 'weekly' && $scope.modalModel.daysOfWeek.length == 0) {
          $scope.buttonEnabled = false;
          $scope.showDayPrompt = true;
        } else {
          $scope.showDayPrompt = false;
        }
      }
      $scope.selectHour = function(input) {
        $scope.modalModel.startHour = ''+input;
        $scope.checkButton();
      }

      $scope.selectMinute = function(input) {
        $scope.modalModel.startMinute = ''+input;
        $scope.checkButton();
      }

      $scope.selectPlayCount = function(input) {
        $scope.modalModel.playCount = ''+input;
      }

      $scope.checkButton();

      $scope.$watch('$viewContentLoaded', function() {
        $timeout(function() {
          adjustMessageDropdownHeight();
        }, 500);
      });
    }];

    return $modal.open(tempModalDefaults).result;
  };

}]);

app.service('messageSchedulerToolbarService', ['$rootScope', function ($rootScope) {
  var service = this;

  var options = {
    id: null,
    x: 0,
    y: 100,
    day: 0,
  };

  service.updateLocation = false;
  service.trigger = {};

  service.setOptions = function(info) {
    options.x = info.x;
    options.y = info.y;
    options.dateLabel = info.dateLabel;
    options.timeLabel = info.timeLabel;
    options.day = info.day;
    options.is_recurring = info.is_recurring;
    options.name = info.name;
    service.updateLocation = true;
  }

  service.getLocation = function() {
    service.updateLocation = false;
    return { x: options.x, y: options.y };
  }

  service.setTrigger = function(trigger) {
    service.trigger = {
      day: options.day,
      action: trigger,
      id: options.id,
    }
    $rootScope.$emit('triggerMessageSchedulerToolbarAction', service.trigger);
  }

  service.show = function (day,slotId) {
    options.day = day;
    options.id = slotId;
    $rootScope.$emit('showMessageSchedulerPopup', options);
  }

  service.hide = function () {
    options.slotId = null;
  }

}]);

app.factory('messageSelection', ['api', 'intercom', 'streamUpdateService',
  function messageSelection(api, intercom, streamUpdateService) {
    var presets = [];
    var schedules = [];
    var presetSelectionWasSet = false;
    var scheduleSelectionWasSet = false;

    var currentSelection = {};

    function initSelection(selection) {
      if (selection.messagePreset) {
        currentSelection.message_preset = selection.messagePreset;
      }
      if (selection.messageSchedule) {
        currentSelection.schedule_id = selection.messageSchedule;
      }
    }

    function getSelection() {
      return currentSelection;
    }

    function loadPresets() {
      return api.getPresets()
        .then(function(result) {
          presets = result.presets;
        });
    }

    function loadSchedules() {
      return api.getMe()
        .then(function() {
          return api.getMessageSchedules()
            .then(function(result) {
              schedules = result.schedules;
          });
      });
    }

    function getMessagePresetFromAPI (presetId, callback) {
      return api.getMessagePresetDetails(presetId)
        .then(function(result) {
          var cachedPreset = getMessagePreset(presetId);
          cachedPreset.name = result.preset.name;
          if (callback) {
            callback();
          }
        });
    }
    function getMessageScheduleFromAPI(scheduleId, callback) {
      return api.getMe()
        .then(function() {
          api.getMessageScheduleDetails(scheduleId)
            .then(function(result) {
              var cachedSchedule = getMessageSchedule(scheduleId);
              cachedSchedule.name = result.schedule.name;
              if (callback) {
                callback();
              }
            })
            .catch(function (err) {
              console.error("Error occurred in fetching schedule for given id.", err);
            });
      });
    }

    function getMessagePreset (presetId) {
      if (presets) {
        var messagePreset = {};
        presets.forEach(function(preset) {
          if (presetId === preset.presetid) {
            messagePreset = preset;
          }
        });
        // If we couldn't find the message preset just generate a placeholder name
        if (presetId && !Object.keys(messagePreset).length) {
          messagePreset = {
            presetid: presetId,
            name: '(account-created preset)'
          };
        }
        return messagePreset;
      }
    }

    function getMessageSchedule (scheduleId) {
      if (schedules) {
        var messageSchedule = {};
        schedules.forEach(function(schedule) {
          if (scheduleId === schedule.scheduleid) {
            messageSchedule = schedule;
          }
        });
        // If we couldn't find the message schedule just generate a placeholder name
        if (scheduleId && !Object.keys(messageSchedule).length) {
          messageSchedule = {
            scheduleid: scheduleId,
            name: '(account-created schedule)'
          };
        }
        return messageSchedule;
      }
    }
    function setSelection(messageData, callback) {
      var selectedStream = streamUpdateService.getSelectedStream();
      if (selectedStream.streamid) {
        if (messageData.messagePreset !== undefined) {
          currentSelection.message_preset = messageData.messagePreset;
          presetSelectionWasSet = true;
        }
        if (messageData.messageSchedule !== undefined) {
          currentSelection.schedule_id = messageData.messageSchedule;
          scheduleSelectionWasSet = true;
        }
      } else {
        console.error('Unable to set the zone. Please select a zone first.');
        if (callback) {
            callback(false);
        }
      }
    }

    function clearSchedule() {
      currentSelection.schedule_id = null;
      scheduleSelectionWasSet = true;
    }

    function clearPreset() {
      currentSelection.message_preset = null;
      presetSelectionWasSet = true;
    }

    function checkPresetSelectionFlag() {
        return presetSelectionWasSet;
    }

    function checkScheduleSelectionFlag() {
        return scheduleSelectionWasSet;
    }

    function clearPresetSelectionFlag() {
        presetSelectionWasSet = false;
    }

    function clearScheduleSelectionFlag() {
       scheduleSelectionWasSet = false;
    }


    return {
      loadPresets: loadPresets,
      loadSchedules: loadSchedules,
      initSelection:initSelection,
      getSelection: getSelection,
      setSelection: setSelection,
      clearSchedule: clearSchedule,
      clearPreset: clearPreset,
      checkPresetSelectionFlag: checkPresetSelectionFlag,
      checkScheduleSelectionFlag: checkScheduleSelectionFlag,
      clearPresetSelectionFlag: clearPresetSelectionFlag,
      clearScheduleSelectionFlag: clearScheduleSelectionFlag,
      getMessagePreset: getMessagePreset,
      getMessageSchedule: getMessageSchedule,
      getMessagePresetFromAPI: getMessagePresetFromAPI,
      getMessageScheduleFromAPI:getMessageScheduleFromAPI
    };
  }
]);

app.service('messageUploadModal', ['$modal', 'api', 'intercom', function ($modal, api, intercom) {
  var modalOptions = {};
  var modalModel = {};

  var modalDefaults = {
    backdrop: true,
    keyboard: true,
    modalFade: true,
    windowClass: 'message-upload-window',
  };

  var model = {
    file: {},
    title: '',
  };

  var resetModel = function() {
    model = {
      file: {},
      title: '',
    };
  }

  var defaultModalOptions = {
    modalDialog: true,
    templateUrl: 'partials/message_upload_modal.html',
    actionButtonText: 'Upload Message',
    headerText: 'Upload Message (.mp3)',
    requiredFields: ['file', 'title'],
  };

  this.setOptions = function(customModalOptions) {
    for (var key in customModalOptions) {
      if (customModalOptions.hasOwnProperty(key)) {
        modalOptions[key] = customModalOptions[key];
      }
    }
  }

  this.getOptions = function() {
    return modalOptions;
  }

  this.show = function () {
    var tempModalOptions = {};
    var tempModalDefaults = {};

    angular.extend(tempModalOptions, defaultModalOptions, modalOptions);
    tempModalDefaults = modalDefaults;
    if (tempModalOptions.templateUrl && tempModalOptions.templateUrl.length > 0)
      tempModalDefaults.templateUrl = tempModalOptions.templateUrl;

    tempModalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.modalModel = {};
      $scope.modalOptions = tempModalOptions;
      $scope.modalModel = model;
      $scope.buttonEnabled = false;
      $scope.ok = function () {
        if ($scope.modalModel.file.name && $scope.modalModel.file.name.length) {
          $scope.buttonEnabled = false;
          var file = $scope.modalModel.file;
          var data = {
            message_name: $scope.modalModel.title
          };

          $scope.dataReady = false;
          $scope.isUploadingFile = true;
          $scope.progress = '1';
          api.uploadMessage(file, data, function(percent) {
            $scope.progress = percent;
          }, function (result) {
            $scope.dataReady = true;
            if (result.meta.code === 200) {
              intercom.sendEvent('Uploaded message', { name: $scope.modalModel.title });
              $scope.modalModel.status = 'ok';
              $scope.modalModel.resultMessage = 'Your message has been uploaded';
              console.log($scope.modalModel.resultMessage);
              $scope.modalModel.file = {};
              $scope.modalModel.title = '';
              $modalInstance.close($scope.modalModel);
              resetModel();
            }
            else if (result.meta.status === 'error') {
              $scope.modalModel.status = 'error';
              $scope.modalModel.resultMessage = 'There was an error with your file upload.\nPlease try again.';
              console.log($scope.modalModel.resultMessage);
              console.error(result);
              $modalInstance.close($scope.modalModel);
              resetModel();
            }
            else {
              $scope.modalModel.status = 'error';
              $scope.modalModel.resultMessage = 'There was an unknown error with your file upload.\nPlease try again.';
              console.log($scope.modalModel.resultMessage);
              console.error(result);
              $modalInstance.close($scope.modalModel);
              resetModel();
            }
          });
        }
      };
      $scope.cancel = function (result) {
        resetModel();
        $modalInstance.dismiss('cancel');
      };
      var checkFileType = function() {
        if ($scope.modalModel.file && $scope.modalModel.file.name) {
          var fileName = $scope.modalModel.file.name.split(".");
          if (fileName.pop() !== 'mp3') {
            $scope.fileTypeError = 'Filetype must be .mp3';
            return false;
          } else {
            $scope.fileTypeError = '';
            return true;
          }
        }
      };
      $scope.checkButton = function() {
        if (
          $scope.modalModel.title &&
          $scope.modalModel.title.length > 0 &&
          $scope.modalModel.file &&
          $scope.modalModel.file.name &&
          checkFileType()
          ) {
          $scope.buttonEnabled = true;
        } else {
          checkFileType();
          $scope.buttonEnabled = false;
        }
      };
      $scope.checkButton();
    }];

    return $modal.open(tempModalDefaults).result;
  };

}]);

app.service('modalService', ['$modal', function ($modal) {
  var modalOptions = {};
  var modalModel = {};

  var modalDefaults = {
    backdrop: true,
    keyboard: true,
    modalFade: true,
  };

  var defaultModalOptions = {
    modalDialog: true,
    templateUrl: 'partials/modal.html',
    closeButtonText: 'Close',
    actionButtonText: 'OK',
    headerText: 'Proceed?',
    bodyText: 'Perform this action?',
    requiredFields: [],
  };

  this.setOptions = function(customModalOptions) {
    for (var key in customModalOptions) {
      if (customModalOptions.hasOwnProperty(key)) {
        modalOptions[key] = customModalOptions[key];
      }
    }
  }

  this.getOptions = function() {
    return modalOptions;
  }

  this.setModel = function(customModalModel) {
    modalModel = customModalModel;
  }

  this.show = function () {
    var tempModalOptions = {};
    var tempModalDefaults = {};

    angular.extend(tempModalOptions, defaultModalOptions, modalOptions);
    tempModalDefaults = modalDefaults;
    if (tempModalOptions.templateUrl && tempModalOptions.templateUrl.length > 0)
      tempModalDefaults.templateUrl = tempModalOptions.templateUrl;

    tempModalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.modalOptions = tempModalOptions;
      $scope.modalModel = modalModel;
      $scope.buttonEnabled = false;
      $scope.modalOptions.ok = function () {
        $modalInstance.close($scope.modalModel);
        modalModel = {};
      };
      $scope.modalOptions.close = function (result) {
        $modalInstance.dismiss('cancel');
        $scope.modalModel = {};
        modalModel = {};
      };
      var checkButton = function() {
        var ok = true;
        for(var i=0; i<$scope.modalOptions.requiredFields.length; i++) {
          if ($scope.modalModel[$scope.modalOptions.requiredFields[i]].length == 0) {
            ok = false;
          }
        }
        if (ok) {
          $scope.buttonEnabled = true;
        } else $scope.buttonEnabled = false;
      }
      checkButton();
    }];

    return $modal.open(tempModalDefaults).result;
  };

}]);

app.factory('musicSelection', ['$rootScope', 'api', 'intercom', 'streamUpdateService',
  function musicSelection($rootScope, api, intercom, streamUpdateService) {
    var selectionWasSet = false;

    var currentSelection = {
      music_type: api.userObject.music_type,
      music_id: api.userObject.music_id
    };

    var searchValue = '';
    var notifyCallback = null;

    function getSelection() {
      return currentSelection;
    }

    function updateSelectionInfo(musicType, musicId, when) {
      if (currentSelection.music_id != musicId) {
        currentSelection.music_type = musicType;
        currentSelection.music_id = musicId;
        api.userObject.music_type = musicType;
        api.userObject.music_id = musicId;

        var selectedStream = streamUpdateService.getSelectedStream();
        selectedStream.music_id = musicId;
        selectedStream.music_type = musicType;
        streamUpdateService.setSelectedStream(selectedStream);

        if (notifyCallback) {
          notifyCallback(when);
        }
      }
    }

    function setSelection(musicType, musicId, musicName, when, callback) {
      var selectedStream = streamUpdateService.getSelectedStream();
      if (selectedStream.streamid) {
        api.selectMusic(musicType, musicId, selectedStream.streamid, when, function (result) {
          intercom.sendEvent(musicType + ' selected', { "name": musicName, "when": when });
          if (callback) callback(true);
        }, function(error) {
          console.error('Unable to set the selection to ' + musicName, error);
          if (callback) {
            callback(false, error);
          }
        });
      } else {
        console.error('Unable to set the selection to ' + musicName + '. No stream set. Please select a stream first.');
        if (callback) callback(false);
      }
    }

    function setSearchValue(str) {
      searchValue = str;
    }

    function clearSearchValue() {
      searchValue = '';
    }

    function getSearchValue() {
      return searchValue;
    }

    function setSelectionFlag() {
      selectionWasSet = true;
    }

    function checkSelectionFlag() {
      return selectionWasSet;
    }

    function clearSelectionFlag() {
      selectionWasSet = false;
    }

    function setNotifyCallback(callback) {
      notifyCallback = callback;
    }

    return {
      getSelection: getSelection,
      setSelection: setSelection,
      updateSelectionInfo: updateSelectionInfo,
      setSearchValue: setSearchValue,
      clearSearchValue: clearSearchValue,
      getSearchValue: getSearchValue,
      setSelectionFlag: setSelectionFlag,
      checkSelectionFlag: checkSelectionFlag,
      clearSelectionFlag: clearSelectionFlag,
      setNotifyCallback: setNotifyCallback
    };
  }
]);

(function (app) {
  app.factory('navigationService', navigationService);

  navigationService.$inject = ['$cookies'];

  function navigationService($cookies) {
    var stateChangeData = {
      forceNextTransition: false,
      userConfirmedNextTransition: false
    };

    return {

      // Properties
      stateChangeData: stateChangeData,

      // Methods
      clearStateChangeData: clearStateChangeData,
      shouldRedirectToLogin: shouldRedirectToLogin
    };

    function clearStateChangeData() {
      stateChangeData.forceNextTransition = false;
      stateChangeData.userConfirmedNextTransition = false;
    }

    function shouldRedirectToLogin(toState) {
      var ignorePaths = [
        '/login',
        '/password_request?linkcode',
        '/password_reset/:token',
        '/register/account',
        '/webautologin/:accesskey',
        '/sonos/login?linkcode',
        '/sonos/register?linkcode'
      ];
      var ignoreStates = [
        'error'
      ];

      var isNotAuthenticated = !$cookies.get('Authorization');
      var isToStateNotIgnored = ignorePaths.indexOf(toState.url) === -1 && ignoreStates.indexOf(toState.name) === -1;

      return isNotAuthenticated && isToStateNotIgnored;
    }
  }

})(app);
app.factory('networkConstraintsService', networkConstraintsService);

networkConstraintsService.$inject = ['$q', 'api', 'apiTimeDataUtility'];

function networkConstraintsService($q, api, apiTimeDataUtility) {
  var DEFAULT_DOWNLOAD_START_TIME = '01:00:00';
  var DEFAULT_DOWNLOAD_STOP_TIME  = '03:00:00';

  var downloadWindowValidator = networkConstraintsDownloadWindowValidator(apiTimeDataUtility);

  return {

    // Methods
    deleteDownloadWindow: deleteDownloadWindow,
    getDefaultDownloadWindow: getDefaultDownloadWindow,
    getMinimumDownloadWindowDurationAsHours: getMinimumDownloadWindowDurationAsHours,
    getNetworkConstraints: getNetworkConstraints,
    isDownloadStopTimeInNextDay: isDownloadStopTimeInNextDay,
    isPrefetchEnabled: isPrefetchEnabled,
    updateNetworkConstraints: updateNetworkConstraints,
    validateDownloadWindow: validateDownloadWindow
  };

  // Public methods

  function deleteDownloadWindow() {
    var deferred = $q.defer();

    api.deleteDeviceNetworkConstraintsDownloadWindow()
      .then(function () {
        deferred.resolve();
      })
      .catch(function (err) {

        // TODO: Handle error
        deferred.reject();
      });

    return deferred.promise;
  }

  function getDefaultDownloadWindow() {
    return {
      downloadStartTime: DEFAULT_DOWNLOAD_START_TIME,
      downloadStopTime: DEFAULT_DOWNLOAD_STOP_TIME
    };
  }

  function getMinimumDownloadWindowDurationAsHours() {
    var hours = downloadWindowValidator.DOWNLOAD_WINDOW_DURATION_MIN_MILLISECONDS / 1000 / 60 / 60;

    return parseFloat(hours.toFixed(2));
  }

  function getNetworkConstraints() {
    var deferred = $q.defer();

    api.getDeviceNetworkConstraints()
      .then(function (data) {
        deferred.resolve(data);
      })
      .catch(function (err) {

        // TODO: Handle error
        deferred.reject();
      });

    return deferred.promise;
  }

  function isDownloadStopTimeInNextDay(downloadStartTimeParts, downloadStopTimeParts) {
    return downloadWindowValidator.isStopTimeInNextDay(downloadStartTimeParts, downloadStopTimeParts);
  }

  function isPrefetchEnabled() {
    return api.userObject && api.userObject.account && api.userObject.account.use_prefetch;
  }

  function updateNetworkConstraints(config) {
    var deferred = $q.defer();
    var apiModel = {
      download_start_time: config.downloadStartTime,
      download_stop_time: config.downloadStopTime
    };

    api.updateDeviceNetworkConstraints(apiModel)
      .then(function (data) {
        deferred.resolve(data);
      })
      .catch(function (err) {

        // TODO: Handle error
        deferred.reject(err);
      });

     return deferred.promise;
  }

  function validateDownloadWindow(downloadStartTime, downloadStopTime) {
    return downloadWindowValidator.validate(downloadStartTime, downloadStopTime);
  }
}

function networkConstraintsDownloadWindowValidator(apiTimeDataUtility) {

  // The download window must be at least 1 hour in duration
  var DOWNLOAD_WINDOW_DURATION_MIN_MILLISECONDS = 60 * 60 * 1000;

  return {

    // Properties
    DOWNLOAD_WINDOW_DURATION_MIN_MILLISECONDS: DOWNLOAD_WINDOW_DURATION_MIN_MILLISECONDS,

    // Methods
    isStopTimeInNextDay: isStopTimeInNextDay,
    validate: validate
  };

  // Public methods

  function isStopTimeInNextDay(startTime, stopTime) {
    var startTimeMs = apiTimeDataUtility.convertTimePartsToMilliseconds(startTime);
    var stopTimeMs = apiTimeDataUtility.convertTimePartsToMilliseconds(stopTime);

    var result =
      (startTime.period === 'pm' && stopTime.period === 'am')
      || (startTime.period === stopTime.period && stopTimeMs < startTimeMs);

    return result;
  }

  function validate(startTime, stopTime) {
    var valid = false;

    var hasStartTime = startTime && startTime.hours && startTime.minutes;
    var hasStopTime = stopTime && stopTime.hours && stopTime.minutes;

    if (hasStartTime && hasStopTime) {
      var isStartTimeValid = validateTimeHours(startTime.hours) && validateTimeMinutes(startTime.minutes);
      var isStopTimeValid = validateTimeHours(stopTime.hours) && validateTimeMinutes(stopTime.minutes) && validateMinStopTime(startTime, stopTime);

      valid = isStartTimeValid && isStopTimeValid;
    }

    return valid;
  }

  // Private methods

  function validateMinStopTime(startTime, stopTime) {
    var startTimeMs = apiTimeDataUtility.convertTimePartsToMilliseconds(startTime);
    var stopTimeMs = apiTimeDataUtility.convertTimePartsToMilliseconds(stopTime);

    // Account for end times that are in the following day
    if (isStopTimeInNextDay(startTime, stopTime)) {
      stopTimeMs += 24 * 60 * 60 * 1000;
    }

    var durationMs = stopTimeMs - startTimeMs;

    return durationMs >= DOWNLOAD_WINDOW_DURATION_MIN_MILLISECONDS;
  }

  function validateTimeHours(hours) {
    return typeof hours === 'string' && (hours.match(/^[1-9]{1}$/) || hours.match(/^1[0-2]{1}$/));
  }

  function validateTimeMinutes(minutes) {
    return typeof minutes === 'string' && minutes.match(/^[0-5][0-9]$/);
  }
}
app.factory('playerConfirmationModal', ['$modal', function($modal) {
  return function(options, confirmationCallback, dismissCallback) {
    var description;

    if (typeof options !== 'object') options = {};
    if (typeof options.stream !== 'object') {
      console.error("No Stream provided for dialog!");
      return;
    }

    var modalConfig = {
      templateUrl: 'partials/player_confirmation_modal.html',
      keyboard: true,
      modalFade: true,
      backdrop: (typeof options.backdrop === 'boolean') ? options.backdrop : true,
      title: (typeof options.title === 'string') ? options.title : 'Stream Now',
      description: (typeof options.description === 'string') ? options.description : 'This will deactivate any other device currently streaming <strong>' + options.stream.streamname + '</strong>. Would you like to continue?</p>',
      controlMode: (typeof options.controlMode === 'boolean') ? options.controlMode : true,
      stream: options.stream,
    };

    modalConfig.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.streamName = modalConfig.stream.streamname;
      $scope.title = modalConfig.title;
      $scope.description = modalConfig.description;

      $scope.ok = function () {
        $modalInstance.close();
        confirmationCallback();
      }

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
        if (dismissCallback) dismissCallback();
      }
    }];

    return $modal.open(modalConfig).result;
  }
}]);

app.factory('playerService', [
  function() {
    var _REMOTE = 0;
    var _PLAYING = 1;
    var controlMode = _REMOTE;

    function getMode() {
      return controlMode;
    }

    function setMode(mode) {
      if (mode === _PLAYING || mode === _REMOTE)
        controlMode = mode;
      else
        ; // leave it alone!
      return controlMode;
    }

    function setRemoteControlMode() {
      controlMode = _REMOTE;
      return controlMode;
    }

    function setPlayingMode() {
      controlMode = _PLAYING;
      return controlMode;
    }

    function isRemoteControlMode() {
      return controlMode === _REMOTE;
    }

    function isPlayingMode() {
      return controlMode === _PLAYING;
    }

    return {
      getMode: getMode,
      setMode: setMode,
      setRemoteControlMode: setRemoteControlMode,
      setPlayingMode: setPlayingMode,
      isRemoteControlMode: isRemoteControlMode,
      isPlayingMode: isPlayingMode,
    };
  }
]);

app.factory('playerTakeoverNotification', ['$modal', function($modal) {
  return function(stream, callback) {
    var modalDefaults = {
      templateUrl: 'partials/player_takeover_notification.html',
      backdrop: true,
      keyboard: true,
      modalFade: true,
    };

    modalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.streamName = stream.streamname;
      if (stream.devicetype === 'pc') {
        $scope.deviceType = 'Another browser';
      } else if (stream.devicetype === 'mobile ios') {
        $scope.deviceType = 'An iOS device';
      } else if (stream.devicetype === 'mobile android') {
        $scope.deviceType = 'An Android device';
      } else if (stream.devicetype === 'cloudbox') {
        $scope.deviceType = 'A CloudBox';
      } else if (stream.devicetype === 'selfserve') {
        $scope.deviceType = 'A third-party player';
      } else if (stream.devicetype === 'sonos') {
        $scope.deviceType = 'A Sonos speaker';
      } else {
        $scope.deviceType = 'An unknown device';
      }

      $scope.ok = function () {
        $modalInstance.close();
        if (typeof callback === 'function') callback();
      }
    }];

    return $modal.open(modalDefaults).result;
  }
}]);

(function (app) {
  app.factory('playlistCategoryService', ['api', 'favorites', 'localStorage', playlistCategoryService]);

  function playlistCategoryService(api, favorites, localStorage) {

    // Key used to store user's recent list in localStorage
    var userId = null;
    var recentListKey = null;

    var mostPopularCategoryPlaylistIdsOrdered = [
      309,  // '60s, '70s, and '80s Hits
      20,   // '70s Greatest Hits
      310,  // '70s, '80s, and '90s Hits
      1,    // '80s Greatest Hits
      211,  // '80s Rock
      72,   // '90s Greatest Hits
      107,  // '90s Rock
      312,  // '90s, 2000s, and 2010s Hits
      149,  // 2000s Greatest Hits
      170,  // 2010s Greatest Hits
      230,  // 2020s Pop
      198,  // Blend: Upbeat Essentials
      110,  // Blend: Upbeat Restaurant
      43,   // Family Friendly
      240,  // Feel Good Hits
      131,  // Pop Party
      59,   // Rock Classic
      319,  // Today's Adult Hits
      37    // Today's Hits
    ];

    var newestReleasesCategoryPlaylistIdsOrdered = [
      321,  // PRIDE Party
      311,  // '80s, '90s, 2000s Hits
      315,  // Easy Listening
      317,  // Hipster Cocktail Party
      314,  // Beach Bar Lounge
      316,  // Hipster BBQ
      318   // Lite Rock & Pop Hits
    ];

    var pandoraCategoryPlaylistIdsOrdered = [
      145,  // 60s Greatest Hits
      309,  // 60s, 70s, and 80s Hits
      2,    // Rock Soft
      310,  // 70s, 80s, and 90s Hits
      210,  // 80s Pop
      211,  // 80s Rock
      312,  // 90s, 2000s, and 2010s Hits
      314,  // Beach Bar Lounge
      38,   // Coffee Shop
      59,   // Rock Classic
      315,  // Loosely: Caruso American Playbook/Sophisticated Standards
      316,  // Hipster BBQ
      317,  // Loosely: Coffee Shop Indie, Indie Pop Chillout, Coffee Shop & Coffee Shop Neo-Soul
      318,  // Lite Rock and Pop Hits
      15,   // Jazz Smooth
      319,  // Today's Adult Hits
      268,  // Fresh Country
      37    // Today's Hits
    ];

    var playlistCategoriesCommonOrdered = {
      genre: [
        'Country',
        'Hip Hop',
        'Jazz',
        'Pop',
        'R&B / Soul',
        'Rock'
      ],
      business: [
        'Coffee Shops',
        'Fitness',
        'Nightlife',
        'QSR',
        'Restaurants',
        'Retail'
      ],
      mood: [
        'Casual',
        'Energetic',
        'Happy',
        'Relaxed',
        'Trendy'
      ]
    };

    function getCommonPlaylistCategories() {
      return playlistCategoriesCommonOrdered;
    }

    function filterPlaylistsByMostPopularCategory(playlists) {
      var playlistIds = !playlists ? [] : playlists
        .map(function (p) {
          return p.playlistid;
        });

      var results = mostPopularCategoryPlaylistIdsOrdered
        .reduce(function (acc, playlistId) {
          var index = playlistIds.indexOf(playlistId);

          if (index > -1) {
            acc.push(playlists[index]);
          }

          return acc;
        }, []);

      return results;
    }

    function filterPlaylistsByNewestReleasesCategory(playlists) {
      var playlistIds = !playlists ? [] : playlists
        .map(function (p) {
          return p.playlistid;
        });

      var results = newestReleasesCategoryPlaylistIdsOrdered
        .reduce(function (acc, playlistId) {
          var index = playlistIds.indexOf(playlistId);

          if (index > -1) {
            acc.push(playlists[index]);
          }

          return acc;
        }, []);

      return results;
    }

    function filterPlaylistsByPandoraCategory(playlists) {
      var playlistIds = !playlists ? [] : playlists
        .map(function (p) {
          return p.playlistid;
        });

      var results = pandoraCategoryPlaylistIdsOrdered
        .reduce(function (acc, playlistId) {
          var index = playlistIds.indexOf(playlistId);

          if (index > -1) {
            acc.push(playlists[index]);
          }

          return acc;
        }, []);

      return results;
    }

    function filterPlaylistsByRecentCategory(playlists) {
      var playlistIds = !playlists ? [] : playlists
        .map(function (p) {
          return p.playlistid;
        });

      var results = getRecentList()
        .reduce(function (acc, playlistId) {
          var index = playlistIds.indexOf(playlistId);

          if (index > -1) {
            acc.push(playlists[index]);
          }

          return acc;
        }, []);

      return results;
    }

    function filterPlaylistsByFavoritesCategory(playlists) {
      var playlistIds = !playlists ? [] : playlists
        .map(function (p) {
          return p.playlistid;
        });

      return getFavoritesPlaylist()
        .then(function (favoritesIds) {
          return favoritesIds.reduce(function (acc, playlist) {
            var index = playlistIds.indexOf(playlist.id);
            if (index > -1) {
              acc.push(playlists[index]);
            }
            return acc;
          }, []);
        });
    }

    function isPlaylistCategoryCommon(categoryType, categoryName) {
      var categoriesByType = playlistCategoriesCommonOrdered[categoryType];

      if (!categoriesByType) {
        return false;
      }

      return categoriesByType.indexOf(categoryName) !== -1;
    }

    function getNewestReleases() {
      return newestReleasesCategoryPlaylistIdsOrdered;
    }

    function getMostPopular() {
      return mostPopularCategoryPlaylistIdsOrdered;
    }

    function getRecentList() {
      return localStorage.getItem(recentListKey) || [];
    }

    function getPandoraList() {
      return pandoraCategoryPlaylistIdsOrdered;
    }

    function getFavoritesPlaylist() {
      return favorites.getPlaylist(userId);
    }

    function setUserId(userid) {
      userId = userid;
      recentListKey = 'recent_list_' + userId;
    }

    function addToRecentList(playlistId) {
      if(recentListKey) {
        var recentList = localStorage.getItem(recentListKey) || [];
        recentList = recentList.filter(function (id) { return id !== playlistId; });
        recentList.unshift(playlistId);
        localStorage.setItem(recentListKey, recentList.slice(0, 10));
      } else {
        console.error('Unable to update recent list');
      }
    }

    return {

      // Methods
      filterPlaylistsByMostPopularCategory: filterPlaylistsByMostPopularCategory,
      filterPlaylistsByNewestReleasesCategory: filterPlaylistsByNewestReleasesCategory,
      filterPlaylistsByRecentCategory: filterPlaylistsByRecentCategory,
      filterPlaylistsByPandoraCategory: filterPlaylistsByPandoraCategory,
      filterPlaylistsByFavoritesCategory: filterPlaylistsByFavoritesCategory,
      getCommonPlaylistCategories: getCommonPlaylistCategories,
      getMostPopular: getMostPopular,
      getNewestReleases: getNewestReleases,
      getRecentList: getRecentList,
      getPandoraList: getPandoraList,
      getFavoritesPlaylist: getFavoritesPlaylist,
      isPlaylistCategoryCommon: isPlaylistCategoryCommon,
      addToRecentList: addToRecentList,
      setUserId: setUserId
    };
  }

})(app);

app.service('playlistService', [function () {
  var service = this;

  service.order = function(scope,orderBy) {
    scope.reverse = (scope.orderBy === orderBy) ? !scope.reverse : false;
    scope.orderBy = orderBy;
    scope.sortDirection = (scope.reverse) ? 'down' : 'up';
    scope.dataset = service.customSort(scope);
  };

  service.customSort = function (scope) {
    var result = [];
    if (scope.reverse) {
      result = scope.dataset.sort(function (a, b) {
        var x = a[scope.orderBy].toString().toLowerCase(),
            y = b[scope.orderBy].toString().toLowerCase();
        return x > y ? -1 : x < y ? 1 : 0;
      });
      return result;
    }
    else {
      result = scope.dataset.sort(function (a, b) {
        var x = a[scope.orderBy].toString().toLowerCase(),
            y = b[scope.orderBy].toString().toLowerCase();
        return x > y ? 1 : x < y ? -1 : 0;
      });
      return result;
    }
  };
}]);



app.factory('prefetchInfoService', prefetchInfoService);

prefetchInfoService.$inject = ['$q', 'api'];

function prefetchInfoService($q, api) {

  var streamname;
  var lastDevice = {
    deviceid: null,
    appversion: null
  };

  return {
    isPrefetch: isPrefetch,
    prefetchTooltip: prefetchTooltip
  };

  // Public methods

  function isPrefetch(me, stream) {
    // A location is prefetch if the account and user are both configured for prefetch,
    // and the device is a CloudBox with 6.x or higher apk.
    if (me.account.use_prefetch && me.user.isPrefetch && stream) {
      if ('cloudbox' === stream.devicetype) {
        // Get device info to check version
        if (stream.deviceid !== lastDevice.deviceid) {
          lastDevice.deviceid = stream.deviceid;
          lastDevice.appversion = null;
          api.getCloudBoxDetails(stream.deviceid).then(function(cbox) {
            if (cbox.appversion[0] >= '6') {
              streamname = stream.streamname;
              lastDevice.appversion = cbox.appversion;
              return true;
            }
            else {
              return false;
            }
          }, function(err) {
            console.error('Could not get cloudbox details: ', err);
            return false;
          });
        }
        else {
          // Still looking at the same device, don't need to hit the api again to get appversion.
          // Of course it might be null if we're waiting for the details to arrive, let it be false in that case.
          return lastDevice.appversion && lastDevice.appversion[0] >= '6';
        }
      }
      return false;
    }
    return false;
  }

  function prefetchTooltip() {
    return 'The ' + streamname + ' device will get the change at the next media download window';
  }

}

app.factory('refreshCloudBoxModal', ['$modal', function($modal) {
  return function(options, confirmationCallback, dismissCallback) {
    var modalConfig = {
      templateUrl: 'partials/refresh_cloudbox_modal.html',
      streamname: options.streamname,
      username: options.username
    };

    modalConfig.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.streamname = modalConfig.streamname;
      $scope.username = modalConfig.username;

      $scope.refresh = function () {
        $modalInstance.close('resume');
      }

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      }
    }];

    return $modal.open(modalConfig).result;
  }
}]);

app.factory('refresher', ['$timeout', function($timeout) {
  var timer = null;

  function refresh(updateFn, options) {
    updateFn();
    if (timer !== null) {
      $timeout.cancel(timer);
    }
    if (options.counter >= 0) {
      options.counter--;
      timer = $timeout(refresh.bind(null, updateFn, options), options.interval, false);
    }
  }

  function cancelTimer() {
    if (timer) {
      $timeout.cancel(timer);
      timer = null;
    }
  }

  return {
    refresh: refresh,
    cancelTimer: cancelTimer
  };
}]);

app.factory('removeSongModal', ['$modal', function($modal) {
  return function(options, confirmationCallback, dismissCallback) {
    var modalConfig = {
      templateUrl: 'partials/remove_song_modal.html',
      name: options.name,
      artist: options.artist,
      canSetGlobal: options.canSetGlobal,
      shouldSkip: true
    };

    modalConfig.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.name = modalConfig.name;
      $scope.artist = modalConfig.artist;
      $scope.canSetGlobal = modalConfig.canSetGlobal;
      $scope.isGlobal = false;
      $scope.shouldSkip = modalConfig.shouldSkip;

      $scope.remove = function (shouldSkip) {
        $modalInstance.close({ shouldSkip: $scope.shouldSkip, isGlobal: $scope.isGlobal });
      }

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      }
    }];

    return $modal.open(modalConfig).result;
  }
}]);

(function (angular, app) {
  app.factory('reportingService', reportingService);

  reportingService.$inject = ['api'];

  function reportingService(api) {

    return {

      // Methods
      disableRecurringReport: disableRecurringReport,
      enableRecurringReport: enableRecurringReport,
      generateLocationsAddedReport: generateLocationsAddedReport,
      generateMessageReport: generateMessageReport,
      generateStreamingReport: generateStreamingReport,
      generateStreamStatusReport: generateStreamStatusReport,
      generateCurrentActivityReport: generateCurrentActivityReport,
      getRecurringReports: getRecurringReports
    };

    function disableRecurringReport(userId, reportId, frequency, recipients) {
      return api.updateRecurringReport(userId, reportId, frequency, false, recipients);
    }

    function enableRecurringReport(userId, reportId, frequency, recipients) {
      return api.updateRecurringReport(userId, reportId, frequency, true, recipients);
    }

    function generateLocationsAddedReport(options) {
      return api.createLocationsAddedReport(options);
    }

    function generateMessageReport(options) {
      return api.createMessageReport(options);
    }

    function generateStreamingReport(options) {
      return api.createStreamingReport(options);
    }

    function generateStreamStatusReport(options) {
      return api.createStreamStatusReport(options);
    }

    function generateCurrentActivityReport(options) {
      return api.createCurrentActivityReport(options);
    }

    function getRecurringReports(userId) {
      return api.getRecurringReports(userId);
    }
  }

})(window.angular, app);

app.factory('scheduleHandler', ['api', '$timeout', '$rootScope', 'messageSelection', 'musicSelection', 'streamUpdateService', function(api, $timeout, $rootScope, messageSelection, musicSelection, streamUpdateService) {
  var messageTimer, processTimer = null;

  function getMessageScheduleEvents(callback) {
    var startDate = moment().format('YYYY-MM-DD');
    var endDate = moment().add(1, 'days').format('YYYY-MM-DD');
    api.getUserMessageScheduleEvents(startDate, endDate, function(details) {
      var schedule = details.schedule.filter(function(item) {
        return new Date(item.play_at) > new Date();
      }).sort(function (a,b) {
        return new Date(a.play_at) - new Date(b.play_at);
      });
      return callback(schedule);
    }, function(err) {
      console.error("Error fetching schedule details %s", err.message ? ': ' + err.message : '');
    });
  }

  function processSqsMessage(message, streamid, userid, scheduleid, scope, callback) {
    if (message.type === 'schedule-set' && message.streams && message.streams.indexOf(streamid) > -1) {
      if (message.scheduleid) {
        messageSelection.setSelection({
          messageSchedule: message.scheduleid
        });
        streamUpdateService.setStreamsUpdateFlag();
      }
      return callback(message.scheduleid);
    }
    else if (message.type === 'schedule-changed' && message.scheduleid === scheduleid) {
      streamUpdateService.setStreamsUpdateFlag();
      return callback(message.scheduleid);
    }
    else if (message.type === 'schedule-cleared' && message.streams && message.streams.indexOf(streamid) > -1) {
      messageSelection.clearSchedule();
      streamUpdateService.setStreamsUpdateFlag();
      return callback(null);
    }
    else {
      return callback(false);
    }
  }

  function clearMessageSchedule() {
    if (messageTimer !== null) {
      $timeout.cancel(messageTimer);
      messageTimer = null;
    }
  }

  function playMessageSchedule(schedule, pushMedia) {
    var nextMessage = null;
    var interval;
    var now = moment();
    for (var i = 0; i < schedule.length; i++) {
      if (moment(schedule[i].play_at).isAfter(now)) {
        nextMessage = schedule[i];
        interval = moment(nextMessage.play_at).diff(now);
        break;
      }
    }
    if (nextMessage) {
      if (messageTimer !== null) {
        $timeout.cancel(messageTimer);
      }
      messageTimer = $timeout(function() {
        pushMedia({
          id: null,
          mediaid: nextMessage.mediaid,
          name: nextMessage.name,
          description: 'scheduled message',
          mediaType: 'message',
          mediaUrl: nextMessage.message_uri
        });
        schedule.shift();
        playMessageSchedule(schedule, pushMedia);
      }, interval);
    }
  }

  function processMessageSchedule(pushMedia) {
    if (processTimer !== null) {
      $timeout.cancel(processTimer);
    }
    getMessageScheduleEvents(function(schedule) {
      if (schedule.length === 0) {
        clearMessageSchedule();
      } else if (schedule.length > 0) {
        playMessageSchedule(schedule, pushMedia);
      }

      // reprocess message schedule every 6 hours if nothing received
      processTimer = $timeout(processMessageSchedule.bind(null, pushMedia), 21600000);
    });
  }

  return {
    getMessageScheduleEvents: getMessageScheduleEvents,
    processSqsMessage: processSqsMessage,
    playMessageSchedule: playMessageSchedule,
    processMessageSchedule: processMessageSchedule
  };
}]);

app.service("selfServeAPIKeyModal", ["$modal", "api", function($modal, api) {
  var modalOptions = {};
  var modalModel = {};

  var modalDefaults = {
    templateUrl: "partials/selfServeAPIKeyModal.html",
    backdrop: true,
    keyboard: true,
    modalFade: true,
    windowClass: "device-api-key-modal"
  };

  var modalOptions = {
    modalDialog: true,
    actionButtonText: "Close",
    headerText: "Account API Key",
  };

  var apiKey = '';

  this.show = function(accountId) {
    modalDefaults.controller = ['$scope', '$modalInstance', function($scope, $modalInstance) {
      api.getSelfServeAPIKey(function(result){
        modalModel.apikey = result.apikey;
      }, function(error) {
        // no-op
      });

      $scope.modalModel = modalModel;
      $scope.modalOptions = modalOptions;

      function showModal() {

        $scope.ok = function() {
          $modalInstance.close({apikey: modalModel.apikey});
          $scope.apikey = '';
        };

        $scope.copySuccess = function(evt) {
          $scope.statusMessage = "Successfully copied to clipboard";
        }

        $scope.copyError = function(evt) {
          $scope.statusMessage = "Could not copy to clipboard. Click Edit in your browser's menu, and select Copy.";
        }

        $scope.cancel = function() {
          $scope.apikey = '';
          $modalInstance.dismiss("cancel");
        };

        $scope.handleEnterKey = function(ev) {
          if (ev.keyCode == 13) {
            $scope.ok();
          }
        };

        $scope.regenerate = function() {
          api.createSelfServeAPIKey(function(result) {
            $scope.modalModel.apikey = modalModel.apikey = $scope.apikey = result.apikey;
            $scope.statusMessage = "Successfully regenerated key";
          }, function(error) {
            console.log(error);
            $scope.statusMessage = "Could not regenerate key";
          });
        }
      }

      if (modalModel.apikey && modalModel.apikey.length > 0) {
        $scope.apikey = modalModel.apikey;
        showModal();
      }
      else {
        api.createSelfServeAPIKey(function(result) {
          modalModel.apikey = $scope.apikey = result.apikey;
          showModal();
        }, function(error) {
          console.log(error);
        });
      }

    }];

    return $modal.open(modalDefaults).result;
  };
}]);

app.service("selfServeStreamModal", ["$modal", "api", "userInfo", function($modal, api, userInfo) {
  var modalOptions = {};
  var modalModel = {};

  var modalDefaults = {
    templateUrl: "partials/selfServeStreamModal.html",
    backdrop: true,
    keyboard: true,
    modalFade: true,
    windowClass: "device-stream-modal"
  };

  var resetModel = function() {
    modalModel = {};
  };

  var defaultModalOptions = {
    modalDialog: true,
    actionButtonText: "Save",
    cancelButtonText: "Cancel",
    headerText: "Update Device Settings",
    action: "save"
  };

  this.setOptions = function(customModalOptions) {
    for (var key in customModalOptions) {
      if (customModalOptions.hasOwnProperty(key)) {
        modalOptions[key] = customModalOptions[key];
      }
    }
  };

  this.setModel = function(customModalModel) {
    modalModel = customModalModel;
  };

  this.getOptions = function() {
    return modalOptions;
  };

  this.show = function() {
    var tempModalOptions = {};
    var tempModalDefaults = {};

    angular.extend(tempModalOptions, defaultModalOptions, modalOptions);
    tempModalDefaults = modalDefaults;

    tempModalDefaults.controller = ['$scope', '$modalInstance', function($scope, $modalInstance) {
      $scope.modalOptions = tempModalOptions;
      $scope.modalModel = modalModel;
      $scope.buttonEnabled = false;
      $scope.warningMessage = '';
      var streamsByIndex = {};

      var grabStreamsForUser = function(callback) {
        streamsByIndex = {};

        api.getStreamsForUser(modalModel.userid, function(result) {
          $scope.streamOptions = result.streams.reduce(function(memo, stream) {
            memo.push(stream);
            streamsByIndex[stream.streamid] = stream;
            if (callback) {
              callback(stream);
            }
            return memo;
          }, []);

          $scope.enableLocationOptions = true;
        }, function(error) {
          showError("Unable to retrieve Zones list.  Make sure you have created at least 1 Zone.");
          console.log(error);
          resetModel();
          $modalInstance.dismiss("cancel");
        });
      }

      api.getLocsWithStreamCounts(api.userObject.user.custid).then(function(locationData) {
        var locations = locationData.locations;
        $scope.locationName = "Select a Location";
        $scope.streamName = "Select a Zone";

        $scope.selectLocation = function() {
          $scope.warningMessage = '';
          $scope.locationName = loc.username;
          $scope.streamName = "Select a Zone";
          $scope.modalModel.streamid = null;
          $scope.buttonEnabled = false;
          grabStreamsForUser();
        }

        $scope.selectZone = function() {
          var stream = streamsByIndex[$scope.modalModel.streamid];
          console.log(stream);
          if (stream && stream.deviceid) {
            $scope.warningMessage = "The <b>selected Zone</b> is already assigned to another device. Assigning this Zone will remove the previously selected device from that Zone.";
          } else {
            $scope.warningMessage = '';
          }
        }

        $scope.locationOptions = locations.reduce(function(memo, loc) {
          var hasUnlicensedOwner = api.userObject.account.unlicensed_account_owner ? true : false;
          if (loc.userid == modalModel.userid) {
            $scope.locationName = loc.username;
            grabStreamsForUser(function(stream){
              if (stream.deviceid == modalOptions.deviceid) {
                $scope.streamName = stream.streamname;
                $scope.modalModel.streamid = stream.streamid;
                $scope.buttonEnabled = true;
              }
            });
          }
          if (
            !hasUnlicensedOwner ||
            (hasUnlicensedOwner && !loc.isAdmin)
          ) {
            loc.name = loc.username + " - " + loc.street + ", " + loc.state;
            memo.push(loc);
          }
          return memo;
        }, []);

        $scope.ok = function() {
          if (!$scope.modalModel.userid || !$scope.modalModel.streamid) {
            $scope.buttonEnabled = false;
            return -1;
          }

          var data = {
            uuid: $scope.modalOptions.uuid,
            name: $scope.modalOptions.name,
            custid: api.userObject.user.custid,
            userid: $scope.modalModel.userid,
            streamid: $scope.modalModel.streamid
          };

          api.assignSelfServeDevice(data, function(result) {
            resetModel();
            $modalInstance.close(result);
          }, function(err) {
            resetModel();
            $modalInstance.close(err);
            console.error("error adding stream for user: ", err.data);
          });
        };

        $scope.cancel = function() {
          resetModel();
          $modalInstance.dismiss("cancel");
        };

        $scope.handleEnterKey = function(ev) {
          if (ev.keyCode == 13 && $scope.buttonEnabled === true && $scope.modalModel.userid && $scope.modalModel.streamid) {
            $scope.ok();
          }
        };

        $scope.checkButton = function() {
          if (
            $scope.modalModel.userid &&
            $scope.modalModel.streamid
          ) {
            $scope.buttonEnabled = true;
          } else {
            $scope.buttonEnabled = false;
          }
        };
        $scope.checkButton();
      });
    }];

    return $modal.open(tempModalDefaults).result;
  };
}]);

app.factory('signUpData', function() {
  return {
    businessTypes: [
      'Education / University',
      'Entertainment Kids',
      'Entertainment Movie / Theater / Gallery',
      'Entertainment Other',
      'Entertainment Sports',
      'Government',
      'Gym / Health Club',
      'Hotel / Casino / Resort',
      'Manufacturing / Warehouse',
      'Office Dental',
      'Office Finance / Insurance',
      'Office Medical / Health Care Facilities',
      'Office Professional / Other',
      'Office Vet / Grooming / Shelter',
      'Property Development',
      'Property Management - Commercial ',
      'Property Management - Residential',
      'Religious Organization',
      'Reseller (VAR)',
      'Restaurant Bakery / Sweets & Treats',
      'Restaurant Bar / Brewery / Lounge',
      'Restaurant Coffee Shop / Cafe',
      'Restaurant Family / Fast Casual',
      'Restaurant Fast Food / QSR',
      'Restaurant Fine Dining',
      'Restaurant Juice Bar / Smoothies / Bowls',
      'Restaurant Other',
      'Restaurant Winery',
      'Retail Arts & Crafts',
      'Retail Automotive Dealership / Service / Wash',
      'Retail Beauty',
      'Retail Beer / Wine / Liquor',
      'Retail Consumer Electronics',
      'Retail Convenience Store / Gas Station',
      'Retail Department Store',
      'Retail Discount Store',
      'Retail Drugstore',
      'Retail Fashion',
      'Retail Furniture',
      'Retail Grocery',
      'Retail Hardware / Home Improvement',
      'Retail Motorcycle Dealership',
      'Retail Other',
      'Retail Outdoor / Sports',
      'Retail Pet',
      'Retail Shipping / Storage',
      'Retail Warehouse / Wholesale Club',
      'Retail Wireless',
      'Salon Hair / Nail / Tanning / Waxing',
      'Spa'
    ],

    businessModel: [
      'Single Store',
      'Franchise'
    ],

    previousService: [
      'No music at location',
      'Mood Media/Muzak',
      'Pandora',
      'PlayNetwork',
      'Sirius XM',
      'Spotify',
      'Other streaming provider',
      'Playing our own',
    ],

    customerProfiles: [
      'Under 18 Male',
      'Under 18 Female',
      'Under 18 Mixed',
      '18-24 Male',
      '18-24 Female',
      '18-24 Mixed',
      '25-34 Male',
      '25-34 Female',
      '25-34 Mixed',
      '35-54 Male',
      '35-54 Female',
      '35-54 Mixed',
      '55+ Male',
      '55+ Female',
      '55+ Mixed',
      'Families Young',
      'Families Teen',
      'Families All Ages'
    ],

  };
});

/*
 * stationInfoPopup displays details about a station and allows the user to listen to a sample.
 */
app.service('stationInfoPopup', ['api', '$modal', '$sce', function (api, $modal, $sce) {
  var service = this;
  var modalOptions = {};
  var modalModel = {};
  var stations = {};
  service.display = false;
  service.updateLocation = false;
  service.queue = false;
  service.playing = false;
  service.setLocation = setLocation;
  service.getLocation = getLocation;
  service.setStationList = setStationList;
  service.show = show;

  var modalOptions = {
    modalDialog: true,
    templateUrl: 'partials/station_info_popup.html',
    samplesUrl: 'https://media.cloudcovermusic.com/sample-music/',
    backdrop: 'true',
    keyboard: true,
    modalFade: true,
    windowClass: 'station-info-popup',
    x: 0,
    y: 100,
  };

  function getStationInfo(id) {
    return stations[id];
  }

  function setStationList(stationList) {
    var thumbUrl = '';

    for(var i=0; i<stationList.length; i++) {
      stations[stationList[i].musicid] = stationList[i];
      thumbUrl = stationList[i].thumb_url.substring(0, stationList[i].thumb_url.lastIndexOf(".") + 1) + 'mp3';
      stations[stationList[i].musicid]['sampleFile'] = modalOptions.samplesUrl+thumbUrl;
    }
  }

  function setLocation(point) {
    modalOptions.x = point.x;
    modalOptions.y = point.y;
  }

  function getLocation () {
    return { x: modalOptions.x, y: modalOptions.y };
  }

  function show (event,id) {
    modalOptions.x = event.clientX;
    modalOptions.y = event.clientY;
    service.display = true;

    modalOptions.controller = ['$scope', '$modalInstance', function($scope, $modalInstance) {
      $scope.stationInfo = getStationInfo(id);
      $scope.description = $sce.trustAsHtml($scope.stationInfo.description);
      $scope.options = modalOptions;

      if (BrowserDetect.mobile) {
        $scope.isMobile = true;
      }

      $scope.cancel = function() {
        if ($scope.playing) $scope.stop();
        $('body').unbind('keyup', escapeClose);
        $modalInstance.close();
      }

      var escapeClose = function(e) {
        if (e.which == 27) {
          $scope.close();
          $('body').unbind('keyup', escapeClose);
        }
      }

      $scope.play = function(event, song) {
        service.queue = {
          id: song.playlistid,
          name: song.name,
          description: 'song preview',
          mediaType: 'song',
          mediaUrl: song.sampleFile,
          overrideDuration: true
        };
        $scope.playing = true;
        service.playing = true;
      }

      $scope.stop = function() {
        service.queue = {};
        service.playing = false;
        $scope.playing = false;
      }

      $scope.$on('resumeMedia', function() {
        $scope.playing = false;
      })

      $('body').bind('keyup', escapeClose);
    }];

    return $modal.open(modalOptions).result.then(function() {
      console.log('Modal close');
    }, function(action) {
      if (service.playing) {
        service.queue = {};
        service.playing = false;
      }
    });
  }

}]);

app.service('streamHistoryModal', ['$modal', function ($modal) {
  var service = this;

  var modalDefaults = {
    backdrop: true,
    keyboard: true,
    modalFade: true,
    templateUrl: 'partials/stream_history_modal.html',
    windowClass: 'stream-history-modal',
  };

  var modalOptions = {
    modalDialog: true,
    headerText: 'Most Recently Streamed Songs',
  };

  service.show = function (locationStream) {
    if (service.open) {
      service.close();
    }

    modalDefaults.controller = ['$scope', '$modalInstance', function ($scope, $modalInstance) {
      $scope.modalOptions = modalOptions;
      $scope.streamHistory = locationStream.songs;
      service.modalInstance = $modalInstance;

      $scope.cancel = function (result) {
        service.close();
      };

      service.open = true;
    }];

    return $modal.open(modalDefaults).result;
  };

  service.close = function () {
    service.modalInstance.dismiss('cancel');
    service.open = false;
  };

}]);

app.factory('streamHistoryService', streamHistoryService);

streamHistoryService.$inject = [];

function streamHistoryService() {

  return {

  };

}

app.service("streamModal", ["$modal", "api", "userInfo", function($modal, api, userInfo) {
  var modalOptions = {};
  var modalModel = {};

  var modalDefaults = {
    backdrop: true,
    keyboard: true,
    modalFade: true,
    windowClass: "stream-modal"
  };

  var resetModel = function() {
    modalModel = {};
  };

  var defaultModalOptions = {
    modalDialog: true,
    templateUrl: "partials/stream_modal.html",
    actionButtonText: "Save",
    cancelButtonText: "Cancel",
    headerText: "Add a Zone",
    action: "add"
  };

  this.setOptions = function(customModalOptions) {
    for (var key in customModalOptions) {
      if (customModalOptions.hasOwnProperty(key)) {
        modalOptions[key] = customModalOptions[key];
      }
    }
  };

  this.setModel = function(customModalModel) {
    modalModel = customModalModel;
  };

  this.getOptions = function() {
    return modalOptions;
  };

  this.show = function() {
    var tempModalOptions = {};
    var tempModalDefaults = {};

    angular.extend(tempModalOptions, defaultModalOptions, modalOptions);
    tempModalDefaults = modalDefaults;
    if (tempModalOptions.templateUrl && tempModalOptions.templateUrl.length > 0) {
      tempModalDefaults.templateUrl = tempModalOptions.templateUrl;
    }

    tempModalDefaults.controller = ['$scope', '$modalInstance', function($scope, $modalInstance) {
      $scope.modalOptions = tempModalOptions;
      $scope.modalModel = modalModel;
      $scope.buttonEnabled = false;
      $scope.streamPrice = 12.95;
      if (api.userObject.subscription.vendor_code.match('annual')) {
        $scope.billFrequency = {
          frequency: 'yearly',
          abbrev: 'yr'
        };
      } else {
        $scope.billFrequency = {
          frequency: 'monthly',
          abbrev: 'mo'
        };
      }

      if (api.userObject.subscription.addon_stream_amount_in_cents) {
        $scope.streamPrice = (api.userObject.subscription.addon_stream_amount_in_cents / 100);
      }
      userInfo.checkPaymentPermission(function(result) {
        $scope.hasPaymentPermission = result;
      });

      api.getLocsWithStreamCounts(api.userObject.user.custid).then(function(locationData) {
        var locations = locationData.locations;
        $scope.locationOptions = locations.reduce(function(memo, loc) {
          var hasUnlicensedOwner = api.userObject.account.unlicensed_account_owner ? true : false;
          if (
            !hasUnlicensedOwner ||
            (hasUnlicensedOwner && !loc.isAdmin)
          ) {
            loc.name = loc.username + " - " + loc.street + ", " + loc.state;
            memo.push(loc);
          }
          return memo;
        }, []);

        $scope.ok = function() {
          var data = {
            custid: api.userObject.user.custid,
            userid: $scope.modalModel.userid,
            streamname: $scope.modalModel.streamname
          };
          api.addStreamToUser(data).then(function(result) {
            resetModel();
            result.streamname = $scope.modalModel.streamname;
            $modalInstance.close(result);
          }, function(err) {
            resetModel();
            $modalInstance.close(err);
            console.error("error adding stream for user: ", err.data);
          });
        };

        $scope.cancel = function() {
          resetModel();
          $modalInstance.dismiss("cancel");
        };

        $scope.handleEnterKey = function(ev) {
          if (ev.keyCode == 13 && $scope.buttonEnabled === true) {
            $scope.ok();
          }
        };

        $scope.checkButton = function() {
          if (
            $scope.modalModel.userid &&
            $scope.modalModel.streamname &&
            $scope.modalModel.streamname.length
          ) {
            if (!$scope.modalModel.termsAgreement) {
              $scope.buttonEnabled = false;
            } else {
              $scope.buttonEnabled = true;
            }
          } else {
            $scope.buttonEnabled = false;
          }
        };
        $scope.checkButton();
      });
    }];

    return $modal.open(tempModalDefaults).result;
  };
}]);

app.factory('streamUpdateService', ['api', function(api) {
  var streamsUpdateFlag = false;
  var selectedStream = null;
  var listeners = [];

  // 1/30/2018 RK: we need this function to compare currentStreams with refreshed streams because the currentStreams array
  // gets additional data mapped to it after processing which we don't want to compare with refreshed data
  function compareStreams(arr1, arr2) {
    var currentStreams, fetchedStreams;
    var isEqual = true;
    var keys = [];
    currentStreams = Object.keys(arr1[0]).length > Object.keys(arr2[0]).length ? arr1 : arr2;
    fetchedStreams = Object.keys(arr1[0]).length > Object.keys(arr2[0]).length ? arr2 : arr1;
    if (currentStreams.length !== fetchedStreams.length) {
      isEqual = false;
      return isEqual;
    }
    currentStreams.sort(function(a, b) {
      return a.streamid - b.streamid;
    });
    fetchedStreams.sort(function(a, b) {
      return a.streamid - b.streamid;
    });
    keys = Object.keys(fetchedStreams[0]);
    for (var i = 0; i < fetchedStreams.length; i++) {
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        if (
          fetchedStreams[i].streamid !== currentStreams[i].streamid ||
          fetchedStreams[i][key] !== currentStreams[i][key]
        ) {
          isEqual = false;
          return isEqual;
        }
      }
    }
    return isEqual;
  }

  function setSelectedStream(stream) {
    selectedStream = stream;
    if (stream !== null) {
      api.userObject.streamid = stream.streamid;
    }
    listeners.forEach(function (listener) {
      listener.onSetSelectedStream(stream);
    });
  }

  function getSelectedStream() {
    return selectedStream;
  }

  function setStreamsUpdateFlag() {
    streamsUpdateFlag = true;
  }

  function clearStreamsUpdateFlag() {
    streamsUpdateFlag = false;
  }

  function checkStreamsUpdateFlag() {
    return streamsUpdateFlag;
  }

  function addListener(listener) {
    if(typeof listener.onSetSelectedStream === 'function') {
      listeners.push(listener);
    }
  }

  return {
    compareStreams: compareStreams,
    setStreamsUpdateFlag: setStreamsUpdateFlag,
    checkStreamsUpdateFlag: checkStreamsUpdateFlag,
    clearStreamsUpdateFlag: clearStreamsUpdateFlag,
    setSelectedStream: setSelectedStream,
    getSelectedStream: getSelectedStream,
    addListener: addListener
  };
}]);

app.factory('subscriptionInfo', ['$q', 'api', '$rootScope', function($q, api, $rootScope) {
  var discountOption = false;
  var paymentStatus = {
    hasPayment: false
  };
  var subscriptionStatus = {
    isEnterprise: false
  };

  return {

    // Methods
    getPaymentStatus: getPaymentStatus,
    setPaymentStatus: setPaymentStatus,
    getTrialStatus: getTrialStatus,
    inTrial: inTrial,
    getEnterpriseStatus: getEnterpriseStatus,
    setEnterpriseStatus: setEnterpriseStatus,
    getPlanOfferings: getPlanOfferings,
    getPlansObject: getPlansObject,
    setDiscountOption: setDiscountOption,
    checkDiscountOption: checkDiscountOption,
    clearDiscountOption: clearDiscountOption,
    messageQuantityAllowedPerPreset: messageQuantityAllowedPerPreset,
    calculateAddonStreams: calculateAddonStreams,
    zonesAllowed: zonesAllowed,
    refreshSubscription: refreshSubscription,
    upgradeSubscription: upgradeSubscription,
    isPaused: isPaused,
    isPlanAnnual: isPlanAnnual
  };

  function setDiscountOption() {
    discountOption = true;
  }

  function checkDiscountOption() {
    return discountOption;
  }

  function clearDiscountOption() {
    discountOption = false;
  }

  function getPaymentStatus() {
    return paymentStatus;
  }

  function setPaymentStatus(value) {
    paymentStatus.hasPayment = value;
  }

  function getTrialStatus() {
    var trialExpired;
    var cdat = new Date();
    var expirationDate = Date.parse(api.userObject.subscription.trial_ends_at);
    var currentDate = cdat.getTime();
    if (currentDate > expirationDate) {
      trialExpired = true;
    } else {
      trialExpired = false;
    }
    return trialExpired;
  }

  function inTrial() {
    if (api.userObject.subscription.state === 'trial') {
      return true;
    } else {
      return false;
    }
  }

  function getEnterpriseStatus() {
    if (
      api.userObject.subscription.admins === 1 &&
      api.userObject.subscription.groups === 1 &&
      api.userObject.subscription.dayparting === 1 &&
      api.userObject.subscription.alerts === 1 &&
      api.userObject.subscription.reports === 1 &&
      api.userObject.subscription.remote === 1
    ) {
      subscriptionStatus.isEnterprise = true;
    } else {
      subscriptionStatus.isEnterprise = false;
    }
    return subscriptionStatus;
  }

  function setEnterpriseStatus(value) {
    subscriptionStatus.isEnterprise = value;
  }

  function messageQuantityAllowedPerPreset() {
    return api.userObject.subscription.messages > 0;
  }

  function getPlansObject(plans) {
    var results = {};
    for (var i = 0; i < plans.length; i++) {
      results[plans[i].vendor_code] = plans[i];
    }

    return results;
  }

  function getPlanOfferings(plans, annualBilling) {
    var results = {};
    if (annualBilling) {
      results.music = {
        name: plans.annual_standard_10disc.name,
        dollar: Math.floor((parseInt(plans.annual_standard_10disc.amount_in_cents) / 12) / 100),
        change: Math.ceil((parseInt(plans.annual_standard_10disc.amount_in_cents) / 12) % 100),
        annualPrice: Math.floor(parseInt(plans.annual_standard_10disc.amount_in_cents) / 100)+'.'+(parseInt(plans.annual_standard_10disc.amount_in_cents) % 100),
        vendor_code: 'annual_standard_10disc',
        isDiscount: true,
        isEnterprise: false,
        addonStreamPrice: plans.annual_standard_10disc.addon_stream_amount_in_cents / 100
      };
      results.manage = {
        name: plans.annual_estandard_10disc.name,
        dollar: Math.floor((parseInt(plans.annual_estandard_10disc.amount_in_cents) / 12) / 100),
        change: Math.ceil((parseInt(plans.annual_estandard_10disc.amount_in_cents) / 12) % 100),
        annualPrice: Math.floor(parseInt(plans.annual_estandard_10disc.amount_in_cents) / 100)+'.'+(parseInt(plans.annual_estandard_10disc.amount_in_cents) % 100),
        vendor_code: 'annual_estandard_10disc',
        isDiscount: true,
        isEnterprise: true,
        addonStreamPrice: plans.annual_estandard_10disc.addon_stream_amount_in_cents / 100
      };
      results.messaging = {
        name: plans.annual_eprofessional_10disc.name,
        dollar: Math.floor((parseInt(plans.annual_eprofessional_10disc.amount_in_cents) / 12) / 100),
        change: Math.ceil((parseInt(plans.annual_eprofessional_10disc.amount_in_cents) / 12) % 100),
        annualPrice: Math.floor(parseInt(plans.annual_eprofessional_10disc.amount_in_cents) / 100)+'.'+(parseInt(plans.annual_eprofessional_10disc.amount_in_cents) % 100),
        vendor_code: 'annual_eprofessional_10disc',
        isDiscount: true,
        isEnterprise: true,
        addonStreamPrice: plans.annual_eprofessional_10disc.addon_stream_amount_in_cents / 100
      };
    } else {
      results.music = {
        name: plans.standard.name,
        dollar: Math.floor(parseInt(plans.standard.amount_in_cents) / 100),
        change: Math.floor(parseInt(plans.standard.amount_in_cents) % 100),
        annualPrice: '',
        vendor_code: 'standard',
        isDiscount: false,
        isEnterprise: false,
        addonStreamPrice: plans.standard.addon_stream_amount_in_cents / 100
      };
      results.manage = {
        name: plans.enterprise_standard.name,
        dollar: Math.floor(parseInt(plans.enterprise_standard.amount_in_cents) / 100),
        change: Math.floor(parseInt(plans.enterprise_standard.amount_in_cents) % 100),
        annualPrice: '',
        vendor_code: 'enterprise_standard',
        isDiscount: false,
        isEnterprise: true,
        addonStreamPrice: plans.enterprise_standard.addon_stream_amount_in_cents / 100
      };
      results.messaging = {
        name: plans.enterprise_professional.name,
        dollar: Math.floor(parseInt(plans.enterprise_professional.amount_in_cents) / 100),
        change: Math.floor(parseInt(plans.enterprise_professional.amount_in_cents) % 100),
        annualPrice: '',
        vendor_code: 'enterprise_professional',
        isDiscount: false,
        isEnterprise: true,
        addonStreamPrice: plans.enterprise_professional.addon_stream_amount_in_cents / 100
      };
    }

    return results;
  }

  function refreshSubscription(callback) {
    var callCallback = function callCallback(subscription, skipBillingUpdate) {
      $rootScope.$broadcast('subscriptionRefreshed', {
        subscription: subscription,
        skipBillingUpdate: skipBillingUpdate
      });

      callback(subscription, skipBillingUpdate);
    };

    api.getMe(1)
      .then(function () {
        return api.getSubscription();
      })
      .then(function (subscription) {
        if (api.userObject.account.recurly) {
          api.getPayment()
            .then(function (payment) {
              var skipBillingUpdate = false;
              if (payment !== 'No Billing Information Found') {
                if (payment.city) {
                  subscription.paymentInfo = payment;
                  skipBillingUpdate = true;
                }

                calculateAddonStreams(subscription)
                  .then(function (addonStreams) {
                    subscription.addonStreams = addonStreams;

                    if (subscription.state === 'expired') {
                      api.getBalance(api.userObject.custid)
                        .then(function (balance) {
                          subscription.balance = balance;
                          callCallback(subscription, skipBillingUpdate);
                        });
                    } else {
                      callCallback(subscription, skipBillingUpdate);
                    }
                  });
              } else {
                callCallback(subscription, skipBillingUpdate);
              }
            });
        } else {
          callCallback(subscription, false);
        }
      });
  }

  function upgradeSubscription(planData, callback) {
    api.upgradeSubscription(planData, function() {
      /**
       * The next 2 lines don't make any sense.  getEnterpriseStatus() actually sets
       * the isEnterprise bool in subscriptionInfo, so it makes no sense to then set
       * the value on the next line.  Furthermore, since getEnterpriseStatus actually
       * sets the value, then it doesn't make sense to call it getEnterpriseStatus.
       * Was commited in 1323ed73b May 2017
       *        -FMadden
       */
      //var isEnterprise = subscriptionInfo.getEnterpriseStatus().isEnterprise;
      //subscriptionInfo.setEnterpriseStatus(isEnterprise);

      // above 2 lines replaced with the following -FMadden
      getEnterpriseStatus();

      refreshSubscription(callback);
    }, function (err) {
      callback({err: err});
    });
  }

  function calculateAddonStreams(subscription) {
    var defer = $q.defer();
    var addonStreams = null;
    if (!api.userObject.recurly.account_code || subscription.state === 'trial') {
      api.getAccountStreamCounts(api.userObject.account.custid).then(function (accountStreamCounts) {
        if (accountStreamCounts[0]) {
          var streamingUsersCount = accountStreamCounts[0].streamingUsers;
          var addonStreamCount = accountStreamCounts[0].streamCount - streamingUsersCount;
          if (addonStreamCount > 0) {
            addonStreams = {
              quantity: {_: addonStreamCount},
              unit_amount_in_cents: {_: subscription.addon_stream_amount_in_cents}
            };
          }
        }
        defer.resolve(addonStreams);
      });
    } else if (api.userObject.recurly.subscription_add_ons && api.userObject.recurly.subscription_add_ons.subscription_add_on) {
      var addons = api.userObject.recurly.subscription_add_ons.subscription_add_on;
      if (Array.isArray(addons)) {
        // 2017-11-30 RK: If user has more than 1 add-on, addons from Recurly will be an array otherwise it will be an object
        for (var i = 0; i < addons.length; i++) {
          if (addons[i].add_on_code === 'stream') {
            addonStreams = addons[i];
            break;
          }
        }
      } else if (addons.add_on_code === 'stream') {
        addonStreams = addons;
      }
      defer.resolve(addonStreams);
    } else {
      defer.resolve(addonStreams);
    }
    return defer.promise;
  }

  function zonesAllowed() {
    if (
      api.userObject.subscription.vendor_code === 'enterprise_standard'     ||
      api.userObject.subscription.vendor_code === 'annual_estandard_10disc' ||
      api.userObject.subscription.vendor_code === 'enterprise_professional' ||
      api.userObject.subscription.vendor_code === 'annual_eprofessional_10disc'
    ) {
      return true;
    } else {
      return false;
    }
  }

  function isPaused() {
    var pauseStartsAt = api.userObject.subscription.pause_starts_at;
    var pauseEndsAt = api.userObject.subscription.pause_ends_at;

    if (!pauseStartsAt || !pauseEndsAt) {
      return false;
    }

    var now = new Date();
    pauseStartsAt = new Date(pauseStartsAt);
    pauseEndsAt = new Date(pauseEndsAt);

    return pauseStartsAt <= now && pauseEndsAt > now;
  }

  function isPlanAnnual() {
    return api.userObject.subscription.vendor_code && api.userObject.subscription.vendor_code.toLowerCase().indexOf('annual') > -1;
  }

}]);

app.factory('userInfo', ['$q', 'api', function ($q, api) {
  var userInfo = {};

  return {

    // Methods
    getUserTimezone: getUserTimezone,
    getUserAddress: getUserAddress,
    checkMessagePresetPermission: checkMessagePresetPermission,
    checkMessageSchedulePermission: checkMessageSchedulePermission,
    checkPaymentPermission: checkPaymentPermission,
    buildAddress: buildAddress,
    getUserPerms: getUserPerms,
    isUserLimitedToCompanySelections: isUserLimitedToCompanySelections
  };

  function getUserTimezone(reload, callback) {
    if (reload) {
      api.getMe(1).then(function (result) {
        userInfo.timezone = result.user.timezone;
        callback(userInfo.timezone);
      });
    } else {
      api.getMe().then(function (result) {
        userInfo.timezone = result.user.timezone;
        callback(userInfo.timezone);
      });
    }
  }

  function getUserAddress(callback) {
    api.getUserDetails(api.userObject.user.userid, function (result) {
      userInfo.address = {};
      userInfo.address.street = result.user.street;
      userInfo.address.street2 = result.user.street2;
      userInfo.address.city = result.user.city;
      userInfo.address.state = result.user.state;
      userInfo.address.zipcode = result.user.zipcode;
      userInfo.address.country = result.user.country;
      userInfo.address.phone = result.user.phone;
      callback(userInfo.address);
    }, function (err) {
      console.error('error fetching user address');
    });
  }

  function buildAddress(user) {
    var address;
    if (user.street2) {
      address = user.street + ', ' + user.street2 + ', ' + user.city + ' ' + user.state + ' ' + user.zipcode;
    } else if (user.street && user.city && user.state && user.zipcode) {
      address = user.street + ', ' + user.city + ' ' + user.state + ' ' + user.zipcode;
    } else {
      address = '';
    }
    return address;
  }

  function checkMessagePresetPermission(callback) {
    api.getMe(1).then(function (me) {
      var result = (me.permissions.account.messages || me.permissions.account.owner);
      callback(result);
    });
  }

  function checkMessageSchedulePermission(callback) {
    api.getMe(1).then(function (me) {
      callback(me.permissions.account.messages || me.permissions.account.owner);
    });
  }

  function checkPaymentPermission(callback) {
    api.getMe().then(function (me) {
      callback(me.permissions.account.payment || me.permissions.account.owner);
    });
  }

  function getUserPerms(callback) {
    api.getMe()
      .then(function (me) {
        var isAccountOwner = me.permissions.account.owner;
        var perms = {
          isAccountOwner: isAccountOwner,
          isMessageAdmin: isAccountOwner || me.permissions.account.messages,
          isMusicAdmin: isAccountOwner || me.permissions.account.music,
          isPaymentAdmin: isAccountOwner || me.permissions.account.payment,
          isPaymentAdminOnly: !isAccountOwner && !me.permissions.account.music && !me.permissions.account.messages && me.permissions.account.payment,
          canEditRegion: isAccountOwner || me.permissions.account.music || me.permissions.account.messages,
          canPlayMusic: me.permissions.user.can_play_music,
          canSkip: isAccountOwner || me.permissions.user.can_skip || me.permissions.account.music,
          canPause: isAccountOwner || me.permissions.user.can_pause || me.permissions.account.music,
          canRemoveSong: isAccountOwner || me.permissions.user.can_downvote || me.permissions.account.music,
          canManageMusic: isAccountOwner || me.permissions.user.manage_music,
          canManageMessages: isAccountOwner || me.permissions.user.manage_messages,
          canManageDevices: isAccountOwner || me.permissions.user.manage_devices,
          canSelectMusic: isAccountOwner || me.permissions.account.music || me.permissions.user.select_music,
          canSelectMessages: isAccountOwner || me.permissions.account.messages || me.permissions.user.select_messages,
        };

        callback(perms);
      });
  }

  function isUserLimitedToCompanySelections() {
    var scope = this;
    var isLimitedToCompanySelections = false;

    return api.getMe()
      .then(function (me) {
        var deferred = $q.defer();

        isLimitedToCompanySelections = me.has_company_stations;

        scope.getUserPerms(function (permissions) {
          deferred.resolve(permissions);
        });

        return deferred.promise;
      })
      .then(function (permissions) {
        return isLimitedToCompanySelections && !permissions.isMusicAdmin;
      });
  }

}]);

(function (app) {
  app.factory('userNotificationService', userNotificationService);

  userNotificationService.$inject = ['growl'];

  function userNotificationService(growl) {

    return {

      // Methods
      addErrorMessage: addErrorMessage,
      addInfoMessage: addInfoMessage,
      addSuccessMessage: addSuccessMessage,
      addWarnMessage: addWarnMessage
    };

    function addErrorMessage(message) {
      growl.addErrorMessage(message);
    }

    function addInfoMessage(message) {
      growl.addInfoMessage(message);
    }

    function addSuccessMessage(message) {
      growl.addSuccessMessage(message);
    }

    function addWarnMessage(message) {
      growl.addWarnMessage(message);
    }
  }

})(app);
app.directive('daypart', function () {
  return {
    restrict: 'E',
    scope: {
      part: '=',
      day: '=',
      dayname: '@',
      index: '=',
      usedslot:'='
    },
    controller: ['$scope', '$rootScope', function($scope, $rootScope) {

      $scope.timeArray = [
        {i:0,name:'12am'},
        {i:1,name:'1am'},
        {i:2,name:'2am'},
        {i:3,name:'3am'},
        {i:4,name:'4am'},
        {i:5,name:'5am'},
        {i:6,name:'6am'},
        {i:7,name:'7am'},
        {i:8,name:'8am'},
        {i:9,name:'9am'},
        {i:10,name:'10am'},
        {i:11,name:'11am'},
        {i:12,name:'12pm'},
        {i:13,name:'1pm'},
        {i:14,name:'2pm'},
        {i:15,name:'3pm'},
        {i:16,name:'4pm'},
        {i:17,name:'5pm'},
        {i:18,name:'6pm'},
        {i:19,name:'7pm'},
        {i:20,name:'8pm'},
        {i:21,name:'9pm'},
        {i:22,name:'10pm'},
        {i:23,name:'11pm'},
        {i:24,name:'12am'}
      ];

      $scope.freqArray = [
        {i:10,name:'10%'},
        {i:20,name:'20%'},
        {i:30,name:'30%'},
        {i:40,name:'40%'},
        {i:50,name:'50%'},
        {i:60,name:'60%'},
        {i:70,name:'70%'},
        {i:80,name:'80%'},
        {i:90,name:'90%'},
        {i:100,name:'100%'}
      ];

      $scope.usedArray = $scope.usedslot;
      $scope.remove = function (e) {
        $rootScope.confirmLocationSwitch = 'Are you sure? Any changes will not be saved.';
        var cindex=e.currentTarget.id.replace('_circle','');
        $scope.day.splice($scope.index,1);
        for(var i=$scope.part.start; i < $scope.part.end; i++)
        {
          $scope.usedArray[i] = 'n';
        }

        if($('#arrGlobalStart').attr('value')!='')
        {
          var arrGlobalStart=JSON.parse($('#arrGlobalStart').attr('value'));
          var arrGlobalEnd=JSON.parse($('#arrGlobalEnd').attr('value'));

          var arrGlobalStartNew=new Object();
          var arrGlobalEndNew=new Object();

          var identifier=cindex.replace(/[0-9]/g, '');
          var identifierInt=cindex.replace(identifier,'');
          var arrStart=new Array(),arrEnd=new Array();

          $.each(arrGlobalStart,function(index,val){
            if(index.search(identifier)!==-1)
            {
              var iiiStr=index.replace(/[0-9]/g, '');
              var iiiInt=index.replace(iiiStr, '');
              arrStart[parseInt(iiiInt)]=arrGlobalStart[index];
              arrEnd[parseInt(iiiInt)]=arrGlobalEnd[index];
            }
            else
            {
              arrGlobalStartNew[index]=arrGlobalStart[index];
              arrGlobalEndNew[index]=arrGlobalEnd[index];
            }
          });

          var arrStartNew=new Object(),arrEndNew=new Object(),iNew=0;
          $(arrStart).each(function(index,val){
            if(parseInt(index)!=parseInt(identifierInt))
            {
              arrGlobalStartNew[identifier+iNew]=arrStart[index];
              arrGlobalEndNew[identifier+iNew]=arrEnd[index];
              iNew++;
            }
          });

          $('#arrGlobalStart').attr('value',JSON.stringify(arrGlobalStartNew));
          $('#arrGlobalEnd').attr('value',JSON.stringify(arrGlobalEndNew));
        }
      };

      $scope.startArray = function () {
        return $scope.timeArray.slice(0,$scope.part.end);
      }

      $scope.endArray = function () {
        return $scope.timeArray.slice($scope.part.start+1,25);
      }

      var sliderName = "#day"+$scope.dayname+"index"+$scope.index;
      var moved = false;

      $scope.scope_tooltips = [];

      function slideTip( e, ui,c ){
        if($('#arrGlobalStart').attr('value')!='')
        {
          var arrGlobalStart=JSON.parse($('#arrGlobalStart').attr('value'));
          var arrGlobalEnd=JSON.parse($('#arrGlobalEnd').attr('value'));
        }
        else
        {
          var arrGlobalStart=new Object();
          var arrGlobalEnd=new Object();
        }

        var identifier=e.target.id.replace(/[0-9]/g, '');
        var identifierInt=e.target.id.replace(identifier,'');
        var notAvailableIndexes=getDiffRange(arrGlobalStart,arrGlobalEnd,identifier,e.target.id);
        var selfIndexes=getSelfRange(arrGlobalStart,arrGlobalEnd,e.target.id);
        var alreadyThere=compareCurrentRange(ui.values[0],ui.values[1],notAvailableIndexes);
        if(alreadyThere===true)
        {
          return false;
        }


        if(ui.values[0] == ui.values[1])
        {
          return false;
        }

        $($scope.scope_tooltips[0]).find('.tooltip-inner').html($scope.timeArray[ui.values[0]].name);
        $($scope.scope_tooltips[1]).find('.tooltip-inner').html($scope.timeArray[ui.values[1]].name);
        $scope.part.start = ui.values[0];
        $scope.part.end = ui.values[1];

        arrGlobalStart[e.target.id]=$scope.part.start;
        arrGlobalEnd[e.target.id]=$scope.part.end;

        $('#arrGlobalStart').attr('value',JSON.stringify(arrGlobalStart));
        $('#arrGlobalEnd').attr('value',JSON.stringify(arrGlobalEnd));
      }

      function getDiffRange(arrGlobalStart,arrGlobalEnd,strIndex,currentIndex)
      {
        var notAvailableIndexes=new Array();
        $.each(arrGlobalStart,function(index,val){

          if(index.search(strIndex)!==-1 && currentIndex!=index)
          {
            for(var i=parseInt(arrGlobalStart[index]);i < parseInt(arrGlobalEnd[index]); i++)
            {
              notAvailableIndexes.push(i);
            }
          }
        });

        return notAvailableIndexes;
      }

      function getSelfRange(arrGlobalStart,arrGlobalEnd,cindex)
      {
        var selfIndexes=new Array();

        for(var i=parseInt(arrGlobalStart[cindex]);i <= parseInt(arrGlobalEnd[cindex]); i++) {
          selfIndexes.push(i);
        }

        return selfIndexes;
      }

      function compareCurrentRange(start,end,notAvailableIndexes)
      {
        var flag=false;
        for(var i=parseInt(start);i < parseInt(end);i++)
        {
          if(notAvailableIndexes.indexOf(i)!==-1)
          {
            flag=true;
          }
        }

        return flag;
      }

      setTimeout(function () {
        var elem = $(sliderName);

        elem.slider({
          range: true,
          min: 0,
          max: 24,
          values: [$scope.part.start,$scope.part.end],
          slide: slideTip,
          stop: slideTip,

          create: function (e, ui) {
            $(sliderName+" .ui-slider-handle:first").tooltip( {title: $scope.timeArray[$scope.part.start].name, trigger: "manual"}).tooltip("show");
            $(sliderName+" .ui-slider-handle:last").tooltip( {title: $scope.timeArray[$scope.part.end].name, trigger: "manual"}).tooltip("show");

            var tooltips = $(this).find('.tooltip');

            if($('#arrGlobalStart').attr('value')!='')
            {
              var arrGlobalStart=JSON.parse($('#arrGlobalStart').attr('value'));
              var arrGlobalEnd=JSON.parse($('#arrGlobalEnd').attr('value'));
            }
            else
            {
              var arrGlobalStart=new Object();
              var arrGlobalEnd=new Object();
            }

            arrGlobalStart[e.target.id]=$scope.part.start;
            arrGlobalEnd[e.target.id]=$scope.part.end;

            $('#arrGlobalStart').attr('value',JSON.stringify(arrGlobalStart));
            $('#arrGlobalEnd').attr('value',JSON.stringify(arrGlobalEnd));

            tooltips.each(function (i,a,c) {
              a.previousSibling.appendChild(a);
              $scope.scope_tooltips.push(a);
            });
          }
        });
      },100);
    }],
    templateUrl: 'views/daypart.html'
  };
});


app.directive('playlist', function () {
  return {
    restrict: 'E',
    scope: {
      playlist: '=',
      index: '=',
      lists: '='
    },
    controller: ['$scope', function($scope) {
      $scope.freqArray = [
        {value:10,name:'1 - Less'},
        {value:20,name:'2'},
        {value:30,name:'3'},
        {value:40,name:'4'},
        {value:50,name:'5'},
        {value:60,name:'6'},
        {value:70,name:'7'},
        {value:80,name:'8'},
        {value:90,name:'9'},
        {value:100,name:'10 - More'}
      ];

      $scope.remove = function () {
        $scope.lists.splice($scope.index,1);
      }

    }],
    templateUrl: 'views/mixplaylist.html'

  };
});
app.directive('ngEnter', function() {
  return function(scope, element, attrs) {
    element.bind("keydown keypress", function(event) {
      if(event.which === 13) {
        scope.$apply(function(){
          scope.$eval(attrs.ngEnter, {'event': event});
        });

        event.preventDefault();
      }
    });
  };
});

app.directive('audiosampleplayer', ['$sce', function ($sce) {
  return {
    restrict: 'E',
    templateUrl: 'partials/audio_sample_player.html',
    link: function (scope, element, attrs) {
      var audioSrc = $sce.trustAsResourceUrl(scope.stationInfo.sampleFile);
      var audio = new Audio(audioSrc);

      if (scope.isMobile) {
        scope.playing = false;
        scope.play = function () {
          audio.play();
          scope.playing = true;
        }

        scope.pause = function () {
          audio.pause();
          scope.playing = false;
        }

        scope.stop = function() {
          audio.pause();
          audio.currentTime = 0;
          scope.playing = false;
        }
      }
    }
  }
}]);

app.directive('currentPlayInfobox', function() {
  return {
    restrict: 'E',
    scope: false,
    templateUrl: 'partials/current_play_infobox.html',
    link: function(scope, element, attrs) {
    }
  }
});

app.directive('daypartPopupToolbar',
  ['$rootScope', 'daypartToolbarService', '$timeout',
  function($rootScope, daypartToolbarService, $timeout) {
    return {
      restrict: 'A',
      templateUrl: 'partials/daypart_popup_toolbar.html',
      scope: {},
      link: function(scope, element, attrs) {
        var isHover = false;

        $rootScope.$on('showDaypartToolbarPopup', function() {
          scope.$apply(function() {
            var position = daypartToolbarService.getLocation();
            scope.left = position.x + 'px';
            scope.top = position.y + 'px';
            scope.ratingList = daypartToolbarService.getRatingList();
            scope.show = true;
            setTimeout(function() {
              if (!isHover) {
                setHide();
              }
            }, 2000);
          });
        });

        scope.setTrigger = function(trigger) {
          daypartToolbarService.setTrigger(trigger);
        }

        scope.setHovering = function() {
          daypartToolbarService.setHovering(true);
        }

        scope.clearHovering = function(e) {
          $timeout(function() {
            daypartToolbarService.setHovering(false);
            daypartToolbarService.hide();
          }, 500);
        }

        var setHide = function() {
          scope.$apply(function() {
            daypartToolbarService.hide();
            scope.show = false;
          });
        }

        scope.hide = function() {
          setHide();
        }

        element.on('mouseover',function(e) {
          isHover = true;
        });

        element.on('mouseleave',function(e) {
          isHover = false;
          setHide();
        });
      }
    }
  }]);


var daypartUtilModule = angular.module('daypartUtilModule', [])
.factory('daypartUtils', function() {
  var utils = {};
  utils.pad = function(n, width) {
    n = n + '';
    return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
  }

  utils.intToTime = function(input){
    var hours = Math.floor(input / 60);
    // Let's make this 1 hour incr, with am/pm 12hour time.
    var ampm = '';
    if (hours == 0 || hours == 24) {
      hours = '12';
      ampm = 'am';
    }
    else if (hours < 12) {
      ampm = 'am';
    }
    else if (hours == 12) {
      ampm = 'pm';
    }
    else {
      hours = (hours - 12);
      ampm = 'pm';
    }
    var minutes = input % 60;
    return this.pad(hours, 2)+':'+this.pad(minutes, 2) + ampm;
  }

  utils.getStationLabel = function(start,stop,tick,station) {
    var label = station;
    var abrev = '';
    var words = [];
    if (stop - start < 4 * tick) {
      words = label.split(/\s+/);
      for (var i=0; i < words.length; i++) {
        abrev += words[i][0];
      }
      label = abrev;
    }
    return label;
  }

  utils.getTimeLabel = function(start,stop) {
    return '(' + this.intToTime(start) + ' - ' + this.intToTime(stop) + ')';
  }

  utils.splitOverlaps = function(scope) {
    angular.forEach(scope.slots, function(el,idx){
      if(el !== scope.model && el.day === scope.model.day){
        // make sure we're dealing only with integers
        el.start = parseInt(el.start);
        el.stop = parseInt(el.stop);
        scope.model.start = parseInt(scope.model.start);
        scope.model.stop = parseInt(scope.model.stop);

        // model is inside another slot
        if(el.stop > scope.model.stop && el.start < scope.model.start){
          var newSlot = angular.copy(el);
          newSlot.start = scope.model.stop;
          scope.slots[idx].stop = scope.model.start;
          scope.slots[idx].timeLabel = utils.getTimeLabel(el.start,el.stop);
          newSlot.timeLabel = utils.getTimeLabel(newSlot.start,newSlot.stop);
          scope.slots.push(newSlot);
        }
        // model completely covers another slot
        else if(scope.model.stop >= el.stop && scope.model.start <= el.start){
          scope.slots[idx] = {};
        }
        // another slot's stop is inside current model
        else if(el.stop >= scope.model.start && el.stop < scope.model.stop ){
          scope.slots[idx].stop = scope.model.start;
          scope.slots[idx].timeLabel = utils.getTimeLabel(el.start,el.stop);
        }
        // another slot's start is inside current model
        else if (el.start >= scope.model.start && el.start < scope.model.stop){
          scope.slots[idx].start = scope.model.stop;
          scope.slots[idx].timeLabel = utils.getTimeLabel(el.start,el.stop);
        }
      }
    });
  }

  return utils;

});

angular.module('daypartGrid', [])
.directive('daypartGrid', [function() {
  return {
    scope: {
      min: '=',
      max: '=',
      tick: '='
    },
    restrict: 'E',
    templateUrl: 'views/daypart_grid.html',
    link: function(scope) {
      scope.range = function(n) {
        return new Array(n);
      };
      scope.tickcount = (scope.max - scope.min) / scope.tick;
      scope.ticksize = 100 / scope.tickcount;
    }
  };
}]);

angular.module('daypartHandle', [])
.directive('daypartHandle', ['$document', function($document){
  return {
    scope: {
      ondrag: '=',
      ondragstop: '=',
      ondragstart: '='
    },
    restrict: 'A',
    link: function(scope, element) {

      var x = 0;

      element.on('mousedown', function(event) {
        // Prevent default dragging of selected content
        event.preventDefault();

        x = event.pageX;

        $document.on('mousemove', mousemove);
        $document.on('mouseup', mouseup);

        if(scope.ondragstart){
          scope.ondragstart(event);
        }

      });

      function mousemove(event) {
        var delta = event.pageX - x;
        scope.ondrag(delta);
      }

      function mouseup(event) {
        $document.unbind('mousemove', mousemove);
        $document.unbind('mouseup', mouseup);

        if(scope.ondragstop){
          scope.ondragstop(event);
        }
      }
    }
  };
}]);

angular.module('daypartMultislider', ['daypartSlot','daypartUtilModule'])
.filter('byDay', [function(){
  return function(input, day){
    var ret = [];
    angular.forEach(input, function(el){
      if(el.day === day){
        ret.push(el);
      }
    });
    return ret;
  };
}])
.filter('intToTime', ['input','daypartUtils',function(input,daypartUtils) {
  return daypartUtils.intToTime;
}])
.directive('daypartMultiSlider', ['daypartUpdateModal', 'daypartUtils', function(daypartUpdateModal, daypartUtils) {
  return {
    scope: {
      slots: '=',
      max: '=',
      min: '=',
      tick: '=',
      defaultValue: '=',
      day: '=',
      zoom: '=',
    },
    restrict: 'E',
    templateUrl: 'views/daypart_multi_slider.html',
    link: function(scope, element){
      var stationLabel = '';
      var timeLabel = '';

      var tickcount = (scope.max - scope.min) / scope.tick;
      var ticksize = 100 / tickcount;

      var hoverElement = angular.element(element.find('div')[0]);
      var hoverElementWidth = 0;

      scope.model = {};

      // Make sure slots was initialized
      if (scope.slots == null) scope.slots = [];

      for (var i=0; i<scope.slots.length; i++) {
        stationLabel = daypartUtils.getStationLabel(scope.slots[i].start,scope.slots[i].stop,scope.tick,scope.slots[i].stationName);
        timeLabel = daypartUtils.getTimeLabel(scope.slots[i].start,scope.slots[i].stop);
        scope.slots[i].stationLabel = stationLabel;
        scope.slots[i].timeLabel = timeLabel;
      }

      var valToPixel = function(val){
        var percent = val / (scope.max - scope.min);
        if (element[0].clientWidth == 0)
          return 180;
        else
          return Math.floor(percent * element[0].clientWidth + 0.5);
      };

      var pixelToVal = function(pixel){
        var percent = pixel / element[0].clientWidth;
        return Math.floor(percent * (scope.max - scope.min) + 0.5);
      };

      var round = function(n){
        return scope.tick * Math.round(n / scope.tick);
      };

      var addSlot = function(slotInfo) {
        var stationLabel = '';
        var timeLabel = '';
        var stationInfo = [];
        var stationId = 0;
        var stationName = '';
        var stationType = '';
        var start = parseInt(slotInfo.startTime);
        var stop = parseInt(slotInfo.endTime);

        start = start >= scope.min ? start : scope.min;
        stop = stop <= scope.max ? stop : scope.max;
        timeLabel = daypartUtils.getTimeLabel(start,stop);

        if (slotInfo.mixstation) {
          stationInfo = slotInfo.mixstation.split('=');
          stationType = 'mix';
        } else if (slotInfo.station) {
          stationInfo = slotInfo.station.split('=');
          stationType = 'playlist';
        } else {
          return;
        }
        if (stationInfo.length < 2) return;

        stationId = stationInfo[0];
        stationInfo.shift();
        stationName = stationInfo.join('=');
        stationLabel = daypartUtils.getStationLabel(start,stop,scope.tick,stationName);

        scope.model = {
          start: start,
          stop: stop,
          day: scope.day,
          stationType: stationType,  // will need to get this working properly
          stationId: stationId,
          stationName: stationName,
          stationLabel: stationLabel,
          timeLabel: timeLabel,
        };

        scope.slots.push(scope.model);
        splitOverlaps();
      };

      var splitOverlaps = function(){
        daypartUtils.splitOverlaps(scope);
      };

      element.on('mousemove', function(e){
        var rect = element[0].getBoundingClientRect(),
          elOffX = e.clientX - rect.left;

        hoverElementWidth = valToPixel(scope.tick * 4);

        hoverElement.css({
          width: hoverElementWidth +'px'
        });

        hoverElement.css({
          left: elOffX - hoverElementWidth/2 + 'px'
        });
      });

      hoverElement.on('click', function(e){
        if(!element.attr('no-add')){
          element[0].classList.add('selected');

          var rect = element[0].getBoundingClientRect();
          var pixelOnClick = e.clientX - rect.left;
          var valOnClick = pixelToVal(pixelOnClick);

          var start = round(valOnClick - scope.defaultValue/2);
          var stop = start + scope.defaultValue;

          if (start < scope.min) start = scope.min;
          if (stop > scope.max) stop = scope.max;
          scope.newStart = start;
          scope.newStop = stop;

          daypartUpdateModal.setOptions({
            headerText: 'Create Daypart',
            daypartType: 'playlist',
          });
          daypartUpdateModal.setModel({
            startTime: start,
            endTime: stop,
          });
          daypartUpdateModal.show()
            .then(function (result) {
              addSlot(result);
              element[0].classList.remove('selected');
            })
            .catch(function () {
              element[0].classList.remove('selected');
            });
        }
      });
    }
  };
}]);

angular.module('daypartScheduler', ['daypartMultislider', 'daypartGrid'])
.filter('intToHour', [function(){
  return function(input) {
    function pad(n, width) {
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
    }

    var hours = Math.floor(input / 60);
    // Let's make this 1 hour incr, with am/pm 12hour time.
    var time = '';
    var ampm = '';
    if (hours == 0) time = '12am';
    else if (hours < 12) time = hours+'am';
    else if (hours == 12) time = '12pm';
    else time = (hours - 12)+'pm';
    return time;
  };
}])
.directive('daypartScheduler', [function(){
  return {
    templateUrl: 'views/daypart_scheduler.html',
    restrict: 'E',
    scope: {
      slots: '=',
      zoom: '=',
    },
    link: function(scope, element){
      scope.labels = [
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday',
        'Sunday',
      ];

      var dataContainer = $(element).find('.data-container');
      scope.$watch(function() {
        return dataContainer[0].scrollWidth > 0;
      }, function() {
        dataContainer[0].scrollLeft = dataContainer[0].scrollWidth / 3;
        scope.$emit('daypart-container-loaded', dataContainer[0]);
      });
    }
  };
}]);

angular.module('daypartSlot', ['daypartHandle','daypartUtilModule'])
.directive('daypartSlot', ['$rootScope','daypartUpdateModal','daypartToolbarService','daypartUtils', '$timeout', 'confirmationDialog', function($rootScope,daypartUpdateModal,daypartToolbarService,daypartUtils,$timeout, confirmationDialog) {
  return {
    scope: {
      min: '=',
      max: '=',
      model: '=',
      slots: '=',
      tick: '=',
      zoom: '=',
    },
    restrict: 'E',
    templateUrl: 'views/daypart_slot.html',
    link: function(scope, element) {

      scope.$watch('model', function(){
        setPosition();
      }, true);

      var slotId = Math.floor(Math.random()*10000);
      var container = element.parent()[0];
      var dataContainer = element.parent().parent().parent().parent()[0];
      var resizeDirectionIsStart = true;
      //var valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop, cursorX: 0, delta: 0};
      var valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop};

      var valToPixel = function(val){
        var percent = val / (scope.max - scope.min);
        return Math.floor(percent * container.clientWidth + 0.5);
      };

      var valToPercent = function(val){
        return val / (scope.max - scope.min) * 100;
      };

      var pixelToVal = function(pixel){
        var percent = pixel / container.clientWidth;
        return Math.floor(percent * (scope.max - scope.min) + 0.5);
      };

      var round = function(n){
        return scope.tick * Math.round(n / scope.tick);
      };

      var setPosition = function(){
        var offset = valToPercent(scope.model.start);
        var width = valToPercent(scope.model.stop - scope.model.start);
        element.css({
          left: offset + '%',
          width: width + '%'
        });
      };


      var deleteSelf = function(){
        confirmationDialog(scope, "Are you sure you want to delete this daypart?",
          function() {
            angular.element(container).removeClass('dragging');
            angular.element(container).removeClass('slot-hover');
            scope.slots.splice(scope.slots.indexOf(scope.model), 1);
          }).catch(angular.noop);
      };

      element.on('mouseover', function(e){
        if (! angular.element(container).hasClass('slot-hover')) {
          angular.element(container).addClass('slot-hover');
          scope.displayToolbar(e);
        }
      });

      element.on('mouseleave', function(e){
        angular.element(container).removeClass('slot-hover');
      });


      scope.stopDrag = function(e){
        // this prevents user from accidentally
        // adding new slot after resizing or dragging
        setTimeout(function(){
          angular.element(container).removeAttr('no-add');
        }, 500);

        element.removeClass('active');
        angular.element(container).removeClass('dragging');

        // First, if the slot wasn't moved, then we'll assume the user just clicked, and wants toolbar
        if (
          (valuesOnDragStart.start >= scope.model.start - 2 && valuesOnDragStart.start <= scope.model.start + 2) &&
          (valuesOnDragStart.stop >= scope.model.stop - 2 && valuesOnDragStart.stop <= scope.model.stop + 2)
        ){
          // user didn't drag
          scope.model.start = valuesOnDragStart.start;
          scope.model.stop = valuesOnDragStart.stop;
        } else {
          // Let's Figure out where the slot was dropped, and place it in the position of the tick it closest to.
          // So if we drop at 9:10am, then it should move to 9:15am.  If we drop at 9:05, then place at 9:00.
          var slotWidth = scope.model.stop - scope.model.start;
          scope.model.start = round(scope.model.start);
          scope.model.stop = round(scope.model.start + slotWidth);
          if (scope.model.start < scope.min) {
            if (scope.model.stop <= scope.min) {
              scope.model.stop = scope.min + scope.tick;
            }
            scope.model.start = scope.min;
          }
          if (scope.model.stop > scope.max) {
            if (scope.model.start >= scope.max) {
              scope.model.start = scope.max - scope.tick;
            }
            scope.model.stop = scope.max;
          }

          // update scope timeLabel and stationLabel
          scope.model.stationLabel = daypartUtils.getStationLabel(scope.model.start, scope.model.stop, scope.tick, scope.model.stationName);
          scope.model.timeLabel = daypartUtils.getTimeLabel(scope.model.start, scope.model.stop);

          // finally, Search over all existing slots and see if we are overlapping any.  If we are overlapping any,
          // then we'll need to overwrite the values of the other. Overlapping could be partial or full.  If full, then delete other.
          // If partial, then alter other accordingly.
          splitOverlaps();
        }
      };


      scope.startResizeStart = function(){
        resizeDirectionIsStart = true;
        scope.startDrag();
      };

      scope.startResizeStop = function(){
        resizeDirectionIsStart = false;
        scope.startDrag();
      };

      scope.startDrag = function(){
        daypartToolbarService.hide();

        element.addClass('active');

        angular.element(container).addClass('dragging');
        angular.element(container).attr('no-add', true);

        //valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop, cursorX: ev.offsetX, delta: 0};
        valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop};
      };


      scope.resize = function(d){
        var slotWidth = scope.model.stop - scope.model.start;

        // Figure out if we need to scroll the container
        var dataContainerWidth = dataContainer.clientWidth;
        var parentWidth = container.clientWidth;
        var pixelRight = dataContainerWidth + dataContainer.scrollLeft;
        var pixelLeft = dataContainer.scrollLeft;
        var scrollOffset = valToPixel(scope.tick);

        if(resizeDirectionIsStart){
          // resizing the start position
          var newStart = 0;
          var newDragStart = 0;
          var startPosition = valToPixel(valuesOnDragStart.start) + d;

          if (dataContainer.scrollLeft > 0 && startPosition <= pixelLeft) {
            var newScrollLeft = dataContainer.scrollLeft - scrollOffset;
            if (newScrollLeft < 0) newScrollLeft = 0;
            dataContainer.scrollLeft = newScrollLeft;
            newStart = round(pixelToVal(startPosition - scrollOffset));
            newDragStart = valuesOnDragStart.start - pixelToVal(scrollOffset);
            if (newDragStart < 0) newDragStart = 0;
            valuesOnDragStart.start = newDragStart;
          }
          else if (startPosition >= pixelRight && startPosition < valToPixel(scope.model.stop)) {
            dataContainer.scrollLeft = dataContainer.scrollLeft + scrollOffset;
            newStart = round(pixelToVal(startPosition + scrollOffset));
            newDragStart = valuesOnDragStart.start + pixelToVal(scrollOffset);
            if (newDragStart > scope.max - slotWidth)
              newDragStart = scope.max - slotWidth;
            valuesOnDragStart.start = newDragStart;
          }
          else newStart = round(pixelToVal(startPosition));

          if (newStart >= scope.model.stop) {
            newStart = scope.model.stop - scope.tick;
          }
          if (newStart <= scope.min) {
            newStart = scope.min;
          }
          scope.model.start = newStart;
        } else {
          // resizing the end position
          var newStop = 0;
          var newDragStop = 0;
          var endPosition = valToPixel(valuesOnDragStart.stop) + d;

          if (endPosition >= pixelRight && endPosition <= valToPixel(scope.max)) {
            dataContainer.scrollLeft = dataContainer.scrollLeft + scrollOffset;
            newStop = round(pixelToVal(endPosition + scrollOffset));
            if (newStop > scope.max) newStop = scope.max;
            newDragStop = valuesOnDragStart.stop + pixelToVal(scrollOffset);
            if (newDragStop > valToPixel(scope.max))
              newDragStop = valToPixel(scope.max);
            valuesOnDragStart.stop = newDragStop;
          }
          else if (endPosition <= pixelLeft && scope.model.start < pixelToVal(endPosition)) {
            var newScrollLeft = dataContainer.scrollLeft - scrollOffset;
            if (newScrollLeft < 0) newScrollLeft = 0;
            dataContainer.scrollLeft = newScrollLeft;
            newStop = round(pixelToVal(endPosition - scrollOffset));
            newDragStop = valuesOnDragStart.stop - pixelToVal(scrollOffset);
            if (newDragStop < 0) newDragStart = 0;
            valuesOnDragStart.stop = newDragStop;
          }
          else newStop = round(pixelToVal(endPosition));

          if (newStop <= scope.model.start) {
            newStop = scope.model.start + scope.tick;
          }
          if (newStop >= scope.max) {
            newStop = scope.max;
          }
          scope.model.stop = newStop;
        }
        // finally, update scope timeLabel and stationLabel
        scope.model.stationLabel = daypartUtils.getStationLabel(scope.model.start, scope.model.stop, scope.tick, scope.model.stationName);
        scope.model.timeLabel = daypartUtils.getTimeLabel(scope.model.start, scope.model.stop);

        scope.$apply();
      };

      scope.drag = function(d){
        scope.$apply(function(){
          if (typeof scope.model.stop == 'undefined')
            scope.model.stop = scope.model.start;

          var slotWidth = scope.model.stop - scope.model.start;
          var newSlotPosition = 0;
          var dragPosition = valToPixel(valuesOnDragStart.start) + d;

          // Figure out if we need to scroll the container
          var dataContainerWidth = dataContainer.clientWidth;
          var parentWidth = container.clientWidth;
          var pixelRight = dataContainerWidth + dataContainer.scrollLeft;
          var pixelLeft = dataContainer.scrollLeft;
          var slotCenterPosition = dragPosition + valToPixel((slotWidth / 2));
          var scrollOffset = valToPixel(scope.tick);
          var multiplier = 1;
          //if (d > 0 && slotCenterPosition >= (pixelRight - slotWidth)) {
          if (d > 0 && (dragPosition + valToPixel(slotWidth)) >= pixelRight &&
          dataContainer.scrollLeft < dataContainer.scrollWidth) {
            if (slotCenterPosition >= (pixelRight - (slotWidth / 2))) {
              multiplier = 2;
            } else if (slotCenterPosition >= (pixelRight - (slotWidth / 3))) {
              multiplier = 4;
            }

            dataContainer.scrollLeft += (10 * multiplier);
            newSlotPosition = pixelToVal(dragPosition + (10 * multiplier));
            newDragStart = valuesOnDragStart.start + pixelToVal(10 * multiplier);

            if (newDragStart > scope.max - slotWidth)
              newDragStart = scope.max - slotWidth;
            valuesOnDragStart.start = newDragStart;
          }
          //else if (d < 0 && slotCenterPosition <= (pixelLeft + slotWidth)) {
          else if (d < 0 && dragPosition <= pixelLeft && dataContainer.scrollLeft > 0) {
            if (slotCenterPosition <= (pixelLeft + (slotWidth / 2))) {
              multiplier = 2;
            } else if (slotCenterPosition <= (pixelLeft + (slotWidth / 3))) {
              multiplier = 4;
            }

            dataContainer.scrollLeft -= (10 * multiplier);
            newSlotPosition = pixelToVal(dragPosition - (10 * multiplier));
            newDragStart = valuesOnDragStart.start - pixelToVal(10 * multiplier);

            if (newDragStart < 0) newDragStart = 0;
            valuesOnDragStart.start = newDragStart;
          }
          else {
            newSlotPosition = pixelToVal(dragPosition);
          }

          if (newSlotPosition >= scope.min && newSlotPosition + slotWidth <= scope.max) {
            scope.model.start = newSlotPosition;
            scope.model.stop = newSlotPosition+slotWidth;
          }
          else if (newSlotPosition <= scope.min) {
            scope.model.start = scope.min;
            scope.model.stop = slotWidth;
          }
          else if (newSlotPosition >= scope.max) {
            scope.model.start = scope.max - slotWidth;
            scope.model.stop = scope.max;
          }

          // finally, update scope timeLabel and stationLabel
          scope.model.stationLabel = daypartUtils.getStationLabel(scope.model.start, scope.model.stop, scope.tick, scope.model.stationName);
          scope.model.timeLabel = daypartUtils.getTimeLabel(round(scope.model.start), round(scope.model.stop));

        });
      };


      var edit = function() {
        var station = '';
        var mixstation = '';
        if (scope.model.stationType == 'playlist')
          station = scope.model.stationId+'='+scope.model.stationName
        else if (scope.model.stationType == 'mix')
          mixstation = scope.model.stationId+'='+scope.model.stationName
        daypartUpdateModal.setModel({
          slotId: slotId,
          startTime: scope.model.start,
          endTime: scope.model.stop,
          station: station,
          mixstation: mixstation,
        });
        daypartUpdateModal.setOptions({
          headerText: 'Edit Daypart',
          daypartType: scope.model.stationType,
        });

        daypartUpdateModal.show()
          .then(function (result) {
            if (result.slotId === slotId) {
              var scopeIndex = scope.slots.indexOf(scope.model);
              var stationInfo = [];
              var stationType = '';
              if (result.mixstation) {
                stationInfo = result.mixstation.split('=');
                stationType = 'mix';
              } else if (result.station) {
                stationInfo = result.station.split('=');
                stationType = 'playlist';
              } else {
                return;
              }
              if (stationInfo.length < 2) return;

              scope.model.stationId = stationInfo[0];
              stationInfo.shift();
              scope.model.stationName = stationInfo.join('=');

              scope.model.start = result.startTime >= scope.min ? result.startTime : scope.min;
              scope.model.stop = result.endTime <= scope.max ? result.endTime : scope.max;

              scope.model.stationLabel = daypartUtils.getStationLabel(scope.model.start,scope.model.stop,scope.tick,scope.model.stationName);
              scope.model.timeLabel = daypartUtils.getTimeLabel(scope.model.start,scope.model.stop);

              scope.model.stationType = stationType;

              scope.slots[scopeIndex] = scope.model;

              splitOverlaps();
            }
          })
          .catch(angular.noop);
      }

      scope.displayToolbar = function(e) {
        var rect = e.currentTarget.getBoundingClientRect();
        var width = e.currentTarget.clientWidth;
        var left = rect.left + (width/2);
        var top = e.pageY - e.offsetY - 40;
        daypartToolbarService.setLocation({x: left, y: top});
        daypartToolbarService.show(scope.model.day, slotId, scope.model.stationId);
      }

      $rootScope.$on('triggerDaypartToolbarAction', function(e, options) {
        if (slotId == options.id) {
          if (options.action == 'edit') {
            // edit
            daypartToolbarService.hide();
            edit();
          } else if (options.action == 'delete') {
            // delete
            daypartToolbarService.hide();
            deleteSelf();
          }
        }
      });

      var splitOverlaps = function(){
        daypartUtils.splitOverlaps(scope);
      };

      element.on('mouseover', function(){
        angular.element(container).addClass('slot-hover');
      });

      element.on('mouseleave', function(){
        angular.element(container).removeClass('slot-hover');
      });


      // on init, split overlaps
      splitOverlaps();

    }
  };
}]);

app.directive('focusInput', ['$timeout',function ($timeout) {
  return {
    link: {
      pre: function preLink(scope, element, attr) {
      },
      post: function postLink(scope, element, attr) {
        $timeout(function () {
          element[0].focus();
        },250);
      }
    }
  }
}]);

app.directive('focusWhenTrue', ['$timeout',function ($timeout) {
  return {
    link: function postLink(scope, element, attr) {
        scope.$watch(attr.focusWhenTrue, function(value) {
          if(value === true) { 
            $timeout(function () {
              element[0].focus();
            }, 250);
          }
        });
      }
    }
  }
]);

app.directive('hidePopup', ['$document', function($document){
  return {
    restrict: 'A',
    link: function(scope, elem, attr, ctrl) {
      elem.bind('click', function(e) {
        e.stopPropagation();
      });
      $document.bind('click', function() {
        scope.$apply(attr.hidePopup);
      });
    }
  }
}]);

app.directive('mediaBarStreamsList', ['$rootScope', function($rootScope) {
  return {
    restrict: 'A',
    templateUrl: 'partials/media_bar_streams_list.html',
    scope: {
      streams: '=',
    },
    controller: function(scope, element, attrs) {
      var isHover = false;
      scope.width = "250px";
      scope.height = "100px";

      scope.setTrigger = function(trigger) {
        messageSchedulerToolbarService.setTrigger(trigger);
        scope.show = false;
      }

      var setHide = function() {
        scope.$apply(function() {
          messageSchedulerToolbarService.hide();
          scope.show = false;
        });
      }

      $rootScope.$on('showMessageSchedulerPopup', function(e, options) {
        scope.$apply(function() {
          scope.left = options.x + 'px';
          scope.top = (options.y - parseInt(scope.height) - 20) + 'px';
          scope.dateLabel = options.dateLabel;
          scope.timeLabel = options.timeLabel;
          scope.day = options.day;
          scope.is_recurring = options.is_recurring;
          scope.name = options.name;

          scope.show = true;
          setTimeout(function() {
            if (!isHover) {
              setHide();
            }
          }, 2000);
        });
        e.stopPropagation();
      });

      element.on('mouseover',function(e) {
        isHover = true;
      });

      element.on('mouseleave',function(e) {
        isHover = false;
        setHide();
      });

    }
  }
}]);


app.directive('mediaToolbarErrorMessage', function() {
  return {
    restrict: 'E',
    scope: false,
    templateUrl: 'partials/media_toolbar_error_message.html',
    link: function(scope, element, attrs) {
    }
  }
});

app.directive('messageSchedulerAgenda', [function() {
  return {
    restrict: 'E',
    templateUrl: 'partials/message_scheduler_agenda.html',
    link: function(scope, elem, attrs) {
    }
  };
}]);


var messageScheduleUtilModule = angular.module('messageScheduleUtilModule', [])
.factory('messageScheduleUtils', ['editMessageScheduleService', function(editMessageScheduleService) {
  var utils = {};

  utils.getMessageLabel = function(start,stop,tick,messageName) {
    var label = (messageName) ? messageName : '';
    var abrev = '';
    var words = [];
    if (stop - start < 4 * tick) {
      words = label.split(/\s+/);
      for (var i=0; i < words.length; i++) {
        abrev += words[i][0];
      }
      label = abrev;
    }
    return label;
  }

  utils.splitOverlaps = function(scope) {
    angular.forEach(scope.slots, function(el,idx){
      if(el !== scope.model && el.day === scope.model.day){

        // model is inside another slot
        if(el.stop > scope.model.stop && el.start < scope.model.start){
          var newSlot = angular.copy(el);
          newSlot.start = scope.model.stop;
          scope.slots[idx].stop = scope.model.start;
          scope.slots[idx].timeLabel = editMessageScheduleService.getTimeLabel(el.start);
          newSlot.timeLabel = editMessageScheduleService.getTimeLabel(newSlot.start);
          scope.slots.push(newSlot);
        }
        // model completely covers another slot
        else if(scope.model.stop >= el.stop && scope.model.start <= el.start){
          scope.slots[idx] = {};
        }
        // another slot's stop is inside current model
        else if(el.stop >= scope.model.start && el.stop < scope.model.stop ){
          scope.slots[idx].stop = scope.model.start;
          scope.slots[idx].timeLabel = editMessageScheduleService.getTimeLabel(el.start);
        }
        // another slot's start is inside current model
        else if (el.start >= scope.model.start && el.start < scope.model.stop){
          scope.slots[idx].start = scope.model.stop;
          scope.slots[idx].timeLabel = editMessageScheduleService.getTimeLabel(el.start);
        }
      }
    });
  }

  return utils;

}]);

angular.module('messageScheduleGrid', [])
.directive('messageScheduleGrid', [function() {
  return {
    scope: {
      min: '=',
      max: '=',
      tick: '='
    },
    restrict: 'E',
    templateUrl: 'partials/message_schedule_grid.html',
    link: function(scope) {
      scope.range = function(n) {
        return new Array(n);
      };
      scope.tickcount = (scope.max - scope.min) / scope.tick;
      scope.ticksize = 100 / scope.tickcount;
    }
  };
}]);

angular.module('messageScheduleHandle', [])
.directive('messageScheduleHandle', ['$document', function($document){
  return {
    scope: {
      ondrag: '=',
      ondragstop: '=',
      ondragstart: '='
    },
    restrict: 'A',
    link: function(scope, element) {

      var x = 0;

      element.on('mousedown', function(event) {
        /*
         * Temporarily removing until we get exceptions implemented.
         * More work to be done here.
        // Prevent default dragging of selected content
        event.preventDefault();

        x = event.pageX;

        $document.on('mousemove', mousemove);
        $document.on('mouseup', mouseup);

        if(scope.ondragstart){
          scope.ondragstart(event);
        }
        /**/

      });

      /**
      function mousemove(event) {
        var delta = event.pageX - x;
        scope.ondrag(delta);
      }

      function mouseup(event) {
        $document.unbind('mousemove', mousemove);
        $document.unbind('mouseup', mouseup);

        if(scope.ondragstop){
          scope.ondragstop(event);
        }
      }
      /**/
    }
  };
}]);

angular.module('messageScheduleMultislider', ['messageScheduleSlot','messageScheduleUtilModule'])
.filter('byDay', [function(){
  return function(input, day){
    var ret = [];
    angular.forEach(input, function(el){
      if(el.day === day){
        ret.push(el);
      }
    });
    return ret;
  };
}])
.directive('messageScheduleMultiSlider', ['messageSchedulerModal', 'messageScheduleUtils', function(messageSchedulerModal, messageScheduleUtils) {
  return {
    scope: {
      slots: '=',
      max: '=',
      min: '=',
      tick: '=',
      defaultValue: '=',
      day: '=',
      zoom: '=',
      sid: '=',
    },
    restrict: 'E',
    templateUrl: 'partials/message_schedule_multi_slider.html',
    link: function(scope, element){
      var messageLabel = '';

      var tickcount = (scope.max - scope.min) / scope.tick;
      var ticksize = 100 / tickcount;

      var hoverElement = angular.element(element.find('div')[0]);
      var hoverElementWidth = 0;

      // Make sure slots was initialized
      if (scope.slots == null) scope.slots = [];

      for (var i=0; i<scope.slots.length; i++) {
        messageLabel = messageScheduleUtils.getMessageLabel(scope.slots[i].start,scope.slots[i].stop,scope.tick,scope.slots[i].messageName);
        scope.slots[i].messageLabel = messageLabel;
      }

      var valToPixel = function(val){
        var percent = val / (scope.max - scope.min);
        if (element[0].clientWidth == 0)
          return 180;
        else
          return Math.floor(percent * element[0].clientWidth + 0.5);
      };

      var pixelToVal = function(pixel){
        var percent = pixel / element[0].clientWidth;
        return Math.floor(percent * (scope.max - scope.min) + 0.5);
      };

      var round = function(n){
        return scope.tick * Math.round(n / scope.tick);
      };

      var splitOverlaps = function(){
        var addedSlots = [];
        messageScheduleUtils.splitOverlaps(scope);
      };

      element.on('mousemove', function(e){
        var rect = element[0].getBoundingClientRect(),
          elOffX = e.clientX - rect.left;

        hoverElementWidth = valToPixel(scope.tick * 4);

        hoverElement.css({
          width: hoverElementWidth +'px'
        });

        hoverElement.css({
          left: elOffX - hoverElementWidth/2 + 'px'
        });
      });

      hoverElement.on('click', function(e){
        if(!element.attr('no-add')){
          var rect = element[0].getBoundingClientRect();
          var pixelOnClick = e.clientX - rect.left;
          var valOnClick = pixelToVal(pixelOnClick);

          var start = round(valOnClick);

          scope.$emit('addNewEvent', {
            scheduleid: scope.sid,
            startTime: start,
            day: scope.day,
          });
        }
      });
    }
  };
}]);

angular.module('messageSchedulerCalendar', ['messageScheduleMultislider', 'messageScheduleGrid'])
.filter('intToHour', [function(){
  return function(input) {
    var hours = Math.floor(input / 60);
    // Let's make this 1 hour incr, with am/pm 12hour time.
    var time = '';
    var ampm = '';
    if (hours == 0) time = '12am';
    else if (hours < 12) time = hours+'am';
    else if (hours == 12) time = '12pm';
    else time = (hours - 12)+'pm';
    return time;
  };
}])
.directive('messageSchedulerCalendar', [function(){
  return {
    templateUrl: 'partials/message_scheduler_calendar.html',
    restrict: 'E',
    scope: {
      slots: '=',
      zoom: '=',
      schedule_id: '=scheduleId',
    },
    link: function(scope, element){
      scope.labels = [
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday',
        'Sunday',
      ];

      var dataContainer = $(element).find('.data-container');
      scope.$watch(function() {
        return dataContainer[0].scrollWidth > 0;
      }, function() {
        dataContainer[0].scrollLeft = dataContainer[0].scrollWidth / 3;
        scope.$emit('message_schedule-container-loaded', dataContainer[0]);
      });
    }
  };
}]);

angular.module('messageScheduleSlot', ['messageScheduleHandle','messageScheduleUtilModule'])
.directive('messageScheduleSlot', ['$rootScope','messageSchedulerModal','messageSchedulerToolbarService','messageScheduleUtils', '$timeout', 'confirmationDialog', function($rootScope,messageSchedulerModal,messageSchedulerToolbarService,messageScheduleUtils,$timeout, confirmationDialog) {
  return {
    scope: {
      min: '=',
      max: '=',
      model: '=',
      slots: '=',
      tick: '=',
      zoom: '=',
    },
    restrict: 'E',
    templateUrl: 'partials/message_schedule_slot.html',
    link: function(scope, element) {

      scope.$watch('model', function(){
        setPosition();
      }, true);

      var slotId = Math.floor(Math.random()*10000);
      var container = element.parent()[0];
      var dataContainer = element.parent().parent().parent().parent()[0];
      //var valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop, cursorX: 0, delta: 0};
      var valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop};

      var valToPixel = function(val){
        var percent = val / (scope.max - scope.min);
        return Math.floor(percent * container.clientWidth + 0.5);
      };

      var valToPercent = function(val){
        return val / (scope.max - scope.min) * 100;
      };

      var pixelToVal = function(pixel){
        var percent = pixel / container.clientWidth;
        return Math.floor(percent * (scope.max - scope.min) + 0.5);
      };

      var round = function(n){
        return scope.tick * Math.round(n / scope.tick);
      };

      var setPosition = function(){
        var offset = valToPercent(scope.model.start);
        var width = valToPercent(scope.model.stop - scope.model.start);
        element.css({
          left: offset + '%',
          width: width + '%'
        });
      };

      scope.stopDrag = function(e){
        // this prevents user from accidentally
        // adding new slot after resizing or dragging
        setTimeout(function(){
          angular.element(container).removeAttr('no-add');
        }, 500);

        element.removeClass('active');
        angular.element(container).removeClass('dragging');

        // First, if the slot wasn't moved, then we'll assume the user just clicked, and wants toolbar
        if (
          (valuesOnDragStart.start >= scope.model.start - 2 && valuesOnDragStart.start <= scope.model.start + 2) &&
          (valuesOnDragStart.stop >= scope.model.stop - 2 && valuesOnDragStart.stop <= scope.model.stop + 2)
        ){
          // user didn't drag
          scope.model.start = valuesOnDragStart.start;
          scope.model.stop = valuesOnDragStart.stop;
          scope.displayToolbar(e);
        } else {
          // Let's Figure out where the slot was dropped, and place it in the position of the tick it closest to.
          // So if we drop at 9:10am, then it should move to 9:15am.  If we drop at 9:05, then place at 9:00.
          var slotWidth = scope.model.stop - scope.model.start;
          scope.model.start = round(scope.model.start);
          scope.model.stop = round(scope.model.start + slotWidth);
          if (scope.model.start < scope.min) {
            if (scope.model.stop <= scope.min) {
              scope.model.stop = scope.min + scope.tick;
            }
            scope.model.start = scope.min;
          }
          if (scope.model.stop > scope.max) {
            if (scope.model.start >= scope.max) {
              scope.model.start = scope.max - scope.tick;
            }
            scope.model.stop = scope.max;
          }

          // update messageLabel
          scope.model.messageLabel = messageScheduleUtils.getMessageLabel(scope.model.start, scope.model.stop, scope.tick, scope.model.messageName);

          // finally, Search over all existing slots and see if we are overlapping any.  If we are overlapping any,
          // then we'll need to overwrite the values of the other. Overlapping could be partial or full.  If full, then delete other.
          // If partial, then alter other accordingly.
          splitOverlaps();
        }
      };


      scope.startDrag = function(){
        /*
         * Temporarily removing until we get exceptions implemented.
         * More work to be done here.
         */
        element.addClass('active');

        angular.element(container).addClass('dragging');
        angular.element(container).attr('no-add', true);

        //valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop, cursorX: ev.offsetX, delta: 0};
        valuesOnDragStart = {start: scope.model.start, stop: scope.model.stop};
        /**/
      };


      scope.drag = function(d){
        scope.$apply(function(){
          if (typeof scope.model.stop == 'undefined')
            scope.model.stop = scope.model.start;

          var slotWidth = scope.model.stop - scope.model.start;
          var newSlotPosition = 0;
          var dragPosition = valToPixel(valuesOnDragStart.start) + d;

          // Figure out if we need to scroll the container
          var dataContainerWidth = dataContainer.clientWidth;
          var parentWidth = container.clientWidth;
          var pixelRight = dataContainerWidth + dataContainer.scrollLeft;
          var pixelLeft = dataContainer.scrollLeft;
          var slotCenterPosition = dragPosition + valToPixel((slotWidth / 2));
          var scrollOffset = valToPixel(scope.tick);
          var multiplier = 1;
          //if (d > 0 && slotCenterPosition >= (pixelRight - slotWidth)) {
          if (d > 0 && (dragPosition + valToPixel(slotWidth)) >= pixelRight &&
          dataContainer.scrollLeft < dataContainer.scrollWidth) {
            if (slotCenterPosition >= (pixelRight - (slotWidth / 2))) {
              multiplier = 2;
            } else if (slotCenterPosition >= (pixelRight - (slotWidth / 3))) {
              multiplier = 4;
            }

            dataContainer.scrollLeft += (10 * multiplier);
            newSlotPosition = pixelToVal(dragPosition + (10 * multiplier));
            newDragStart = valuesOnDragStart.start + pixelToVal(10 * multiplier);

            if (newDragStart > scope.max - slotWidth)
              newDragStart = scope.max - slotWidth;
            valuesOnDragStart.start = newDragStart;
          }
          //else if (d < 0 && slotCenterPosition <= (pixelLeft + slotWidth)) {
          else if (d < 0 && dragPosition <= pixelLeft && dataContainer.scrollLeft > 0) {
            if (slotCenterPosition <= (pixelLeft + (slotWidth / 2))) {
              multiplier = 2;
            } else if (slotCenterPosition <= (pixelLeft + (slotWidth / 3))) {
              multiplier = 4;
            }

            dataContainer.scrollLeft -= (10 * multiplier);
            newSlotPosition = pixelToVal(dragPosition - (10 * multiplier));
            newDragStart = valuesOnDragStart.start - pixelToVal(10 * multiplier);

            if (newDragStart < 0) newDragStart = 0;
            valuesOnDragStart.start = newDragStart;
          }
          else {
            newSlotPosition = pixelToVal(dragPosition);
          }

          if (newSlotPosition >= scope.min && newSlotPosition + slotWidth <= scope.max) {
            scope.model.start = newSlotPosition;
            scope.model.stop = newSlotPosition+slotWidth;
          }
          else if (newSlotPosition <= scope.min) {
            scope.model.start = scope.min;
            scope.model.stop = slotWidth;
          }
          else if (newSlotPosition >= scope.max) {
            scope.model.start = scope.max - slotWidth;
            scope.model.stop = scope.max;
          }

          // finally, update scope messageLabel
          scope.model.messageLabel = messageScheduleUtils.getMessageLabel(scope.model.start, scope.model.stop, scope.tick, scope.model.messageName);

        });
      };


      var edit = function() {
        scope.$emit('editEvent',{
          itemid: scope.model.itemid,
          scheduleid: scope.model.scheduleid,
          startTime: scope.model.start,
          day: scope.model.day,
        });
      }

      var deleteSelf = function(){
        scope.$emit('deleteEvent',{
          itemid: scope.model.itemid,
          scheduleid: scope.model.scheduleid,
          startTime: scope.model.start,
          day: scope.model.day,
        });
        angular.element(container).removeClass('dragging');
        angular.element(container).removeClass('slot-hover');
      };


      var splitOverlaps = function(){
        var addedSlots = [];
        messageScheduleUtils.splitOverlaps(scope);
      };

      checkSlotHover = function(e){
        if(element.attr('slots')){
          var rect = container.getBoundingClientRect();
          var pixelOnClick = e.clientX - rect.left;
          var valOnClick = pixelToVal(pixelOnClick);

          var start = round(valOnClick);

          for (var i=0;i<scope.slots.length; i++) {
            if (scope.slots[i].start <= start + 10 && scope.slots[i].start >= start - 10) {
              return true;
            }
          }
          return false;
        }
      }

      // better way to do this with emit maybe.
      $rootScope.$on('triggerMessageSchedulerToolbarAction', function(e, options) {
        if (options.day === scope.model.day && options.id === slotId) {
          if (options.action == 'edit') {
            // edit
            edit();
          } else if (options.action == 'delete') {
            // delete
            deleteSelf();
          }
        }
      });

      /*
       * dateLabel: string
       * day: int
       * is_recurring: bool
       * itemid: int
       * name: string
       * scheduleid: int
       * start: int
       * stop: int
       * timeLabel: string
       */
      scope.displayToolbar = function(e) {
        //var editScreen = $('.message-schedule-edit-screen');
        scope.model.x = e.pageX - e.offsetX;
        scope.model.y = e.pageY - e.offsetY;
        messageSchedulerToolbarService.setOptions(scope.model);
        messageSchedulerToolbarService.show(scope.model.day, slotId);
      }

      element.on('mouseover', function(e){
        angular.element(container).addClass('slot-hover');
        if (checkSlotHover(e)) scope.displayToolbar(e);
      });

      element.on('mouseleave', function(e){
        angular.element(container).removeClass('slot-hover');
      });


      // on init, split overlaps
      splitOverlaps();

    }
  };
}]);

app.directive('messageSchedulerPopupToolbar',
  ['$rootScope', 'messageSchedulerToolbarService', '$timeout',
  function($rootScope, messageSchedulerToolbarService, $timeout) {
    return {
      restrict: 'A',
      templateUrl: 'partials/message_scheduler_popup_toolbar.html',
      scope: {},
      link: function(scope, element, attrs) {
        var isHover = false;
        scope.width = "250px";
        scope.height = "100px";

        scope.setTrigger = function(trigger) {
          messageSchedulerToolbarService.setTrigger(trigger);
          scope.show = false;
        }

        var setHide = function() {
          scope.$apply(function() {
            messageSchedulerToolbarService.hide();
            scope.show = false;
          });
        }

        $rootScope.$on('showMessageSchedulerPopup', function(e, options) {
          scope.$apply(function() {
            scope.left = options.x + 'px';
            scope.top = (options.y - parseInt(scope.height) - 20) + 'px';
            scope.dateLabel = options.dateLabel;
            scope.timeLabel = options.timeLabel;
            scope.day = options.day;
            scope.is_recurring = options.is_recurring;
            scope.name = options.name;

            scope.show = true;
            setTimeout(function() {
              if (!isHover) {
                setHide();
              }
            }, 2000);
          });
          e.stopPropagation();
        });

        element.on('mouseover',function(e) {
          isHover = true;
        });

        element.on('mouseleave',function(e) {
          isHover = false;
          setHide();
        });

      }
    }
  }]
);



(function (app) {
  app.directive('messageScheduleEditUnique', messageScheduleEditUnique);

  messageScheduleEditUnique.$inject = ['$q', '$http', '$log', 'api'];

  function messageScheduleEditUnique($q, $http, $log, api) {
    return {
      require: 'ngModel',
      link: function (scope, elem, attrs, c) {
        scope.$watch(attrs.ngModel, function () {


          c.$asyncValidators.messageScheduleUniqueName = function(modelValue, viewValue) {

            if (!scope.formData.name || scope.formData.name.length < 4) {
              return $q.resolve();
            }

            var def = $q.defer();
            c.$setValidity('unique', true);

            api.checkMessageScheduleNameEdit(scope.formData.name, scope.formData.scheduleid,function(result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            },function(err){
              console.log("An error occured while calling checkMessageScheduleNameEdit when in messageScheduleEditUnique directive.");
              def.reject();
            });

            return def.promise;
          };
        });
      }
    };
  }

})(app);
app.directive('messagepreset', function () {
	return {
		restrict: 'E',
		scope: {
			message: '=',
			index: '=',
			lists: '='
		},
		controller: ['$scope', function($scope) {
			$scope.days = ['Every Day','Monday', 'Tuesday', 'Wednesday', 'Thursday','Friday','Saturday','Sunday'];

			$scope.days = $scope.days.map(function (item,i) {
				return {value:i,name:item};
			})

			$scope.remove = function () {
				$scope.lists.splice($scope.index,1);
			}

		}],
		templateUrl: 'views/messagepreset.html'

	};
});

app.directive('modal', ['$location', '$rootScope', function ($location, $rootScope) {
  return {
    restrict: 'A',
    templateUrl: 'partials/modal.html',
    link: function(scope, element, attrs) {
      var
        overlay = $('.modal-overlay'),
        modal = $('.modal-content');

      scope.showSingle = false;
      scope.showMulti = false;
      scope.showStream = false;

      scope.$on('showLocationStream', function() {
        scope.openModal();
        scope.showSingle = false;
        scope.showMulti = false;
        scope.showStream = true;
        scope.streamHistory = $rootScope.locationStream.songs;
        modal.removeClass('multi');
        modal.removeClass('single');
        modal.addClass('stream');
      });

      scope.checkQueryParams = function() {
        var queries = $location.search();

        if(queries.reg) {
          if(queries.reg == 1) {
            modal.removeClass('multi stream');
            modal.addClass('single');
            scope.showMulti = false;
            scope.showStream = false;
            scope.showSingle = true;
          }

          if(queries.reg == 2) {
            modal.removeClass('single stream');
            modal.addClass('multi');
            scope.showSingle = false;
            scope.showStream = false;
            scope.showMulti = true;
          }

          $(element[0]).addClass('show');
          return;
        }

        scope.showSingle = false;
        scope.showMulti = false;
        scope.showStream = false;
        modal.removeClass('multi');
        modal.removeClass('stream');
        $(element[0]).removeClass('show');
      };

      scope.openModal = function() {
        $(element[0]).removeClass('hidden');
        $(element[0]).addClass('show');
      };

      scope.cancel = function($event) {
        $event.stopPropagation();
        $(element[0]).removeClass('show');
        $location.url($location.path());
      };

      scope.checkQueryParams();
    }
  };
}]);

app.directive('validateMultipleEmails', function () {
  var EMAIL_REGEXP = /^[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\.[a-zA-Z]{2,24}$/i;

  return {
    restrict: 'A',
    require: 'ngModel',
    link: multipleEmailsPostLink
  };

  function isValidEmail(email) {
    return EMAIL_REGEXP.test(email.trim());
  }

  function multipleEmailsPostLink(scope, elem, attrs, modelCtrl) {
    modelCtrl.$formatters.push(multipleEmailsValidator);
    modelCtrl.$parsers.push(multipleEmailsValidator);

    function multipleEmailsValidator(value) {
      return validateAll(modelCtrl, 'validateMultipleEmails', value);
    }
  }

  function validateAll(ctrl, validatorName, value) {
    var validity = ctrl.$isEmpty(value) || value.split(/[,;]/).every(isValidEmail);

    ctrl.$setValidity(validatorName, validity);

    return validity ? value : undefined;
  }
});
app.directive('onlyDigits', function () {
  return {
    require: 'ngModel',
    restrict: 'A',
    scope: {
      step: '=',
      decimal: '='
    },
    link: function (scope, element, attr, ctrl) {
      function inputValue(val) {
        if (val) {
          if (typeof val === 'string') {
            if (attr.decimal) {
              var digits = val.replace(/[^0-9.]/g, '');

              if (digits.split('.').length > 2) {
                digits = digits.substring(0, digits.length - 1);
              }
            } else {
              var digits = val.replace(/[^0-9]/g, '');
            }
          } else digits = val;

          if (+attr.min && +digits < +attr.min) digits = attr.min;
          if (+attr.max && +digits > +attr.max) digits = attr.max;

          if (digits !== val) {
            ctrl.$setViewValue(digits);
            ctrl.$render();
          }
          return +attr.digits;
        }
        return undefined;
      }
      ctrl.$parsers.push(inputValue);
    }
  };
});

app.directive('ccmOnLoad', onLoad);

onLoad.$inject = ['$parse'];

function onLoad($parse) {
  return {
    restrict: 'A',
    compile: compile
  };

  function compile(element, attrs) {
    var callback = $parse(attrs.ccmOnLoad);

    return function (scope, element) {
      element.on('load', onLoadEventHandler);

      scope.$on('$destroy', function () {
        element.off('load', onLoadEventHandler);
      });

      function onLoadEventHandler(e) {
        scope.$apply(function (scope) {
          callback(scope, { $event: e });
        });
      }
    };
  }
}

app.directive('playButton', function() {
  return {
    restrict: 'EA',
    scope: {},
    template: '<i class="fa fa-play icon"></i>',
    link: function(scope, element, attrs) {
      scope.$on('resumeMedia', function() {
        if ($('.play-preview').find('.icon').hasClass('fa-pause')) {
          $('.play-preview').find('.icon').removeClass('fa-pause');
          $('.play-preview').find('.icon').addClass('fa-play');
        }
      });

      element.bind('click', function() {
        var icon = $(element).find('.icon')[0];
        var icons = $('.play-preview').find('.icon');

        if ($(icon).hasClass('fa-play')) {
          $(icons).removeClass('fa-pause');
          $(icons).addClass('fa-play');
          $(icon).removeClass('fa-play');
          $(icon).addClass('fa-pause');
        } else {
          $(icon).removeClass('fa-pause');
          $(icon).addClass('fa-play');
        }
      });
    }
  };
});

var ReadyState = {
  Uninitialized: 0,
  Loading: 1,
  Error: 2,
  Loaded: 3
};

var PlayState = {
  Stopped: 0,
  Playing: 1
};

function MediaWrapper(scope, media) {
  var mediaWrap = this;
  this.id = media.id;
  this.mediaid = media.mediaid;
  this.messageid = media.messageid;
  this.messagepresetid = media.messagepresetid;
  this.message_preset_detail_id = media.message_preset_detail_id;
  this.playlistid = media.playlistid;
  this.name = media.name;
  this.description = media.description;
  this.artist = media.artist;
  this.station = media.station;
  this.mediaType = media.mediaType;
  this.mediaUrl = media.mediaUrl;
  this.imageUrl = media.imageUrl;
  this.mix = media.mix;
  this.daypart = media.daypart;
  this.music_type = media.music_type;
  this.extra = media.extra;
  this.trackIndex = media.trackIndex;
  this.trackToken = media.trackToken;
  this.stationId = media.stationId;
  this.feedbackValue = media.feedbackValue;

  var autoLoad = false;

  if (BrowserDetect.browser === 'Safari') {
    autoLoad = true;
  }

  this.scope = scope;
  this.sound = soundManager.createSound({
    id: media.mediaType + '_' + media.id,
    url: media.mediaUrl,
    autoLoad: autoLoad,
    stream: true,
    volume: scope.playerVolume,
    onload: function(success) {
      if (!success) {
        scope.showError('Error streaming media');
        return scope.playNextMedia();
      }

      mediaWrap.duration = this.duration;
      scope.safeApply();
    },
    onplay: function() {

    },
    onfinish: function() {
      if (scope.broadcast) {
        scope.broadcast('playFinished', {id: media.id, mediaType: media.mediaType});
      } else if (scope.$broadcast) {
        scope.$broadcast('playFinished', {id: media.id, mediaType: media.mediaType});
      }
      scope.playNextMedia();
    },
    // Bug in Soundmanager code is causing "Uncaught TypeError: Cannot read property '_onerror' of null" when this is called.
    // Was fixed in July 2017 but developer hasn't released it as of April 2018.
    // This function could be useful since it provides more detail than just success=false from onload().
    onerror: function(code, description) {
      console.log('Sound error: ' + description + '(' + code + ')');
      scope.showError(description + '(' + code + ')');
      return scope.playNextMedia();
    },
    // This could probably be removed. Soundmanager2 doc says:
    // "Fires at least once per sound play instance when Flash 9 encounters a security error when trying to call computeSpectrum() internally."
    ondataerror: function() {
      scope.showError('Error streaming media');
      return scope.playNextMedia();
    }
  });
}

MediaWrapper.prototype.details = function() {
  return {
    id: this.id,
    name: this.name,
    description: this.description,
    artist: this.artist,
    station: this.station,
    mediaType: this.mediaType,
    mediaUrl: this.mediaUrl,
    imageUrl: this.imageUrl,
    playState: this.sound.playState,
    readyState: this.sound.readyState,
    duration: this.sound.duration,
    position: this.sound.position,
    loaded: this.sound.loaded,
    paused: this.sound.paused
  };
};

MediaWrapper.prototype.play = function() {
  this.sound.play();
};

MediaWrapper.prototype.pause = function() {
  this.sound.pause();
};

MediaWrapper.prototype.resume = function() {
  this.sound.resume();
};

MediaWrapper.prototype.fadeTo = function(toVol, dur, callback) {
  toVol = toVol || 0;
  dur = dur || 1000;
  callback = typeof callback == 'function' ? callback : function(){};

  var sound = this.sound;
  var currVol = sound.volume;
  var interval = dur / Math.abs(currVol - toVol);
  var i = setInterval(function() {
  currVol = currVol > toVol ? currVol - 1 : currVol + 1;
  sound.setVolume(currVol);
  if (currVol == toVol) {
    callback();
    clearInterval(i);
    i = null;
  }
  }, interval);
};

MediaWrapper.prototype.getState = function() {
  var state = '';

  switch(this.sound.readyState) {
    case ReadyState.Uninitialized:
    case ReadyState.Loading:
      state = 'buffering';
      break;
    case ReadyState.Error:
      state = 'error';
      break;
    case ReadyState.Loaded:
      break;
    default:
      if (this.sound.playState === PlayState.Playing) {
        state = 'playing';
      } else {
        state = 'buffering';
      }
      break;
  }

  return state;
};

MediaWrapper.prototype.isBuffering = function() {
  return this.sound.readyState === ReadyState.Uninitialized
    || this.sound.readyState === ReadyState.Loading
    || this.sound.playState === PlayState.Stopped;
};

MediaWrapper.prototype.isActive = function() {
  return this.sound.readyState === ReadyState.Loaded && this.sound.playState === PlayState.Playing;
};

MediaWrapper.prototype.isPaused = function() {
  return this.sound.paused;
};

MediaWrapper.prototype.togglePause = function() {
  if (this.sound.paused && this.scope.interruptMedia) {
    console.log('Cleaning up interrupt media...')
    this.scope.interruptMedia.cleanup();
    delete this.scope.interruptMedia;
    this.sound.setVolume(this.scope.playerVolume);
  }

  var scope = this;
  try {
    this.sound.togglePause();
  } catch (err) {
    console.error(err);

    setTimeout(function () {
      scope.sound.togglePause();
    }, 100);
  }
};

MediaWrapper.prototype.cleanup = function() {
  try {
    this.sound.destruct();
  }
  catch (ex) {
    console.error('MediaWrapper.cleanup: ', ex);
  }
};

app.directive('player', playerDirectiveCtrl);

playerDirectiveCtrl.$inject = ['$window', '$location', '$rootScope', '$timeout', 'intercom', 'requirements', 'subscriptionInfo', 'awsService', '$stateParams', 'scheduleHandler', 'deviceCommand', 'playerService', 'streamHistoryModal', 'playerConfirmationModal', 'playerTakeoverNotification', 'streamUpdateService', 'musicSelection', 'messageSelection', 'userInfo', 'removeSongModal', 'playlistCategoryService'];

function playerDirectiveCtrl ($window, $location, $rootScope, $timeout, intercom, requirements, subscriptionInfo, awsService, $stateParams, scheduleHandler, deviceCommand, playerService, streamHistoryModal, playerConfirmationModal, playerTakeoverNotification, streamUpdateService, musicSelection, messageSelection, userInfo, removeSongModal, playlistCategoryService) {
  return {
    restrict: 'E',
    scope: false,
    templateUrl: 'views/player.html',
    link: function(scope, element, attrs) {
      //--------------------------------
      // private properties
      //--------------------------------
      var firstTime = true;
      var permissions = scope.api.userObject.permissions;
      var playerState = 'inactive';
      var isAutologin = $stateParams.accesskey && $stateParams.accesskey.length > 0;
      var remoteDeviceState = {};
      var remoteMediaTimer = null;
      var remoteDBState = {};

      // For throttling fast media requests
      var lastMediaRequest = new Date();
      var fastRequests = 0;

      // TODO remove for device state

      // skip control
      var tooManyAtOnce = 7; // allow fast manual skips, or a small transient burst
      var minBackToBackTime = 3000; // milliseconds
      var overloadRetryMinutes = 3; // We want to resume automatically if the issue clears up
      var overloadRetryTimer = null;

      //--------------------------------
      // public properties
      //--------------------------------
      scope.autoLogin = permissions.user.auto_login;
      scope.autoPlayStatus = {
        canAutoPlay: false,
        playabilityInitialized: false
      };

      scope.canPauseMedia = permissions.user.can_pause;
      scope.canPlayMusic = permissions.user.can_play_music;
      scope.canRemoveSong = permissions.user.can_downvote;
      scope.canSkipMedia = permissions.user.can_skip;

      scope.controlMode = playerService.getMode();
      scope.currentMedia = null;

      scope.deviceDetails = {};
      scope.errorMessage = '';
      scope.getNextTimeout = null;
      scope.heroImage = {};
      scope.interruptMedia = null;

      scope.isMobile = false;
      scope.isPlayingMode = playerService.isPlayingMode;
      scope.isRemoteControlMode = playerService.isRemoteControlMode;

      scope.likeBtnTitle = 'Like song';
      scope.mobileDownloadUrl = "";
      scope.nextMedia = null;
      scope.noMediaSet = true;
      scope.remoteOnly = false;
      scope.removeBtnTitle = "Remove song";
      scope.requestInProgress = false;
      scope.selectedStream = streamUpdateService.getSelectedStream();
      scope.selectStreamIcon = '';
      scope.selectStreamLabel = 'Select Zone';
      scope.showStreamList = false;
      scope.skipLimit = 600;
      scope.skips = {};
      scope.toggleEnabled = false;
      scope.sqsService = null;
      scope.trackIndex = 0;

      //----------------------------
      // private method list
      //----------------------------
      // adjustVolume               (stream, value)
      // clearOverload              ()
      // createInterruptMedia       (data)
      // deviceCommandCallback      (message)
      // getMusicName               (music_id, music_type)
      // getMediaPlayingForStream   (callback)
      // getMediaPlayingFromDb      (streamid, callback)
      // getStreamListData          (callback)
      // handleAdjustVolume         (message)
      // handleSetVolume            (message)
      // incrementSkipCount         (streamid, showMessage)
      // isRequestOverload          ()
      // isStreamAvailable          (stream)
      // setEnableBlink             ()
      // setMediaInfo               (media)
      // setRemoteControlMediaInfo  ()
      // setVolume                  (toVolume)
      // startPlayer                ()
      // sendDeviceUpdate           ()
      // streamDataCallback         ()
      // switchToPlayingMode        ()
      // switchToRemoteControlMode  ()
      // testForAutoPlay            (callback)
      // updateSelectedStream       (stream, callback)

      //----------------------------
      // general public methods
      //----------------------------
      scope.activatePlayer = activatePlayer;              // (stream, callback)
      scope.cannotLikeCurrentMedia = cannotLikeCurrentMedia;      // ()
      scope.cannotRemoveCurrentMedia = cannotRemoveCurrentMedia;  // ()
      scope.closeMediaBar = closeMediaBar;                // ()
      scope.isPlayerState = isPlayerState;                // (state)
      scope.launchMediaBar = launchMediaBar;              // ()
      scope.playNextMedia = playNextMedia;                // ()
      scope.pushMedia = pushMedia;                        // (data)
      scope.queueMedia = queueMedia;                      // ()
      scope.registerDevice = registerDevice;              //(callback, errorcallback)
      scope.removeCurrentMedia = removeCurrentMedia;      // ()
      scope.setCurrentMedia = setCurrentMedia;            // (media)
      scope.setInactive = setInactive;                    // (newState)
      scope.setNextMedia = setNextMedia;                  // (media)
      scope.setPlayerState = setPlayerState;              // (state)

      // public methods related to player controls
      scope.canBePaused = canBePaused;                    // ()
      scope.canBePlayed = canBePlayed;                    // ()
      scope.closeMoreInfo = closeMoreInfo;                // ()
      scope.closeStreamListPopup = closeStreamListPopup;  // ()
      scope.isAtSkipLimit = isAtSkipLimit;                // ()
      scope.lowerVolume = lowerVolume;                    // (stream)
      scope.noDevice = noDevice;                          // ()
      scope.openMoreInfo = openMoreInfo;                  // (evt, move)
      scope.raiseVolume = raiseVolume;                    // (stream)
      scope.remotePause = remotePause;                    // ()
      scope.remotePlay = remotePlay;                      // ()
      scope.removeSong = removeSong;                      // ()
      scope.selectStream = selectStream;                  // (stream)
      scope.showHistory = showHistory;                    // (evt)
      scope.showVolumeControl = showVolumeControl;        // (evt)
      scope.skipSong = skipSong;                          // ()
      scope.switchControlMode = switchControlMode;        // (evt)
      scope.toggleMedia = toggleMedia;                    // ()
      scope.toggleSongLike = toggleSongLike;              // ()
      scope.toggleStreamListPopup = toggleStreamListPopup;// ()
      scope.$on('$destroy', function() {
        scope.sqsService.interruptPolling(); // stop polling for SQS messages
        scope.setInactive(); // kill Media player
        streamUpdateService.setSelectedStream(null); // reset selected stream
        playerService.setRemoteControlMode(); // reset player mode
        if (remoteMediaTimer) {
          $timeout.cancel(remoteMediaTimer);
        }
      });
      //--------------------------------
      // Initialization
      //--------------------------------

      init();

      //--------------------------------
      // define methods
      //--------------------------------

      function activatePlayer (stream, callback) {
        userInfo.getUserPerms(function(userPerms) {
          if (!userPerms.canPlayMusic) {
            return;
          }

          var eventHandled = false;

          if (stream) {
            updateSelectedStream(stream);
          }
          else if (!scope.selectedStream || !scope.selectedStream.streamid) {
            for (var i=0; i<scope.streams.length; i++) {
              if (scope.streams[i].deviceid === scope.me.device_id) stream = scope.streams[i];
            }
            if (!stream) stream = scope.streams[0];
            updateSelectedStream(stream);
          }
          else {
            stream = scope.selectedStream;
          }

          if (!scope.me.streamid) {
            scope.me.streamid = stream.streamid;
          }

          testForAutoPlay(function() {
            scope.setInactive();
            startPlayer();
            if (typeof callback === 'function') callback();
            eventHandled = true;
          });
        });
      }

      function adjustVolume (stream, value) {
        var userid = scope.api.userObject.user.userid,
            custid = scope.api.userObject.user.custid,
            deviceid = stream.deviceid;
        var command = 'adjust volume ' + value;

        awsService.getQueueInfo(userid, deviceid)
          .then(function (data) {
            awsService.sendCommand(data.QueueUrl, command);
          })
          .catch(angular.noop);

        var intercomData = {
          source: 'mobile tune player bar',
          custid: custid,
          localDeviceId: scope.me.device_id,
          localUserId: userid,
          streamingDeviceId: deviceid,
          target: scope.me.device_id === deviceid ? 'local' : 'remote',
          volumeChange: (value >= 0 ? '+' : '') + (value * 100) + '%'
        }
        intercom.sendEvent("Change volume (relative)", intercomData);
      }

      function cannotLikeCurrentMedia() {
        return ((scope.currentMedia && scope.currentMedia.mediaType !== 'song') && scope.isPlayingMode())
        || (scope.isRemoteControlMode() && (
          (remoteDeviceState.id && remoteDeviceState.media.type !== 'song' )
          || (remoteDBState.mediaid && remoteDBState.mediaType !== 'song')
        ))
      || !scope.selectedStream || !scope.selectedStream.streamid;
      }

      function cannotRemoveCurrentMedia() {
        return ((scope.currentMedia && scope.currentMedia.mediaType !== 'song') && scope.isPlayingMode())
          || (scope.isRemoteControlMode() && (
            (remoteDeviceState.id && remoteDeviceState.media.type !== 'song' )
            || (remoteDBState.mediaid && remoteDBState.mediaType !== 'song')
          ))
        || !scope.canRemoveSong || !scope.selectedStream || !scope.selectedStream.streamid
      }

      function clearOverload() {
        scope.errorMessage = '';
        fastRequests = 0;
        if (overloadRetryTimer) {
          clearTimeout(overloadRetryTimer);
          overloadRetryTimer = null;
        }
      }

      function closeMediaBar () {
        $rootScope.mobileMediaToolbarOpen = false;

        // Notify the App that the player bar has closed, so that it recalculates the height
        // of the panel
        $timeout(function(){
          $rootScope.$broadcast('playerBarReady', true);
        }, 150);
      }

      function deviceCommandCallback(message) {
        if (message.successMessage) {
          scope.showSuccess(message.successMessage);
        }
        if (message.errMessage) {
          scope.showWarning(message.errMessage);
        }
      }

      function getMusicName (music_id, music_type) {
        if (!scope.api.musicSelection)
          return '';

        var music = null;
        var idname = '';
        if ('dayparting' == music_type) {
          music = scope.api.musicSelection.dayparting;
          idname = 'daypartingid';
        }
        else if ('mix' == music_type) {
          music = scope.api.musicSelection.mix;
          idname = 'mixid';
        }
        else {
          music = scope.api.musicSelection.public;
          idname = 'playlistid';
        }
        var selection = null;
        for (var i=0; i < music.length; i++) {
          if (music[i][idname] == music_id) {
            selection = music[i];
            break;
          }
        }

        if (selection) return selection.name;
        else return '';
      }

      function getMediaPlayingForStream(callback) {
        // TODO May need to fetch stream details first, to get the current deviceid
        if (scope.selectedStream && scope.selectedStream.deviceid) {
          scope.api.getDeviceState([scope.selectedStream.deviceid])
            .then(function (results) {
              if (results.DeviceState.length > 0 && moment().diff(moment(results.DeviceState[0].lastUpdate), 'minutes') <= 10) {
                remoteDeviceState = results.DeviceState[0];
                var messageInfo = messageSelection.getSelection();
                var mediaInfo = {
                  // Mimic the structure returned by api, at least for now.
                  musicPollRate: 15000, // do it more often if we're getting data from Device State
                  streamingMedia: {
                    deviceid: remoteDeviceState.id,
                    devicetype: remoteDeviceState.device.type,
                    streamid: remoteDeviceState.streamid,
                    mediaid: remoteDeviceState.media.mediaid,
                    media_name: remoteDeviceState.media.title,
                    media_station: remoteDeviceState.media.station,
                    mediaType: remoteDeviceState.media.type,
                    artist: remoteDeviceState.media.artist,
                    imageUrl: remoteDeviceState.media.imageUrl ? remoteDeviceState.media.imageUrl : '',
                    music_type: remoteDeviceState.media.playlistType,
                    music_selection: remoteDeviceState.media.playlist,
                    message_preset: messageInfo.message_preset,
                    schedule_id: messageInfo.schedule_id,
                    preset_name: messageInfo.message_preset ? messageSelection.getMessagePreset(messageInfo.message_preset).name : '',
                    schedule_name: messageInfo.schedule_id ? messageSelection.getMessageSchedule(messageInfo.schedule_id).name : ''
                  }
                };
                // Don't send the media info if it's not considered active.
                // TODO this can come back once we've removed those flaky websockets.
                //var howOld = moment().diff(moment(remoteDeviceState.lastUpdate), 'minutes');
                //if (howOld > 10) mediaInfo.streamingMedia = {};

                remoteDBState = {};

                if (typeof callback == 'function') {
                  callback(mediaInfo);
                }
              } else {
                // This device is not in DeviceState or is stale, fall back to server
                getMediaPlayingFromDb(scope.selectedStream.streamid, callback);
                remoteDeviceState = {};
              }
            })
            .catch(function (err) {
              getMediaPlayingFromDb(scope.selectedStream.streamid, callback);
              remoteDeviceState = {};
            });
        } else {
          // If there's no deviceid, this zone isn't streaming.
          if (typeof callback == 'function') {
            callback({ streamingMedia: {} });
          }
        }
      }

      function updateMessageSelection() {
          var messageInfo = messageSelection.getSelection();
          scope.mediaInfo.preset_name = messageInfo.message_preset ? messageSelection.getMessagePreset(messageInfo.message_preset).name : '';
          scope.mediaInfo.schedule_name = messageInfo.schedule_id ? messageSelection.getMessageSchedule(messageInfo.schedule_id).name : '';
      }
      function fetchPresetAndUpdateMessageSelection(presetId) {
        messageSelection.getMessagePresetFromAPI(presetId, function() {
          updateMessageSelection();
        })
      }
      function fetchScheduleAndUpdateMessageSelection(scheduleId) {
        messageSelection.getMessageScheduleFromAPI(scheduleId, function() {
          updateMessageSelection();
        })
      }
      function getMediaPlayingFromDb(streamid, callback) {
        scope.api.getMediaPlayingForStream(streamid, function(err, mediaInfo) {
          if (mediaInfo && mediaInfo.streamingMedia) {
            if (mediaInfo.streamingMedia.media_type === 'message') {
              mediaInfo.streamingMedia.mediaType = 'message';
              mediaInfo.streamingMedia.name = mediaInfo.streamingMedia.message_name;
            } else {
              mediaInfo.streamingMedia.imageUrl = mediaInfo.streamingMedia.thumb_url;
              mediaInfo.streamingMedia.mediaType = 'song';
              mediaInfo.streamingMedia.name = mediaInfo.streamingMedia.song_name;
            }

            remoteDBState.artist = mediaInfo.streamingMedia.artist;
            remoteDBState.mediaid = mediaInfo.streamingMedia.mediaid;
            remoteDBState.mediaType = mediaInfo.streamingMedia.mediaType;
            remoteDBState.name = mediaInfo.streamingMedia.media_name;
            remoteDBState.stationid = mediaInfo.streamingMedia.media_station_id;
            remoteDBState.station = mediaInfo.streamingMedia.media_station;

            if (typeof callback == 'function') callback(mediaInfo);
          }
          else if (err) {
            if (typeof callback == 'function') callback({ streamingMedia: {} });
          }
          else if (typeof callback == 'function') callback({ streamingMedia: {} });
        });
      }

      function getStreamListData (callback) {
        scope.api.getStreamsForUser(scope.me.user.userid, function(userStreams) {
          scope.streams = userStreams.streams;

          for (var i = 0; i < scope.streams.length; i++) {
            // determine if this is the first time user logged in (no device registered)
            if (scope.streams[i].deviceid) firstTime = false;
            var stream = scope.streams[i];

            // setup icons for list popup
            if (stream.devicetype === null) stream.deviceicon = '';
            else if (stream.devicetype === 'pc') stream.deviceicon = 'fa-laptop';
            else if (stream.devicetype.search(/mobile/i) > -1) stream.deviceicon = 'fa-mobile';
            else if (stream.devicetype === 'sonos') stream.deviceicon = 'fa-cube';
            else stream.deviceicon = 'fa-hdd-o'; // CloudBox and other devices

            // update selected Stream in case values have changed
            if (scope.selectedStream && stream.streamid === scope.selectedStream.streamid) {
              updateSelectedStream(stream);
            }
          }

          if (!scope.selectedStream && !isAutologin) {
            // No stream selected, see if this device is assigned to one.
            if (scope.me.device_id) {
              // Using filter since IE 11 doesn't support Array.find()
              var assignedStreams = scope.streams.filter(function(item) { return item.deviceid == scope.me.device_id; });
              if (assignedStreams.length > 0) {
                updateSelectedStream(assignedStreams[0]);
              }
            }
            if (!scope.selectedStream) {
              // Couldn't match on assigned device, see if there is a stream not in use.
              var firstAvailableStreams = scope.streams.filter(function(item) { return item.deviceid == null; });
              if (firstAvailableStreams.length > 0) {
                updateSelectedStream(firstAvailableStreams[0]);
              }
              else {
                // Still no selected stream
                if (playerService.isRemoteControlMode()) {
                  // Remote mode, select the first stream in the list.
                  // Don't want to do this in Playing mode, since it might be autologin still getting started.
                  updateSelectedStream(scope.streams[0]);
                }
              }
            }
          }

          if (callback && typeof(callback) === 'function') callback();
        }, function(err) {
          if (isAutologin) {
            scope.initialAutoLoginState = true;
          }
        });
      }

      function handleAdjustVolume (message) {
        // Parse volume from message, convert to 0-100 scale.
        var playerVolume = scope.playerVolume;
        var tokens = message.split(' ');
        if (tokens[0] == 'adjust' && tokens[1] == 'volume') {
          if (/^(-?(?:0[.][0-9]{1,3}|1|1[.]00?0?))$/.test(tokens[2])) {
            var adjust = parseFloat(tokens[2]) * 100;
            playerVolume += adjust;
            if (playerVolume > 100) playerVolume = 100;
            else if (playerVolume < 0) playerVolume = 0;
            setVolume(playerVolume);
          }
        }
      }

      function handleSetVolume (message) {
        // Parse volume from message, convert to 0-100 scale.
        tokens = message.split('=');
        if (tokens[1]) {
          intVol = parseFloat(tokens[1]) * 100;
          if (intVol < 0 || intVol > 100) {
            return;
          }
          setVolume(intVol);
        }
      }

      function incrementSkipCount(streamid, showMessage) {
        if (!scope.skips[streamid]) {
          scope.skips[streamid] = 1;
        }
        else {
          if (scope.skips[streamid] < scope.skipLimit)
            scope.skips[streamid]++;
          if (scope.skips[streamid] >= scope.skipLimit) {
            if (showMessage)
              scope.showSuccess('You have reached the skip limit for this device. You will receive an additional skip every 10 minutes.');
            return true;
          }
        }
        return false;
      }

      // initialization
      function init() {
        var playerVolume = localStorage.getItem('ccm_playerVolume');
        var cssBreakPoint = ($window.innerWidth < 400) ? 0 : ($window.innerWidth < 900) ? 1 : 2;
        var trialExpired = false;

        // Handle music selection change
        musicSelection.setNotifyCallback(function(when) {
          scope.skips[scope.selectedStream.streamid] = 0;
          scope.selectedStream = streamUpdateService.getSelectedStream();
          if (!scope.autoLogin) {
            streamUpdateService.setSelectedStream(scope.selectedStream);
          }
          scope.$emit('setNextMedia', null);
          scope.$emit('resetSkipCount');
          if (playerService.isPlayingMode()) {
            if (when == 'now') {
              scope.$emit('playNextMedia');
            }
          }
          else if (playerService.isRemoteControlMode) {
            scope.setPlayerState('remotecontrol');
          }
        });

        if (BrowserDetect.mobile) {
          scope.isMobile = true;
          if (BrowserDetect.isMobile.Android()) {
            scope.isAndroid = true;
            scope.mobileDownloadUrl = "https://play.google.com/store/apps/details?id=com.cloudcovermusic.player";
          }
          else if (BrowserDetect.isMobile.iOS()) {
            scope.isIOS = true;
            scope.mobileDownloadUrl = "https://itunes.apple.com/us/app/cloud-cover-music/id1163777405";
          }
        }

        // Prevent streaming only if the user has Account Owner permission
        // and not all of the requirements are fulfilled
        if (permissions.account && permissions.account.owner && !requirements.fulfilled) {
          scope.remoteOnly = true;
        }

        // Enable another skip every 10 minutes
        setInterval(function() {
          if (scope.skips[scope.selectedStream.streamid] > 0) {
            scope.skips[scope.selectedStream.streamid]--;
          }
        }, 600000);

        if (playerVolume) {
          scope.playerVolume = parseInt(playerVolume);
        }
        // TODO: Decide on default volume for player if volume has never been set
        else {
          setVolume(100);
        }

        if (scope.api.userObject.subscription && scope.api.userObject.subscription.state === 'trial') {
          trialExpired = subscriptionInfo.getTrialStatus();
        }

        //  9-8-17 RK: Only do these if not autologin and not an expired trial
        if (!trialExpired && !isAutologin) {
          scope.api.getDevices(scope.api.userObject.user.userid, function(result) {
            scope.api.getUserCloudBox(scope.api.userObject.user.userid, function(cloudboxResult) {
              // If the user does not have any devices or cloudboxes, or /me didn't return a deviceid,
              // then register (create) this device.
              var totalDevices = result.meta.count + cloudboxResult.length;
              if (totalDevices < 1 || !scope.me.device_id) {
                scope.api.registerDevice(function(err, devResult) {
                  if (err) {
                    return;
                  }

                  scope.me.device_id = scope.api.userObject.device_id = devResult.device.deviceid;

                  // Only start playing automatically if the user has no devices
                  if (totalDevices < 1) {
                    switchToPlayingMode();

                    // 2022-02-10 rporczak -- These lines taken from streamDataCallback, which
                    //  is no longer called in this code branch, as executing that in
                    //  parallel to getting & registering devices was problematic.
                    scope.toggleEnabled = true;
                    $rootScope.$broadcast('playerBarReady', true);
                  } else {
                    // 2022-01-31 rporczak -- Generally, this callback is used in getStreamListData().
                    //  However, this causes a race condition in which this callback is called
                    //  and determines Remote Mode before the rest of the device initialization
                    //  can complete, which, in some cases, will decide to autoplay. Deferring
                    //  this call until after that determination.
                    streamDataCallback();
                  }
                });
              } else {
                // 2022-01-31 rporczak -- Generally, this callback is used in getStreamListData().
                //  However, this causes a race condition in which this callback is called
                //  and determines Remote Mode before the rest of the device initialization
                //  can complete, which, in some cases, will decide to autoplay. Deferring
                //  this call until after that determination.
                streamDataCallback();
              }
            });
          });
        }

        getStreamListData();

        //----------------------------
        // handle various events
        //----------------------------
        scope.$on('setNextMedia', function(event, arg) { scope.setNextMedia(arg); });
        scope.$on('playNextMedia', function(event) { scope.playNextMedia(); });
        scope.$on('resetSkipCount', function(event, arg) { scope.skips[scope.selectedStream.streamid] = 0; });
        scope.$on('playNow', function(event, arg) {
          if (scope.nextMedia) {
            intercom.sendEvent('Skip media', {
              "name": scope.nextMedia.name,
              "artist": scope.nextMedia.artist,
              "station": scope.nextMedia.station,
              "description": scope.nextMedia.description
            });
          }
          scope.playNextMedia();
        });

        scope.$on('registerDevice', function(event, arg) {
          scope.registerDevice();
        });

        scope.$on('setPlayerVolume', function(obj, volume) {
          setVolume(100 * parseFloat(volume));
        });

        scope.$on('getSelectedStream', function(obj, callback) {
          callback(scope.selectedStream);
        });

        // Requested by Key West Technology
        $(window).on('message', function(evt) {
          var message = evt.originalEvent.data;
          if (/^set volume/.test(message)) {
            handleSetVolume(message);
          }
          if (/^adjust volume/.test(message)) {
            handleAdjustVolume(message);
          }
        });

        //----------------------------
        // Watch for various changes
        //----------------------------

        // when mode switches between local and remote play mode, update scope.controlMode
        scope.$watch(function() {
          return playerService.getMode();
        }, function(newMode, oldMode) {
          if (newMode !== scope.controlMode) {
            scope.controlMode = newMode;
          }
        });

        // update our local stream list when we get notice of streamlist data change
        scope.$watch(function() {
          return streamUpdateService.checkStreamsUpdateFlag();
        }, function(updatedStream, oldVal) {
          if (updatedStream && playerService.isPlayingMode()) {
            getStreamListData();
            streamUpdateService.clearStreamsUpdateFlag();
          }
        });

        scope.$watch('autoLoginActivation.isActivated', function (newValue) {
          if (!newValue) {
            return;
          }

          if (scope.autoLoginActivation && scope.autoLoginActivation.data) {
            var autoLoginData = scope.autoLoginActivation.data;

            scope.initialAutoLoginState = true;
            scope.me.device_id = autoLoginData.device_id;
            getStreamListData(function () {
              var streams = scope.streams.filter(function (item) { return item.streamid === autoLoginData.streamid; });
              if (streams.length > 0) {
                scope.activatePlayer(streams[0], function () {
                  scope.queueMedia();
                });
              }
            });
          }
        });

        scope.$watch('me.device_id', function() {
          // 09-14-17 RK: need to wait until we have a valid device_id before subscribing to updates
          if (scope.me.device_id) {
            // Use presence of device_id as a proxy for having an authorized user who can make this request.
            scheduleHandler.processMessageSchedule(scope.pushMedia);

            awsService.getQueueInfo(scope.me.user.userid, scope.me.device_id)
              .then(function (result) {
                var queueUrl = result.QueueUrl;
                var region = result.region;
                var cognitoRegion = result.cognitoRegion;
                var identityPoolId = result.identityPoolId;

                awsService.configureAws(region, cognitoRegion, identityPoolId, function (sqsService) {
                  scope.sqsService = sqsService;
                  awsService.purgeSqsQueue(queueUrl);
                  awsService.getSqsMessages(queueUrl, sqsService, function(message) {
                    if (message && scope.selectedStream) {
                      var messageSelectionData = messageSelection.getSelection();
                      scheduleHandler.processSqsMessage(message, scope.selectedStream.streamid, scope.me.user.userid, messageSelectionData.schedule_id, scope, function (scheduleid) {
                        if (['music-selection-changed', 'message-preset-set', 'message-preset-cleared', 'schedule-set', 'schedule-cleared', 'stream-device-assigned'].indexOf(message.type) >= 0 ) {
                          $rootScope.$broadcast(message.type, message);
                        }

                        if (['message-preset-set', 'message-preset-cleared'].indexOf(message.type) >= 0) {
                          if (message.streams && (message.streams).indexOf(scope.selectedStream.streamid) >= 0) {
                            var newStreamData = {
                              messagePreset: message.presetid > -1 ? message.presetid : null
                            };
                            messageSelection.setSelection(newStreamData);
                            if ('undefined' !== typeof message.presetid) {
                              scope.selectedStream.message_preset = message.presetid;
                            }
                            streamUpdateService.setSelectedStream(scope.selectedStream);
                            streamUpdateService.setStreamsUpdateFlag();
                          }
                        }

                        if (['message-preset-set', 'message-preset-cleared', 'schedule-set', 'schedule-cleared'].indexOf(message.type) >= 0) {
                          updateMessageSelection();
                        }
                        // For Player's current selection to display the updated preset, fetch the modified preset details
                        if (message.type === 'message-preset-changed') {
                          fetchPresetAndUpdateMessageSelection(message.presetid);
                        }
                        // For Player's current selection to display the updated schedule, fetch the modified schedule details
                        if (message.type === 'schedule-changed') {
                          fetchScheduleAndUpdateMessageSelection(message.scheduleid);
                        }

                        if (message.type === 'music-selection-changed' && message.streams && message.streams.indexOf(scope.selectedStream.streamid) > -1) {
                          musicSelection.updateSelectionInfo(message.music_type, message.music_id, message.when);
                          scope.skips[scope.selectedStream.streamid] = 0;
                          // If this is my device, update its state
                          // TODO will box and mobile do the same?
                          if (scope.selectedStream.deviceid === scope.me.device_id) sendDeviceUpdate();
                        }
                        else if (message.type === 'stream-device-assigned') {
                          if (scope.selectedStream.streamid === message.streamid && scope.selectedStream.deviceid !== message.deviceid) {
                            scope.selectedStream.deviceid = message.deviceid;

                            // 2019-12-18 rpoprczak -- We are planning to support sending the devicetype in the
                            //  SQS message body in order to make the playerTakeoverNotification popup more
                            //  reliable. However, until this happens, we'll fall back on the original value
                            //  instead of setting it to null.
                            scope.selectedStream.devicetype = message.devicetype || scope.selectedStream.devicetype;

                            if (message.deviceid !== scope.me.device_id && playerService.isPlayingMode()) {
                              scope.me.active_player = false;
                              playerTakeoverNotification(scope.selectedStream).catch(angular.noop);
                              switchToRemoteControlMode();
                            }
                          }
                        }

                        if (scheduleid || scheduleid === null) {
                          scope.me.schedule_id = scheduleid;
                          scheduleHandler.processMessageSchedule(scope.pushMedia);
                        }
                        else {
                          // scheduleHandler didn't do anything with it, see if it's something we should handle here.
                          // These don't go via SNS, but directly to the device's queue.
                          if (playerService.isPlayingMode()) {
                            if (/^skip/.test(message)) {
                              if (!scope.skips[scope.selectedStream.streamid] || scope.skips[scope.selectedStream.streamid] < scope.skipLimit) {
                                scope.playNextMedia();
                              }
                              incrementSkipCount(scope.selectedStream.streamid, false);
                            }
                            else if (/^set volume/.test(message)) {
                              handleSetVolume(message);
                            }
                            else if (/^adjust volume/.test(message)) {
                              handleAdjustVolume(message);
                            }
                            else if (/^pause/.test(message)) {
                              console.log('Received pause command.', message);

                              if (scope.currentMedia) {
                                console.log('Pausing current media...');
                                scope.currentMedia.pause();
                              }
                            }
                            else if (/^unpause/.test(message)) {
                              console.log('Received unpause command.', message);

                              if (scope.currentMedia && scope.currentMedia.isPaused()) {
                                console.log('Resuming current media...');
                                scope.currentMedia.resume();
                              }
                            }
                          }
                        }
                      });
                    }
                  });
                });
              })
              .catch(angular.noop);

            // Get device details so we can report on state changes, whether remote or playing.
            scope.api.getDeviceDetails(scope.me.device_id).then(function(device) {
              scope.deviceDetails = {
                id: device.device.deviceid,
                uuid: device.device.uuid,
                name: device.device.name,
                appversion: device.device.appversion,
                type: device.device.type
              };
            }, function (err) {
              scope.deviceDetails = {};
            });
          }
        });

        // handle update to me.streamid
        scope.$watch(scope.me.streamid, function (newValue, oldValue) {

          // Do nothing when the listener was called due to the initialization of the watcher
          if (newValue === oldValue) {
            return;
          }

          if (!scope.me.device_id) {
            scope.registerDevice(function () {
              getStreamListData(streamDataCallback);
            }, function () {
              scope.showError('Could not register device with network');
            });
          } else {
            getStreamListData(streamDataCallback);
          }
        });

      }

      /*
        There are two types of the buffering state. One is where there is no currentMedia
        but we are actively trying to get one (waiting on queueMedia). The other is when
        we have the current Media, but it's still loading content and not ready to play.
      */
      function isPlayerState (state) {
        if (scope.currentMedia && state === 'buffering' && playerState === 'active') {
          return scope.currentMedia.isBuffering();
        }

        if (scope.currentMedia && state === 'active' && playerState === 'active') {
          return scope.currentMedia.isActive();
        }

        if (scope.me.streamid && state === 'remotecontrol' && playerState === 'remotecontrol') {
          return true;
        }

        return playerState === state;
      }

      // only called in queueMedia(), so this won't be called if in remote control mode
      function isRequestOverload() {
        var now = new Date();
        if (now - lastMediaRequest < minBackToBackTime) {
          fastRequests++;
          if (fastRequests >= tooManyAtOnce) {
            // Only need to do this when we transition into overload state
            if (fastRequests === tooManyAtOnce) {
              scope.errorMessage = 'Media or sound error, will retry in ' + overloadRetryMinutes + ' minute' + (overloadRetryMinutes > 1 ? 's' : '');
              scope.setInactive('error');
              if (!overloadRetryTimer) {
                overloadRetryTimer = $timeout(function() {
                  clearOverload();
                  switchToPlayingMode();
                }, overloadRetryMinutes * 60 * 1000);
              }
            }
            return true;
          }
        }
        else {
          // Not back-to-back requests
          if (fastRequests > 0)
            clearOverload();
        }

        lastMediaRequest = now;
        return false;
      }

      function isStreamAvailable (stream) {
        // We can take the stream if no device is assigned or it's our device.
        return (!stream.deviceid || stream.deviceid == scope.me.device_id);
      }

      function launchMediaBar () {
        $rootScope.mobileMediaToolbarOpen = true;
      }

      function playNextMedia () {
        if (!scope.nextMedia) {
          scope.removeCurrentMedia();
          return scope.queueMedia();
        }

        var media = scope.nextMedia;
        delete scope.nextMedia;
        scope.setCurrentMedia(media);
      }

      function createInterruptMedia (data) {
        return new MediaWrapper({
          api: {
            APIKey: scope.api.APIKey
          },
          showError: scope.showError,
          playerVolume: scope.playerVolume,
          playNextMedia: function() {
            if (scope.currentMedia && (scope.currentMedia.sound.playState !== 1 || scope.currentMedia.isPaused())) {
              scope.currentMedia.fadeTo(scope.playerVolume, 1500);
              scope.currentMedia.play();
            }
            scope.$broadcast('resumeMedia');
            scope.interruptMedia.cleanup();
            delete scope.interruptMedia;
            scope.safeApply();
          },
          safeApply: function() {
            scope.safeApply();
          },
          broadcast: function(message, data) {
            $rootScope.$broadcast(message, data);
          }
        }, data);
      }

      function pushMedia (data) {
        if (data.description === "scheduled message" && !scope.interruptMedia && (!scope.currentMedia || scope.currentMedia.isPaused())) {
          return;
        }

        if (scope.interruptMedia) {
          if (data.id && data.id === scope.interruptMedia.id) {
            console.log('Toggling pause for current media...');
            return scope.interruptMedia.togglePause();
          } else if (!data.id) {
            scope.interruptMedia.fadeTo(0, 1000, function() {
              if (scope.currentMedia && (scope.currentMedia.sound.playState !== 1 || scope.currentMedia.isPaused())) {
                scope.currentMedia.fadeTo(scope.playerVolume, 1500);
                scope.currentMedia.play();
              }
              scope.$broadcast('resumeMedia');
              scope.interruptMedia.cleanup();
              delete scope.interruptMedia;
              scope.safeApply();
            });
            return;
          } else {
            scope.interruptMedia.cleanup();
            delete scope.interruptMedia;
          }
        }

        scope.interruptMedia = createInterruptMedia(data);

        if (scope.currentMedia && !scope.currentMedia.isPaused()) {
          scope.currentMedia.fadeTo(0, 1500, function() {
            console.log('Pausing current media...');

            // 2021-03-02 rporczak -- Due to the asynchronous nature of the currentMedia
            //  fade, it is possible in some cases for the interrupt media to be
            //  unexpectedly deleted before the fade is complete and this callback is
            //  executed, i.e. if currentMedia changes at the _exactly_ right time. If we
            //  do not handle this error, it will stop the music and send it into an
            //  infinite loop. Therefore, do one last check and bounce out if necessary.
            if (!scope.interruptMedia) {
              scope.interruptMedia = createInterruptMedia(data);
            }

            scope.currentMedia.pause();
            scope.interruptMedia.play();
            scope.interruptMedia.fadeTo(scope.playerVolume, 1500);
            if (scope.interruptMedia.mediaType === "message" && scope.interruptMedia.description === "scheduled message") {
              var historyInfo = {
                userid:     scope.me.user.userid,
                streamid:   scope.me.streamid,
                deviceid:   scope.me.device_id,
                mediaid:    scope.interruptMedia.mediaid,
                media_type: scope.interruptMedia.mediaType,
                created_at: moment().utc().format('YYYY-MM-DD HH:mm:ss')
              };

              scope.api.addStreamHistory(scope.me.streamid, [historyInfo])
                .catch(angular.noop);
            }
          });
        }
        else {
          scope.interruptMedia.play();
        }

        if (data.mediaType === 'song') {
          if (data.overrideDuration && scope.interruptMedia) {
            scope.$watch(function() {
              return scope.interruptMedia && scope.interruptMedia.duration;
            }, function (newDuration, oldDuration) {
              if (newDuration && newDuration > 0) {
                scope.interruptMedia.sound.onPosition(newDuration, function() {
                  if (scope.interruptMedia) {
                    scope.interruptMedia.fadeTo(0, 1500, function() {
                      if (scope.interruptMedia) {
                        scope.interruptMedia.sound.stop();
                        scope.interruptMedia.sound.clearOnPosition();
                        scope.interruptMedia.scope.playNextMedia();
                      }
                    });
                  }
                  $rootScope.$broadcast('resumeMedia');
                });
              }
            });
          }
          else {
            scope.interruptMedia.sound.onPosition(30000, function() {
              scope.interruptMedia.fadeTo(0, 1500, function() {
                scope.interruptMedia.sound.stop();
                scope.interruptMedia.sound.clearOnPosition();
                scope.interruptMedia.scope.playNextMedia();
              });
            });
          }
        }
      }

      function queueMedia (currentMedia) {
        if (scope.requestInProgress || !scope.canPlayMusic) {
          return;
        }

        if (isRequestOverload()) {
          return;
        }

        if (scope.getNextTimeout) {
          clearTimeout(scope.getNextTimeout);
          delete scope.getNextTimeout;
        }
        if (scope.isRemoteControlMode()){
            return;
        }

        if (!scope.currentMedia) {
          scope.isLoadingInitialMedia = true;
        }

        scope.requestInProgress = true;

        if (scope.interruptMedia) {
          scope.interruptMedia.scope.playNextMedia();
        }

        // If there's an error, retry after 45 seconds
        var retryTimeout = 45000;

        var streamHistoryEntry = buildStreamHistoryEntry(currentMedia);
        var streamHistory = streamHistoryEntry ? [streamHistoryEntry] : undefined;

        scope.api.getNextMedia(scope.selectedStream.streamid, streamHistory, scope.currentMedia)
          .then(function (response) {
            scope.isLoadingInitialMedia = false;
            scope.requestInProgress = false;

            if (response.err) {
              if (response.err.code && response.err.code === 'InActivePlayer') {
                if (isAutologin) {
                  scope.initialAutoLoginState = true;
                }

                // TODO not sure we need this since switchToRemoteControlMode calls setRemoteControlMediaInfo which calls getMediaPlayingForStream
                //getMediaPlayingForStream(function(mediaInfo) {
                //  if (mediaInfo) setMediaInfo(mediaInfo.streamingMedia);
                playerTakeoverNotification(scope.selectedStream).catch(angular.noop);
                switchToRemoteControlMode();
                //});
              } else {
                if (response.err === 'nomusic' || response.err === 'emptydaypart') {
                  scope.setInactive(response.err);
                } else if (response.err.message) {
                  scope.showError(response.err.message);
                  scope.errorMessage = response.err.message;
                  scope.setInactive('error');
                } else {
                  scope.showError(response.err);
                  scope.errorMessage = 'Streaming error. Please check network connection.';
                  scope.setInactive('error');
                }

                // Keep trying
                scope.getNextTimeout = $timeout(function() {
                    scope.queueMedia();
                }, retryTimeout);
              }
            } else {
              if (response.data.mediaUrl.length > 0) {
                if (!scope.currentMedia) {
                  scope.setPlayerState('buffering');
                }

                if (scope.selectedStream.message_preset) {
                  response.data.messagepresetid = scope.selectedStream.message_preset;
                }

                var media = new MediaWrapper(scope, response.data);

                if (!scope.currentMedia && (scope.autoPlayStatus.playabilityInitialized || scope.autoLogin)) {
                  scope.setCurrentMedia(media);
                } else {
                  scope.setNextMedia(media);
                }
              }
            }
          })
          .catch(function (response) {
            scope.isLoadingInitialMedia = false;
            scope.requestInProgress = false;

            // This case can be observed when there are network or connection issues and the server is not responding.
            // An HTTP status code of -1 usually indicates that the HTTP request was aborted by the client.
            if (response.status === 500 || response.status === -1) {
              scope.errorMessage = 'Streaming error. Please check network connection.';
              scope.setInactive('error');

              if (isAutologin) {
                scope.initialAutoLoginState = true;
              }

              scope.getNextTimeout = $timeout(function() { scope.queueMedia(); }, retryTimeout);
            }
          });
      }

      function registerDevice (callback, callerror) {
        if (!isAutologin) {
          return scope.api.registerDevice(function(err, result) {
            if (err) {
              scope.errorMessage = 'Could not register device.';
              scope.setPlayerState('error');
              callerror(err);
              return;
            }

            scope.me.device_id = scope.api.userObject.device_id = result.device.deviceid;

            if (scope.selectedStream) {
              if (!scope.selectedStream.streamid) {
                if (scope.me.streamid) {
                  scope.selectedStream.streamid = scope.me.streamid;
                  updateSelectedStream(scope.selectedStream);
                }
              }
              if (!scope.me.streamid) {
                if (scope.selectedStream.streamid) scope.me.streamid = scope.selectedStream.streamid;
              }
              if (scope.me.streamid) scope.activatePlayer();
            }
            if (typeof callback === 'function') callback();
          });
        }
      }

      function removeCurrentMedia () {
        if (scope.currentMedia) {
          scope.currentMedia.cleanup();
          delete scope.currentMedia;
          scope.setPlayerState('buffering');
        }
      }

      function setCurrentMedia (media) {
        scope.removeCurrentMedia();
        scope.setPlayerState('active');
        scope.currentMedia = media;
        scope.likeBtnTitle = media.liked ? 'Unlike song' : 'Like song';

        intercom.sendEvent('Stream Media', {
          "artist": media.artist,
          "name": media.name,
          "station": media.station
        });
        sendDeviceUpdate();

        // if(media.index) {
        //   scope.api.postArtistRadioStation(scope.me.user.userid, media.stationId, {command: 'setStarted', index: media.index});
        // }

        // eventually we might have SQS messages handling message_preset
        // But until we do, we're updating preset selection here.
        // This constructs a streamingMedia object from the new 'media' plus preset and schedule from server info
        getMediaPlayingForStream(function(mediaData) {
          if (mediaData) {
            var mediaInfo = {};
            mediaInfo.mediaid = media.mediaid;
            mediaInfo.music_type = media.music_type;
            mediaInfo.mediaType = media.mediaType;
            if (media.music_type == 'dayparting') mediaInfo.music_selection = media.daypart;
            else if (media.music_type == 'mix') mediaInfo.music_selection = media.mix;
            else if (media.music_type == 'playlist') mediaInfo.music_selection = media.station;
            mediaInfo.preset_name = mediaData.streamingMedia.preset_name;
            mediaInfo.schedule_name = mediaData.streamingMedia.schedule_name;
            mediaInfo.artist = media.artist;
            mediaInfo.media_name = media.name;
            mediaInfo.media_station = media.station;
            mediaInfo.imageUrl = media.imageUrl;

            setMediaInfo(mediaInfo);

            //messageSelection.setSelection({
            //  messagePreset: mediaData.streamingMedia.message_preset,
            //  messageSchedule: mediaData.streamingMedia.schedule_id
            //});
          }
        });

        if (!scope.initialAutoLoginState || scope.autoPlayStatus.canAutoPlay) {
          scope.autoPlayStatus.playabilityInitialized = true;
          setEnableBlink();
          scope.currentMedia.togglePause();
          if (!scope.nextMedia) {
            scope.queueMedia(media);
          }
        }

      }

      function setEnableBlink() {
        if (scope.autoPlayStatus.playabilityInitialized || scope.autoPlayStatus.canAutoPlay) {
          scope.autoPlayStatus.playabilityInitialized = true;
          scope.autoPlayStatus.canAutoPlay = true;
        }
        scope.enableBlink = !scope.isRemoteControlMode() && !scope.autoPlayStatus.canAutoPlay && !scope.autoPlayStatus.playabilityInitialized;
      }

      function setInactive (newState) {
        scope.setPlayerState(newState ? newState : 'inactive');
        if (scope.currentMedia) {
          scope.currentMedia.cleanup();
          delete scope.currentMedia;
        }

        if (scope.nextMedia) {
          scope.nextMedia.cleanup();
          delete scope.nextMedia;
        }
      }

      function setMediaInfo (media) {
        var retainMediaLikeStatus = scope.mediaInfo && scope.mediaInfo.mediaid === media.mediaid;
        var previousMediaLikeStatus = scope.mediaInfo && scope.mediaInfo.liked;

        scope.noMediaSet = false;
        scope.mediaInfo = media;
        if (!media.mediaType || !media.media_name) {
          scope.noMediaSet = true;
        }
        if (media.mediaType === "song") {
          if (media.imageUrl) {
            scope.mediaInfo.heroImage = {
              'background-image': 'url("' + media.imageUrl + '")',
              'background-size': 'cover'
            };
          } else {
            scope.mediaInfo.heroImage = {
              'background': '',
              'background-size': 'cover'
            };
          }

          if (retainMediaLikeStatus) {
            scope.mediaInfo.liked = previousMediaLikeStatus;
          }
        } else if (media.mediaType === "message") {
          scope.mediaInfo.heroImage = {
            'background': 'url(/images/message-player-icon2x.png)',
            'background-size': 'cover'
          }
        } else {
          scope.mediaInfo.heroImage = {
            'background': '',
            'background-size': 'cover'
          };
        }
      }

      function setNextMedia (media) {
        if (scope.nextMedia) {
          scope.nextMedia.cleanup();
          delete scope.nextMedia;
        }

        scope.nextMedia = media;
      }

      function setPlayerState (state) {
        playerState = state;
        scope.safeApply();
      }

      function setRemoteControlMediaInfo() {
        getMediaPlayingForStream(function(mediaInfo) {
          if (mediaInfo && mediaInfo.streamingMedia) {
            setMediaInfo(mediaInfo.streamingMedia);

            // Make sure the player controls are enabled if a zone starts streaming while the browser is in Remote mode.
            // A zone's device assignment could change at any time.
            if (mediaInfo.streamingMedia.deviceid && mediaInfo.streamingMedia.devicetype) {
              scope.selectedStream.deviceid = mediaInfo.streamingMedia.deviceid;
              scope.selectedStream.devicetype = mediaInfo.streamingMedia.devicetype;
              streamUpdateService.setSelectedStream(scope.selectedStream);
            }
            if ('undefined' !== typeof mediaInfo.streamingMedia.message_preset)
              scope.selectedStream.message_preset = mediaInfo.streamingMedia.message_preset;
            if ('undefined' !== typeof mediaInfo.streamingMedia.schedule_id)
              scope.selectedStream.schedule_id = mediaInfo.streamingMedia.schedule_id;
            streamUpdateService.setSelectedStream(scope.selectedStream);

            var shouldCheckMediaLiked = playerService.isRemoteControlMode() && mediaInfo.streamingMedia.mediaid && mediaInfo.streamingMedia.mediaType === 'song' && typeof scope.mediaInfo.liked === 'undefined';
            if (shouldCheckMediaLiked) {
              scope.api
                .getMediaLikeBatch([{
                  userId: scope.me.user.userid,
                  mediaId: mediaInfo.streamingMedia.mediaid,
                  playlistName: mediaInfo.streamingMedia.media_station
                }])
                .then(function (mediaLikes) {
                  scope.mediaInfo.liked = Boolean(mediaLikes && mediaLikes[0]);
                })
                .catch(angular.noop);
            }
          }

          if (playerService.isRemoteControlMode()) {
            var interval = (mediaInfo && mediaInfo.musicPollRate) ? mediaInfo.musicPollRate : 60000;
            if (remoteMediaTimer) $timeout.cancel(remoteMediaTimer);
            remoteMediaTimer = $timeout(function() { setRemoteControlMediaInfo(); }, interval);
          }
        });
      }

      function setVolume (toVol) {
        scope.playerVolume = toVol;
        scope.$emit('setLocalVolume', toVol);

        // Set the volume on each potential media item.
        if (scope.currentMedia) {
          scope.currentMedia.sound.setVolume(toVol);
        }
        if (scope.nextMedia) {
          scope.nextMedia.sound.setVolume(toVol);
        }
        if (scope.interruptMedia) {
          scope.interruptMedia.sound.setVolume(toVol);
        }

        localStorage.setItem('ccm_playerVolume', toVol);
        sendDeviceUpdate();
      }

      function startPlayer() {
        if (!scope.selectedStream || !scope.selectedStream.streamid) {
          scope.errorMessage = 'Could not start player, no zone selected.';
          return;
        }

        if (!isAutologin) {
          scope.api.activateDevice(scope.api.userObject.device_id, scope.selectedStream.streamid, function(err, result) {
            if (err) {
              scope.errorMessage = 'Could not activate device.';
              scope.setPlayerState('error');
              intercom.sendEvent('Failed to activate device');
              return;
            }
            else {
              getStreamListData(function() {

                if (!scope.isMobile) {
                  scope.api.activatePlayer(function(err, result) {
                    if (err) {
                      scope.errorMessage = 'Could not activate player.';
                      scope.setPlayerState('error');
                      intercom.sendEvent('Failed to activate player');
                      return;
                    }

                    if (result.active_player) {
                      scope.me.active_player = true;
                      scope.queueMedia();
                      intercom.sendEvent('Activated player');
                    }
                  });
                } else {
                  switchToRemoteControlMode();
                }
              });
            }
          });
        }
        else {

          // Autologin
          scope.api.activatePlayer(function(err, result) {
            if (err) {
              scope.errorMessage = 'Could not activate player.';
              scope.setPlayerState('error');
              intercom.sendEvent('Failed to activate player');
              scope.initialAutoLoginState = true;
              return;
            }
            if (result.active_player) {
              scope.me.active_player = true;
              scope.controlMode = playerService.setPlayingMode();
              scope.queueMedia();
              intercom.sendEvent('Activated player');
            }
          });
        }
      }

      function sendDeviceUpdate() {
        if (scope.me.streamid && scope.deviceDetails.id) {
          var state = 'not_playing';
          if (playerService.isPlayingMode() && scope.currentMedia) {
            if (scope.currentMedia.isPaused()) state = 'paused';
            else state = 'playing'; // might be buffering but we'll call it playing
          }

          var deviceInfo = {
            id: scope.deviceDetails.id,
            streamid: scope.me.streamid,
            userid: scope.me.user.userid,
            custid: scope.me.user.custid,
            state: state,
            device: {
              name: scope.deviceDetails.name,
              type: 'browser',
              skipCount: scope.skips[scope.me.streamid] ? scope.skips[scope.me.streamid] : 0,
              volumePercent: scope.playerVolume
            },
            media: {}
          };

          if (scope.currentMedia) {
            deviceInfo.media = {
              // 'n/a' is because dynamoDB doesn't allow empty values
              album: 'n/a', // description after the '/', could add to media object if needed
              artist: scope.currentMedia.artist ? scope.currentMedia.artist : 'n/a',
              imageUrl: scope.currentMedia.imageUrl ? scope.currentMedia.imageUrl : 'n/a',
              mediaid: scope.currentMedia.mediaid,
              playlist: scope.currentMedia.daypart ? scope.currentMedia.daypart : scope.currentMedia.mix ? scope.currentMedia.mix : scope.currentMedia.station,
              playlistType: scope.currentMedia.music_type,
              station: scope.currentMedia.station,
              title: scope.currentMedia.name,
              type: scope.currentMedia.mediaType
            };
          }
          else {
            // At least show the selection
            deviceInfo.media = {
              playlist: getMusicName(scope.selectedStream.music_id, scope.selectedStream.music_type) || 'n/a',
              playlistType: scope.selectedStream.music_type
            };
          }
          scope.api.sendDeviceState(deviceInfo)
            .catch(angular.noop);
        }
      }

      function switchToPlayingMode() {
          scope.controlMode = playerService.setPlayingMode();

          // In case user switched zones in remote mode, then hit Play
          if (scope.selectedStream && scope.selectedStream.streamid) scope.me.streamid = scope.selectedStream.streamid;

          if (scope.playerVolume === 0) scope.showWarning('Your player volume is set to zero!');
          scope.activatePlayer();
      }

      function switchToRemoteControlMode() {
        // fetch stream list so that we can get the updated info
        // about the selected stream.
        getStreamListData(function() {
          clearOverload();
          scope.controlMode = playerService.setRemoteControlMode();
          scope.setInactive();
          scope.setPlayerState('remotecontrol');

          setEnableBlink();
          setRemoteControlMediaInfo();
          sendDeviceUpdate();
          if (isAutologin) {
            scope.errorMessage = 'Zone taken by another device, refresh and click play button to resume playing.';
            scope.setPlayerState('error');
            scope.initialAutoLoginState = true;
          }
        });
      }

      // attempt to autoplay a silent track to see if a promise is returned.
      // If we receive a promise, then autoplay is possible.
      // If an exception is thrown, then we need to require play button click.
      function testForAutoPlay(callback) {
        var testAudio = document.createElement('audio');
        testAudio.type = 'audio/mpeg';
        testAudio.src = 'https://media.cloudcovermusic.com/music/test/Silence-08s.mp3';

        function autoPlaySuccess() {
          scope.autoPlayStatus.canAutoPlay = true;
          scope.autoPlayStatus.playabilityInitialized = true;
          setEnableBlink();
          scope.initialAutoLoginState = false;
          if (testAudio.playing) {
            testAudio.pause();
            delete testAudio;
          }
          callback();
        }

        function autoPlayFailure(error) {
          scope.autoPlayStatus.canAutoPlay = false;
          scope.autoPlayStatus.playabilityInitialized = false;
          scope.initialAutoLoginState = true;
          setEnableBlink();
          if (testAudio) {
            delete testAudio;
          }
          callback();
        }

        // for browsers that don't support promises
        testAudio.addEventListener("play", function() {

          // Autoplay started
          scope.$apply(function() {
            autoPlaySuccess();
          });
        });
        testAudio.addEventListener("error", function(err) {
          autoPlayFailure(err);
        });

        var testPromise = testAudio.play();
        if (testPromise !== undefined) {
          testPromise.then(function() {
            // Autoplay started
            // No-Op because it should be handled by play event
          }).catch(function(error) {
            // Autoplay was prevented
            // autoplay that requires interaction in order to play
            // should be caught here, but not by error event.
            // Therefore we need to define this promise rejection here.
            autoPlayFailure(error);
          });
        }
      }

      function updateSelectedStream (stream, callback) {
        scope.selectedStream = stream;
        streamUpdateService.setSelectedStream(stream);

        var streamMessageSelection = {
          messagePreset: stream.message_preset,
          messageSchedule: stream.schedule_id
        };
        messageSelection.setSelection(streamMessageSelection);

        if (stream === null) {
          scope.selectStreamLabel = 'Select Zone';
          scope.selectStreamTooltip = '';
          scope.autoLoginStreamLabel = '';
          scope.autoLoginStreamTooltip = '';
          scope.selectStreamIcon = '';

          if (typeof callback === 'function') {
            callback();
          }
        } else {
          scope.selectStreamLabel = stream.streamname;
          scope.selectStreamTooltip = (stream.streamname.length > 15) ? stream.streamname : '';

          // the following 2 strings are used for Auto Login Specifically
          scope.autoLoginStreamLabel = stream.streamname;
          scope.autoLoginStreamTooltip = scope.selectStreamTooltip;

          scope.selectStreamIcon = stream.deviceicon;

          // Populate remote device info for new stream's device
          if (playerService.isRemoteControlMode() && scope.selectedStream.deviceid) {
            scope.api.getDeviceState([scope.selectedStream.deviceid])
              .then(function (results) {
                if (results.DeviceState.length > 0) {
                  remoteDeviceState = results.DeviceState[0];
                } else {
                  remoteDeviceState = {};
                }
              })
              .catch(angular.noop);
          }

          if (typeof callback === 'function') {
            callback();
          }
        }
      }

      //----------------------------------
      // player controls
      //----------------------------------

      function canBePaused () {
        if (playerService.isPlayingMode()) {
          if (scope.currentMedia)
            return scope.isPlayerState('active') && !scope.currentMedia.isPaused();
          else
            return false;
        }
        else if (playerService.isRemoteControlMode())
          return remoteDeviceState.state ? (remoteDeviceState.state == 'playing') : false;
        else
          return false; // shouldn't get here unless we add another mode besides Playing and Remote
      }

      function canBePlayed () {
        if (playerService.isPlayingMode()) {
          return !scope.isPlayerState('active') || (scope.currentMedia && scope.currentMedia.isPaused());
        }
        else if (playerService.isRemoteControlMode())
          return remoteDeviceState.state ? (remoteDeviceState.state != 'playing') : false;
        else
          return true; // shouldn't get here unless we add another mode besides Playing and Remote
      }

      function closeMoreInfo () {
        scope.showMoreInfo = false;
      }

      function closeStreamListPopup () {
        scope.showStreamList = false;
      }

      function isAtSkipLimit () {
        if (scope.selectedStream.streamid && scope.skips[scope.selectedStream.streamid])
          return scope.skips[scope.selectedStream.streamid] >= scope.skipLimit;
        else
          return false;
      }

      function toggleArtistRadioThumbs(value) {
        var media = scope.currentMedia;
        var operation;
        if (value === media.feedbackValue) {
          operation = 'removeFeedback';
          value = null;
        } else {
          operation = 'setFeedback';
        }
        scope.currentMedia.feedbackValue = value;
        var command = {
          operation: operation,
          contextId: media.stationId,
          targetId: 'TR:' + media.mediaid,
          trackToken: media.trackToken,
          value: value
        };
        scope.api.postArtistRadioFeedback(scope.me.user.userid, command).then(function () {
          if(value === 'DOWN') {
            scope.skipSong();
          }
        });
      }

      function toggleSongLike() {
        if (typeof scope.currentMedia.stationId === 'string') {
          scope.mediaInfo.thumbs = toggleArtistRadioThumbs('UP') === 'UP';
          return;
        }

        if (scope.isMediaLikeRequestActive) {
          return;
        }

        var songLike = {
          userid: scope.me.user.userid
        };

        if (playerService.isPlayingMode() && scope.currentMedia && scope.currentMedia.mediaType === 'song') {
          songLike.mediaid = scope.currentMedia.mediaid;
          songLike.playlistid = scope.currentMedia.playlistid;
          songLike.name = scope.currentMedia.name;
        } else if (playerService.isRemoteControlMode() && remoteDeviceState.id) {
          songLike.mediaid = remoteDeviceState.media.mediaid;
          songLike.playlistName = remoteDeviceState.media.station;
          songLike.name = remoteDeviceState.media.title;
        } else if (playerService.isRemoteControlMode() && remoteDBState.mediaid) {
          songLike.mediaid = remoteDBState.mediaid;
          songLike.playlistid = remoteDBState.stationid;
          songLike.name = remoteDBState.name;
        }

        if (!songLike.mediaid || (!songLike.playlistid && !songLike.playlistName)) {
          return;
        }

        scope.isMediaLikeRequestActive = true;

        if (scope.mediaInfo.liked) {
          scope.mediaInfo.liked = false;

          scope.api
            .deleteMediaLike(songLike.userid, songLike.mediaid, songLike.playlistid, songLike.playlistName)
            .then(function () {
              scope.likeBtnTitle = 'Like song';
            })
            .catch(function (response) {
              if (response.status !== 404) {
                scope.mediaInfo.liked = true;
                scope.showWarning('There was a problem removing the like for the song "' + songLike.name + '"');
              }
            })
            .finally(function () {
              scope.isMediaLikeRequestActive = false;
            });
        } else {
          scope.mediaInfo.liked = true;

          scope.api
            .createMediaLike(songLike.userid, songLike.mediaid, songLike.playlistid, songLike.playlistName)
            .then(function () {
              scope.likeBtnTitle = 'Unlike song';
              scope.showSuccess(songLike.name + ' has been successfully liked');
            })
            .catch(function () {
              scope.mediaInfo.liked = false;
              scope.showWarning('There was a problem liking the song "' + songLike.name + '"');
            })
            .finally(function () {
              scope.isMediaLikeRequestActive = false;
            });
        }
      }

      function lowerVolume (stream) {
        adjustVolume(stream, '-0.05');
      }

      // Is there a device that can be controlled?
      function noDevice () {
        return (!scope.selectedStream || !scope.selectedStream.deviceid);
      }

      function openMoreInfo (evt, move) {
        if (scope.isMobile || scope.showMoreInfo) return;
        if (move) {
          var left = evt.clientX - 120;
          if (left < 0) left = 0;
          scope.moreInfoPopupLeft = {
            left: left + "px"
          }
        }
        scope.showMoreInfo = true;
      }

      function raiseVolume (stream) {
        adjustVolume(stream, '0.05');
      }

      function remotePause () {
        if (scope.selectedStream && scope.selectedStream.deviceid) {
          var device = {
            type: scope.selectedStream.devicetype,
            deviceid: scope.selectedStream.deviceid,
            userid: scope.api.userObject.user.userid,
            custid: scope.api.userObject.user.custid
          };
          deviceCommand.pauseDevice(device, deviceCommandCallback);

          var intercomData = {
            source: 'player bar',
            custid: device.custid,
            localDeviceId: scope.me.device_id,
            localUserId: scope.me.user.userid,
            streamingDeviceType: device.type,
            streamingDeviceId: device.deviceid,
            streamingUserId: device.userid,
            streamId: scope.selectedStream.streamid
          };
          intercom.sendEvent('Remote pause', intercomData);
        }
      }

      function remotePlay () {
        if (!scope.selectedStream) {
          return;
        }
        // 07/08/19 FM
        // need to check to see if another device is assigned, and if not, prompt to play locally
        if (scope.selectedStream.deviceid && scope.selectedStream.deviceid != scope.me.device_id) {
          var device = {
            type: scope.selectedStream.devicetype,
            deviceid: scope.selectedStream.deviceid,
            userid: scope.api.userObject.user.userid,
            custid: scope.api.userObject.user.custid
          };
          deviceCommand.unpauseDevice(device, deviceCommandCallback);

          var intercomData = {
            source: 'player bar',
            custid: device.custid,
            localDeviceId: scope.me.device_id,
            localUserId: scope.me.user.userid,
            streamingDeviceType: device.type,
            streamingDeviceId: device.deviceid,
            streamingUserId: device.userid,
            streamId: scope.selectedStream.streamid
          };
          intercom.sendEvent('Remote play', intercomData);
        }
        else if (!scope.isMobile) {
          playerConfirmationModal({
            stream: scope.selectedStream,
            title: 'Play Here?',
            description: 'Would you like to begin streaming (<strong>' + scope.selectedStream.streamname + '</strong>) in this browser now?',
          }, function(result) {
            scope.setInactive();
            updateSelectedStream(scope.selectedStream, function() {
              scope.activatePlayer(scope.selectedStream);
            });
            switchToPlayingMode();
          }).catch(angular.noop);
        }
      }

      function removeSong () {
        if (typeof scope.currentMedia.stationId === 'string') {
          toggleArtistRadioThumbs('DOWN');
          return;
        }

        var reason = "DontLikeSong";
        var removedSong = {
          reason: reason,
          userid: scope.me.user.userid
        };
        var intercomData;

        if (playerService.isPlayingMode() && scope.currentMedia && scope.currentMedia.mediaType === 'song') {
          removedSong.artist = scope.currentMedia.artist;
          removedSong.mediaid = scope.currentMedia.mediaid;
          removedSong.name = scope.currentMedia.name;
          removedSong.station = scope.currentMedia.station;

          removedSong.description = scope.currentMedia.description;

        } else if (playerService.isRemoteControlMode() && remoteDeviceState.id) {
          removedSong.artist = remoteDeviceState.media.artist;
          removedSong.mediaid = remoteDeviceState.media.mediaid;
          removedSong.name = remoteDeviceState.media.title;
          removedSong.station = remoteDeviceState.media.station;

          // 2020-03-20 rporczak -- We don't have Description information in
          //  Device State, and it's not worth adding.
          removedSong.description = 'REMOTE_REMOVE';

        } else if (playerService.isRemoteControlMode() && remoteDBState.mediaid) {
          removedSong.artist = remoteDBState.artist;
          removedSong.mediaid = remoteDBState.mediaid;
          removedSong.name = remoteDBState.name;
          removedSong.station = remoteDBState.station;
        }

        if (removedSong.mediaid) {
          var accountPermissions = scope.me.permissions.account;

          removeSongModal({
            name: removedSong.name,
            artist: removedSong.artist,
            mediaid: removedSong.mediaid,
            canSetGlobal: (subscriptionInfo.getEnterpriseStatus().isEnterprise && (accountPermissions.owner || accountPermissions.music))
          }).then(function (params) {
            if (params.shouldSkip) {
              if (playerService.isPlayingMode()) {
                scope.playNextMedia();
              } else {
                var device = {
                  type: scope.selectedStream.devicetype,
                  deviceid: scope.selectedStream.deviceid,
                  userid: scope.api.userObject.user.userid,
                  custid: scope.api.userObject.user.custid
                };
                deviceCommand.skipDevice(device, angular.noop);
                // Update "now playing" sooner than normal
                $timeout(function() {
                  getMediaPlayingForStream(function(mediaInfo) {
                    if (mediaInfo) setMediaInfo(mediaInfo.streamingMedia);
                  });
                }, 5000);
              }
            }

            var intercomData = {
              'Artist': removedSong.artist,
              'Description': removedSong.description,
              'Name': removedSong.name,
              'Media Id': removedSong.mediaid,
              'Reason': removedSong.reason,
              'Station': removedSong.station,
            };

            scope.api.removeSong({
              mediaid: removedSong.mediaid,
              isGlobal: params.isGlobal,
              name: removedSong.name,
              reason: removedSong.reason,
              userid: removedSong.userid
            }, function(params) {
              scope.showSuccess(removedSong.name + ' has been successfully removed');
              intercom.sendEvent('Removed song', intercomData);
              $timeout(function() {
                getMediaPlayingForStream(function(mediaInfo) {
                  if (mediaInfo) setMediaInfo(mediaInfo.streamingMedia);
                  getStreamListData();
                });
              }, 3000);
            }, function(e) {
              scope.showWarning('There was a problem removing the song "' + removedSong.name + '"');
              intercom.sendEvent('Remove song failed', intercomData);
            });

          }).catch(function (e) {
            // 2020-03-23 rporczak -- Remove Song cancelled. No-op.
          });
        }
      }

      function selectStream (stream) {
        // if browser is currently in remote control mode...
        if (playerService.isRemoteControlMode()) {
          // if no device is assigned to the given stream, then we should ask he user
          // if they wish to stream locally.
          if (!scope.isMobile && (stream.deviceid === scope.me.device_id || stream.deviceid === null)) {
            playerConfirmationModal({
              stream: stream,
              title: 'Play Here?',
              description: 'Would you like to begin streaming (<strong>' + stream.streamname + '</strong>) in this browser now?',
            }, function(result) {
              scope.setInactive();
              updateSelectedStream(stream, function() {
                scope.activatePlayer(stream);
              });
              switchToPlayingMode();
            }).catch(angular.noop);
          }
          // if a device is assigned to this stream, then we simply stay in remote control
          // mode and control remote device
          else {
            updateSelectedStream(stream, function() {
              // Update the current media right away
              setRemoteControlMediaInfo();
            });
            scope.setPlayerState('remotecontrol');
          }
        }
        // browser currently in local play mode
        else {
          scope.me.streamid = stream.streamid;
          scope.showStreamList = false;
          if (isStreamAvailable(stream)) {
            updateSelectedStream(stream, function() {
              scope.activatePlayer(stream);
            });
          }
          else {
            playerConfirmationModal({
              stream: stream,
              controlMode: scope.controlMode,
            }, function(result) {
              updateSelectedStream(stream, function() {
                scope.activatePlayer(stream);
              });
            }).catch(angular.noop);
          }
        }

        scope.$broadcast('newStreamSet');
      }

      function showHistory (evt) {
        scope.api.getStreamHistory(scope.selectedStream.streamid, 50)
          .then(function (rows) {

            // 2016-10-28 tbrown  API now returns a Unix timestamp, convert to JS date.
            rows.songs.map(function (song) {
              song.time = new Date(song.timestamp.ts * 1000);
            });
            streamHistoryModal.show(rows).catch(angular.noop);
          })
          .catch(function () {
            scope.showWarning('There was an error');
          });
      }

      function showVolumeControl (evt) {
        var volumeOption = scope.playerVolume;
        if (playerService.isRemoteControlMode()) {
          if ('undefined' !== typeof remoteDeviceState.device && 'undefined' !== typeof remoteDeviceState.device.volumePercent)
            volumeOption = remoteDeviceState.device.volumePercent;
          else
           volumeOption = 50;
        }
        scope.$emit('showVolumeControl',
          {evt: evt, userid: scope.api.userObject.user.userid, deviceid: scope.selectedStream.deviceid, custid: scope.api.userObject.user.custid, volume: volumeOption});
      }

      function skipSong () {
        getStreamListData(function() {
          if (playerService.isPlayingMode() && scope.selectedStream.deviceid === scope.me.device_id) {
            intercom.sendEvent('Skip media', {
              "name": scope.currentMedia.name,
              "artist": scope.currentMedia.artist,
              "station": scope.currentMedia.station,
              "description": scope.currentMedia.description
            });
            incrementSkipCount(scope.selectedStream.streamid, true);
            scope.playNextMedia();
          } else if (playerService.isPlayingMode() && scope.selectedStream.deviceid !== scope.me.device_id) {
            // 2019-12-18 rporczak -- Due to the asynchronous nature of the SQS messages being sent from
            //  the server to inform the client of device changes, it is possible for the Tune browser here
            //  to first learn that it is no longer the active device because of the getStreamListData call
            //  here. In this case, we'll be actively playing but the deviceids will be wrong, and so we'll
            //  want to correct this by bouncing out to Remote mode.
            playerTakeoverNotification(scope.selectedStream).catch(angular.noop);
            switchToRemoteControlMode();
          } else {
            var device = {
              type: scope.selectedStream.devicetype,
              deviceid: scope.selectedStream.deviceid,
              userid: scope.api.userObject.user.userid,
              custid: scope.api.userObject.user.custid
            };
            if(scope.selectedStream.music_type === 'pandoraradio') {
              getMediaPlayingForStream(function(mediaInfo) {
                if (mediaInfo) setMediaInfo(mediaInfo.streamingMedia);
                deviceCommand.skipDevice(device, deviceCommandCallback);
              });
            } else {
              deviceCommand.skipDevice(device, deviceCommandCallback);
              // Update "now playing" sooner than normal
              $timeout(function() {
                getMediaPlayingForStream(function(mediaInfo) {
                  if (mediaInfo) setMediaInfo(mediaInfo.streamingMedia);
                });
              }, 3000);
            }
          }
        });
      }

      function streamDataCallback () {
        if (playerService.isRemoteControlMode() && scope.selectedStream) {
          if (scope.me.device_id && (firstTime || scope.selectedStream.deviceid === scope.me.device_id)) {

            // TODO: Do we want this notification?
            //scope.showSuccess('Currently in Playing mode.');

            switchToPlayingMode();
          } else {

            // 2022-01-28 rporczak -- When the very first login occurs (i.e., the first login
            //  after creating a new trial), it takes some additional work to register the
            //  device in order to begin streaming. We enter this code before all of those
            //  requests complete, so, we will just not show the Remote Mode popup if
            //  there are no other streams on this account, and let the first-time device
            //  setup occur asynchronously in parallel.
            if (!firstTime) {
              scope.showWarning('Currently in Remote Control.');
            }

            switchToRemoteControlMode();
          }
        }
        scope.toggleEnabled = true;

        // Notify the App that the player bar is ready
        $rootScope.$broadcast('playerBarReady', true);
      }

      function switchControlMode (evt) {
        if (playerService.isPlayingMode()) {
          playerConfirmationModal({
            stream: scope.selectedStream,
            controlMode: !scope.controlMode,
            title: 'Would you like to stop streaming?',
            description: 'Switching to Remote Control will stop streaming for this browser.',
          }, function(result) {
            switchToRemoteControlMode();
          }).catch(angular.noop);
        } else if (playerService.isRemoteControlMode() && !scope.remoteOnly) {
          if (isStreamAvailable(scope.selectedStream)) {
            switchToPlayingMode();
          }
          else {
            playerConfirmationModal({
              stream: scope.selectedStream,
              controlMode: !scope.controlMode
            }, function(result) {
              switchToPlayingMode();
            }).catch(angular.noop);
          }
        }
        evt.stopPropagation();
      }

      function toggleMedia () {
        if (playerService.isRemoteControlMode()) {
          setEnableBlink();
          return;
        }

        // for browsers that can't autoplay, they've now manually
        // clicked Play, so playability has been initialized
        if (!scope.autoPlayStatus.playabilityInitialized) {
          scope.autoPlayStatus.playabilityInitialized = true;
          setEnableBlink();
        }

        if (scope.currentMedia) {
          if (scope.canPauseMedia && playerService.isPlayingMode() && scope.isPlayerState('active')) {
            if (scope.currentMedia.isPaused()){
              intercom.sendEvent('Play media', {
                "name": scope.currentMedia.name,
                "artist": scope.currentMedia.artist,
                "station": scope.currentMedia.station,
                "description": scope.currentMedia.description
              });
            } else {
              intercom.sendEvent('Pause media', {
                "name": scope.currentMedia.name,
                "artist": scope.currentMedia.artist,
                "station": scope.currentMedia.station,
                "description": scope.currentMedia.description
              });
            }
            scope.currentMedia.togglePause();
            scope.$broadcast('resumeMedia');
            sendDeviceUpdate();
          } else if (scope.initialAutoLoginState) {
            scope.currentMedia.togglePause();
            scope.initialAutoLoginState = false;
            sendDeviceUpdate();

            // In this case, an auto-login has just been initialized and playback was initiated by
            // user interaction as opposed to auto-play. When this occurs, the next media is not
            // prefetched. Therefore, we update stream history separately from the request for
            // next media.
            var streamHistoryEntry = buildStreamHistoryEntry(scope.currentMedia);
            if (streamHistoryEntry) {
              scope.api.addStreamHistory(scope.selectedStream.streamid, [streamHistoryEntry])
                .catch(angular.noop);
            }
          }
        } else {
          scope.playNextMedia();
        }
      }

      function toggleStreamListPopup () {
        if (scope.canPlayMusic && !scope.autoLogin) {
          scope.safeApply(function(){
            getStreamListData(function() {
              scope.showStreamList = !scope.showStreamList;
            });
          });
        }
      }

      function buildStreamHistoryEntry(media) {
        var entry;

        if (media) {
          var shouldAddToStreamHistory =
            media.mediaType === 'song'
            || media.mediaType === 'message'
            || media.extra;

          if (shouldAddToStreamHistory) {
            entry = {
              userid:   scope.me.user.userid,
              streamid: scope.me.streamid,
              deviceid: scope.me.device_id,
              media_type: media.mediaType,
              created_at: moment().utc().format('YYYY-MM-DD HH:mm:ss'),
              track_index: media.trackIndex
            };

            if (media.extra) {
              entry.message_preset_detail_id = media.message_preset_detail_id;
              entry.extra = media.extra;
            } else {
              if (media.mediaType === 'song') {
                entry.mediaid = media.mediaid;
                entry.playlistid = media.playlistid;
                entry.playlistType = scope.selectedStream.music_type;
              } else if (media.mediaType === 'message') {
                entry.mediaid = media.messageid;
                entry.message_preset_detail_id = media.message_preset_detail_id;
              }
            }
          }
        }

        return entry;
      }

    }
  };
}

app.directive('playlistNav', function() {
  return {
    restrict: 'E',
    replace: true,
    templateUrl: 'views/playlists_nav.html',
    controller: ['$scope', 'ENV', function($scope, ENV) {
      var playlistNav = [];
      if ($scope.me.permissions.user.select_music && $scope.navType === 'music') {
        playlistNav.push(
          {
            id:'public',
            name:'Stations',
            url:'/playlists/public',
            icon:'music'
          }
        );
        playlistNav.push(
          {
            id:'dayparting',
            name:'Dayparting',
            link:'dayparting',
            icon:'calendar',
            url:'/playlists/dayparting',
          }
        );
        playlistNav.push(
          {
            id:'mix',
            name:'Mix Stations',
            icon:'random',
            link:'playlists',
            url:'/playlists/mix',
          }
        );

        if(ENV.featureFlags && ENV.featureFlags.artistRadio && $scope.me.account.artist_radio === 1) {
          playlistNav.push(
            {
              id:'artistradio',
              name:'Artist Radio',
              icon:'user',
              link:'playlists',
              url:'/playlists/artistradio',
            }
          );
        }
      }
      if ($scope.me.subscription.messages > 0 && $scope.me.permissions.user.select_messages && $scope.navType === 'messaging') {
        playlistNav.push(
          {
            id:'messaging',
            name:'Presets',
            url:'/playlists/messaging',
            icon:'microphone'
          }
        );
        playlistNav.push(
          {
            id:'messageschedules',
            name:'Schedules',
            url:'/playlists/messageschedules',
            icon:'calendar'
          }
        );
      }
      $scope.playlistNav = playlistNav;
      for(var i=0;i<playlistNav.length;i++) {
        if (playlistNav[i].id == $scope.currentNav) {
          $scope.currentNavName = playlistNav[i].name;
          $scope.currentNavIcon = playlistNav[i].icon;
        }
      }
    }]
  }
});

app.directive('onDocumentClick', ['$document','$parse',function($document,$parse) {
  return {
    restrict: 'A',
    link: function(scope, element, attr) {
      var functionName = attr.onDocumentClick;
      var invoker = $parse(functionName);

      $document.on('click', function(event){
        scope.$apply(function() {
          invoker(scope,{$event: event});
        });
      });
    }
  }
}]);

app.directive('playlistScroll',['$timeout', function ($timeout) {
  return function (scope, elm, attr) {
    var raw = elm[0];
    elm.bind('scroll', function () {
      var el = document.getElementById("playlistToolbar");
      if (raw.scrollTop > 60) {
        el.classList.add('scrolling');
      }
      else if (el.classList.contains('scrolling')) {
        el.classList.remove('scrolling');
      }
    });
  };
}]);

app.directive('daypartingPlaylist', function () {
  return {
    restrict: 'E',
    scope: {
      playlist: '=',
      index: '=',
      lists: '='
    },
    controller: ['$scope', function($scope) {
      $scope.freqArray = [
        {value:10,name:'1 - Less'},
        {value:20,name:'2'},
        {value:30,name:'3'},
        {value:40,name:'4'},
        {value:50,name:'5'},
        {value:60,name:'6'},
        {value:70,name:'7'},
        {value:80,name:'8'},
        {value:90,name:'9'},
        {value:100,name:'10 - More'}
      ];

      $scope.remove = function () {
        $scope.lists.splice($scope.index,1);
      }

    }],
    templateUrl: 'views/mixplaylist.html'

  };
});

app.directive('publicStationFilter', function() {
  return {
    restrict: 'E',
    replace: true,
    templateUrl: function (elem, attrs) {
      return attrs.templateUrl || 'partials/playlists_public_station_filter.html';
    },
    scope: {
      searchQuery: '=',
      filterMethod: '&'
    },
    controller: [
      '$scope', '$rootScope', '$timeout', '$document', 'api', 'contentRatingService', 'contentRatingInfoModalService', 'playlistCategoryService',
      function($scope, $rootScope, $timeout, $document, api, contentRatingService, contentRatingInfoModalService, playlistCategoryService) {
        var dm = this;

        dm.filterStatus = {};
        dm.commonFilterList = {};
        dm.filterStatus = {};

        // public properties
        //-----------------------
        $scope.clearFilterList = false;
        $scope.commonFilters = {};
        $scope.musicFilterList = {};
        $scope.musicSelectionCategories = {};
        $scope.playlistStationFilter = {};
        $scope.showAll = true;
        $scope.showCategorySelect = false;

        // public methods
        //-----------------------
        $scope.checkFilter = checkFilter;
        $scope.collapseAllToggleCategory = collapseAllToggleCategory;
        $scope.resetAllFilters = resetAllFilters;
        $scope.resetFixedFilters = resetFixedFilters;
        $scope.resetFilter = resetFilter;
        $scope.showContentRatingsExplanation = showContentRatingsExplanation;
        $scope.toggleCategory = toggleCategory;
        $scope.toggleFilter = toggleFilter;
        $scope.toggleFilterExpansion = toggleFilterExpansion;

        // --------------------------

        init();

        $scope.$watch('clearFilterList', function(newvalue, oldvalue, scope) {
          if (newvalue === true) {
            $scope.playlistStationFilter = resetAllFilters();
            $scope.clearFilterList = false;
          }
        });

        $scope.$watch('searchQuery', function(oldvalue, newvalue, scope) {
          if ((oldvalue !== newvalue) && $scope.filterMethod) {
            if(oldvalue !== '') {
              $scope.resetFixedFilters();
            }
            $scope.filterMethod({
              filterStatus: $scope.playlistStationFilter,
              filterList: $scope.musicFilterList,
              searchQuery: $scope.searchQuery
            });
          }
        });

        $document.on('click', closeDropdown);

        $rootScope.$on('remove-filter', function(scope, filter, callback) {
          var index = dm.filterStatus[filter.type].indexOf(filter.id);
          if (index > -1) {
            dm.filterStatus[filter.type].splice(index, 1);
            callback(true, dm.filterStatus, $scope.musicFilterList, $scope.searchQuery);
          } else {
            callback(false);
          }
        })

        function checkFilter (filterType, id) {
          return (dm.filterStatus[filterType].indexOf(id) != -1);
        }

        function closeDropdown (ev) {
          if (dm.filterStatus.dropdown) {
            var onTarget = false;
            var menuList = document.querySelectorAll('.generic-public-station-filter-mobile-dropdown');
            for (var i = 0; i < menuList.length; i++) {
              if (menuList[i].contains(ev.target)) {
                onTarget = true;
                break;
              }
            }

            if (!onTarget) {
              var phase = $scope.$root.$$phase;
              if(phase == '$apply' || phase == '$digest') {
                dm.filterStatus.menuOpen.business = false;
                dm.filterStatus.menuOpen.genre = false;
                dm.filterStatus.menuOpen.mood = false;
                dm.filterStatus.menuOpen.rating = false;
                dm.filterStatus.dropdown = false;
              } else {
                $scope.$apply(function(){
                  dm.filterStatus.menuOpen.business = false;
                  dm.filterStatus.menuOpen.genre = false;
                  dm.filterStatus.menuOpen.mood = false;
                  dm.filterStatus.menuOpen.rating = false;
                  dm.filterStatus.dropdown = false;
                });
              }
            }
          }
        }

        function collapseAllToggleCategory (filterType) {
          dm.filterStatus.dropdown = false;
          var keys = Object.keys(dm.filterStatus.menuOpen);
          for( var k=0; k < keys.length; k++ ) {
            if (keys[k] === filterType) {
              if (dm.filterStatus.menuOpen[keys[k]]) {
                dm.filterStatus.menuOpen[keys[k]] = false;
              } else {
                dm.filterStatus.menuOpen[keys[k]] = true;
                dm.filterStatus.dropdown = true;
              }
            } else {
              dm.filterStatus.menuOpen[keys[k]] = false;
            }

            if (dm.filterStatus.expand[filterType]) {
              toggleFilterExpansion(filterType);
            }
          }
        }

        function init () {
          dm.commonFilterList = {
            business: [],
            genre: [],
            mood: [],
            rating: [],
          };

          dm.filterStatus = {
            business: [],
            genre: [],
            mood: [],
            rating: [],
            popular: false,
            newest: false,
            recent: false,
            pandora: false,
            favorites: false,
            drawerOpen: {
              genre: true,
              mood: false,
              business: false,
              rating: false,
            },
            menuOpen: {
              genre: false,
              mood: false,
              business: false,
              rating: false,
            },
            expand: {
              genre: false,
              mood: false,
              business: false,
              rating: false,
            },
            dropdown: true
          };
          $scope.playlistStationFilter = dm.filterStatus;

          $scope.commonFilters = playlistCategoryService.getCommonPlaylistCategories();

          api.getMusicSelectionCategories().then(function(results) {
            var ratingList = [];
            for (var category in results.category) {
              for (var item = 0; item < results.category[category].length; item++) {
                if ($scope.commonFilters[category] && $scope.commonFilters[category].indexOf(results.category[category][item].name) !== -1) {
                  results.category[category][item].popular = true;
                  dm.commonFilterList[category].push(results.category[category][item]);
                }
                else {
                  results.category[category][item].popular = false;
                }
              }
            }
            $scope.musicSelectionCategories = results.category;
            ratingList = Object.values(contentRatingService.getAllContentRatingDetails());
            $scope.musicFilterList = {
              business: $scope.musicSelectionCategories.business,
              genre:    $scope.musicSelectionCategories.genre,
              mood:     $scope.musicSelectionCategories.mood,
              rating:   ratingList.map(function (rating) {
                return {
                  id: rating.id,
                  name: rating.rating,
                  popular: true
                }
              })
            };
            $rootScope.$broadcast('playlistFiltersInitialized');
          });

        }

        function resetFixedFilters() {
          dm.filterStatus.popular = false;
          dm.filterStatus.newest = false;
          dm.filterStatus.favorites = false;
          dm.filterStatus.recent = false;
          dm.filterStatus.pandora = false;
          return dm.filterStatus;
        }

        function resetAllFilters() {
          dm.filterStatus.business = [];
          dm.filterStatus.genre = [];
          dm.filterStatus.mood = [];
          dm.filterStatus.rating = [];
          dm.filterStatus.expand.business = false;
          dm.filterStatus.expand.genre = false;
          dm.filterStatus.expand.mood = false;
          dm.filterStatus.expand.rating = false;
          return resetFixedFilters();
        }

        function resetFilter(filterType) {
          if (filterType == 'all') {
            dm.filterStatus = resetAllFilters();
          }
          else {
            dm.filterStatus[filterType] = [];
          }

          if ($scope.filterMethod) {
            $scope.filterMethod({
              filterStatus: $scope.playlistStationFilter,
              filterList: $scope.musicFilterList,
              searchQuery: $scope.searchQuery
            });
          }

          $scope.playlistStationFilter = dm.filterStatus;
        }

        function showContentRatingsExplanation () {
          contentRatingInfoModalService.open().catch(angular.noop);
        };

        function siftFilter(category,filter) {
          var stationFilter = {};

          if (category === 'popular') {
            dm.filterStatus = resetAllFilters();
            dm.filterStatus.popular = true;
            stationFilter = dm.filterStatus;
          }
          else if (category === 'newest') {
            dm.filterStatus = resetAllFilters();
            dm.filterStatus.newest = true;        
            stationFilter = dm.filterStatus;
          }
          else if (category === 'pandora') {
            dm.filterStatus = resetAllFilters();
            dm.filterStatus.pandora = true;
            stationFilter = dm.filterStatus;
          }
          else if (category === 'favorites') {
            dm.filterStatus = resetAllFilters();
            dm.filterStatus.favorites = true;
            stationFilter = dm.filterStatus;
          }
          else if (category === 'recent') {
            dm.filterStatus = resetAllFilters();
            dm.filterStatus.recent = true;
            stationFilter = dm.filterStatus;
          }
          else if (dm.filterStatus[category].indexOf(filter) > -1) {
            dm.filterStatus = resetFixedFilters();
            stationFilter = dm.filterStatus;
            stationFilter[category] = dm.filterStatus[category].filter(function(val, idx, arr) {
              return val != filter;
            });
          } else {
            dm.filterStatus = resetFixedFilters();
            stationFilter = dm.filterStatus;
            stationFilter[category].push(filter);
            // Ratings ought to be sorted.
            // Other categories should not since the filter uses AND logic and each
            // filter is built upon another.  So the order of picking the filters is important.
            if (category === 'rating') {
              stationFilter[category].sort();
            }
          }
          return stationFilter;
        }

        function toggleCategory (filterType) {
          if ($scope.playlistStationFilter.drawerOpen[filterType]) {
            $scope.playlistStationFilter.drawerOpen[filterType] = false;
            if ($scope.playlistStationFilter.expand[filterType]) {
              $scope.toggleFilterExpansion(filterType);
            }
          } else {
            $scope.playlistStationFilter.drawerOpen[filterType] = true;
          }
        }

        function toggleFilter (filterType, filterId) {
          $scope.playlistStationFilter = siftFilter(filterType,filterId);
          if ($scope.filterMethod) {
            $scope.filterMethod({
              filterStatus: $scope.playlistStationFilter,
              filterList: $scope.musicFilterList,
              searchQuery: $scope.searchQuery
            });
          }
        }

        function toggleFilterExpansion (filterType) {
          $scope.playlistStationFilter.expand[filterType] = !$scope.playlistStationFilter.expand[filterType];
        }

      }
    ]
  };
});

app.directive('genericPublicStationFilterMobileDropdown', function() {
  return {
    restrict: 'E',
    replace: false,
    templateUrl: function (elem, attrs) {
      return attrs.templateUrl || 'partials/generic_public_station_filter_mobile_dropdown.html';
    },
    scope: {
      collapseAllToggleCategory: '&',
      checkFilter: '&',
      toggleFilter: '&',
      category: '@',
      icon: '@',
      title: '@',
      filterStatus: '=',
      musicFilterList: '=',
    },
  }
});

app.directive('genericPublicStationFilterDesktopSelector', function() {
  return {
    restrict: 'E',
    replace: false,
    templateUrl: function (elem, attrs) {
      return attrs.templateUrl || 'partials/generic_public_station_filter_desktop_selector.html';
    },
    scope: {
      checkFilter: '&',
      resetFilter: '&',
      showContentRatingsExplanation: '&',
      toggleCategory: '&',
      toggleFilter: '&',
      toggleFilterExpansion: '&',
      category: '@',
      icon: '@',
      showCategoryFilter: '@',
      title: '@',
      commonFilters: '=',
      filterStatus: '=',
      musicFilterList: '=',
    },
  };
});





app.directive("passwordVerify", function() {
  return {
    require: "ngModel",
    scope: {
      otherModelValue: "=passwordVerify"
    },
    link: function(scope, element, attrs, ctrl) {
      ctrl.$validators.passwordVerify = function(modelValue) {
        return modelValue == scope.otherModelValue;
      };

      scope.$watch("otherModelValue", function() {
        ctrl.$validate();
      });
    }
  };
});

app.directive('ensureUnique', ['$http', 'api', function($http, api) {
  return {
    require: 'ngModel',
    link: function(scope, ele, attrs, c) {
      scope.$watch(attrs.ngModel, function() {

      	c.$setValidity('unique', true);
        c.$setValidity('chars', true);

      	if (!scope.formdata.username || scope.formdata.username.length < 4) return;

      	if (!scope.formdata.username.match(/^[\w\-.@]+$/)) {
          return c.$setValidity('chars', false);
          }

          api.checkUsername(scope.formdata.username,function(result) {
            if (result.available) {
              c.$setValidity('unique', true);
            } else {
              c.$setValidity('unique', false);
            }
          }, function(err) {
            console.error('Error checking username: ', err);
          });

      });
    }
  }
}]);

app.directive('rollOver', function () {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      element.rolloutTimer = null;

      $(element).mouseover(function () {
        clearTimeout(element.rolloutTimer);
        $(element).addClass(attrs.rollOver);
      });

      $(element).mouseout(function () {
        element.rolloutTimer = setTimeout(function () {
          $(element).removeClass(attrs.rollOver);
        }, 300);
      });
    }
  };
});

app.directive('daypartingeditUnique', ['$q', '$http', 'api', function($q, $http, api) {
  return {
    require: 'ngModel',
    link: function(scope, ele, attrs, c) {
      scope.$watch(attrs.ngModel, function() {

        c.$asyncValidators.daypartUniqueName = function(modelValue, viewValue) {

          if (!scope.formData.name || scope.formData.name.length < 4) {
            return $q.resolve();
          }

          var def = $q.defer();
          var data = {name:scope.formData.name,daypartingid:scope.formData.daypartingid};
          c.$setValidity('unique', true);
          if (data.daypartingid) {
            api.checkDaypartingNameEdit(data,function(result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            },function(err){
              console.log("Error occured when calling checkDaypartingNameEdit when in daypartingeditUnique directive.");
              def.reject();
            });
          } else {
            api.checkDaypartingNameAdd(data.name,function(result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            },function(err){
              console.log("Error occured when calling checkDaypartingNameAdd when in daypartingUnique directive.");
              def.reject();
            });
          }

          return def.promise;
        };
      });
    }
  };
}]);

app.directive('stationeditUnique', ['$q', '$http', 'api', function($q, $http, api) {
  return {
    require: 'ngModel',
    link: function(scope, ele, attrs, c) {
      scope.$watch(attrs.ngModel, function() {

        c.$asyncValidators.stationUniqueName = function(modelValue, viewValue) {
          if ((!scope.formData || !scope.formData.name || scope.formData.name.length < 4) && (!scope.vm || !scope.vm.formData.name || scope.vm.formData.name.length < 4)) {
            return $q.resolve();
          }
          var def = $q.defer();
          var data;
          if (scope.vm.formData) {
            data = {
              name: scope.vm.formData.name,
              mixid: scope.vm.formData.mixid
            };
          } else if (scope.formData) {
            data = {
              name: scope.formData.name,
              mixid: scope.formData.mixid
            };
          }
          c.$setValidity('unique', true);

          if (data.mixid) {
            api.checkStationNameEdit(data, function (result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            }, function (err){
              console.log("Error occured when calling checkDaypartingNameEdit when in stationeditUnique directive.");
              def.reject();
            });
          } else {
            api.checkStationNameAdd(data.name,function (result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            }, function (err){
              console.log("Error occured when calling checkDaypartingNameAdd when in stationUnique directive.");
              def.reject();
            });
          }

          return def.promise;
        };
      });
    }
  };
}]);

app.directive('preseteditUnique', ['$q', '$http', 'api', function($q, $http, api) {
  return {
    require: 'ngModel',
    link: function(scope, ele, attrs, c) {
      scope.$watch(attrs.ngModel, function() {

        c.$asyncValidators.uniquePresetName = function(modelValue, viewValue) {
          if (!scope.formData.name || scope.formData.name.length < 4) {
            return $q.resolve();
          }
          var def = $q.defer();
          var data = {name:scope.formData.name,presetid:scope.formData.presetid};
          c.$setValidity('unique', true);

          if (data.presetid) {
            api.checkMessageNameEdit(data,function(result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            },function(err){
              console.log("Error occured when calling checkDaypartingNameEdit when in preseteditUnique directive.");
              def.reject();
            });
          } else {
            api.checkMessageNameAdd(data.name,function(result) {
              if (result.available) {
                c.$setValidity('unique', true);
                def.resolve();
              } else {
                c.$setValidity('unique', false);
                def.reject();
              }
            },function(err){
              console.log("Error occured when calling checkDaypartingNameAdd when in presetUnique directive.");
              def.reject();
            });
          }

          return def.promise;
        }
      });
    }
  };
}]);

app.directive('searchField', function () {
  return {
    require: 'ngModel',
    restrict: 'A',
    scope: {},
    link: function (scope, elem, attrs, ctrl) {

      // Bind to the mouseup event of the input textbox.  
      elem.bind('mouseup', function () {

        // Get the old value (before click) and return if it's already empty
        // as there's nothing to do.
        var $input = $(this), oldValue = $input.val();
        if (oldValue === '') return;

        // Check new value after click, and if it's now empty it means the
        // clear button was clicked. Manually trigger element's change() event.
        setTimeout(function () {
          var newValue = $input.val();
          if (newValue === '') {
            angular.element($input).change();
          }
        }, 1);
      });
    }
  }
});

(function() {
  app.directive("showTooltipOnTextOverflow", ['$timeout', showTooltipOnTextOverflow]);

  function showTooltipOnTextOverflow ($timeout) {
    return {
      restrict: 'A',
      link: function (scope, element, attrs) {
        var el = element[0];
        scope.$watch( function () {
          return el.scrollWidth;
        }, function () {
          var el = element[0];
          if (el.offsetWidth < el.scrollWidth) {
            //console.log('ellipsis is active for element', element);
            attrs.tooltipEnable = "true";
          } else {
            //console.log('ellipsis is NOT active for element', element);
          }
        });
      }
    }
  }

})();

app.directive('ccmStreamEditUnique', streamEditUnique);

streamEditUnique.$inject = ['$q', 'api'];

function streamEditUnique($q, api) {
  return {
    require: 'ngModel',
    scope: {
      ccmStreamEditUniqueUserId: '='
    },
    link: function (scope, elem, attrs, ngModelCtrl) {
      ngModelCtrl.$asyncValidators.streamEditUnique = function (modelValue, viewValue) {
        var value = modelValue || viewValue;
        var shouldValidateStreamName = value && scope.ccmStreamEditUniqueUserId;
        if (!shouldValidateStreamName) {
          return $q.resolve();
        }

        return api
          .checkUniqueStreamname({
            streamname: modelValue,
            userid: scope.ccmStreamEditUniqueUserId
          })
          .then(function (result) {
            var isStreamnameAvailable = result && result.available;
            if (!isStreamnameAvailable) {
              return $q.reject();
            }
          });
      };

      scope.$watch('ccmStreamEditUniqueUserId', function (newValue, oldValue) {
        if (newValue != oldValue) {
          ngModelCtrl.$validate();
        }
      });
    }
  };
}

app.directive("touchStation", ['$window', function ($window) {
  return {
    restict: 'A',
    scope: true,
    link: function (scope, el, attr) {
      var activate = function() {
        var value;
        if (scope.station.musicid)
          value = scope.station.musicid;
        else if (scope.schedule.scheduleid)
          value = scope.schedule.scheduleid;
        else if (scope.preset.presetid)
          value = scope.preset.presetid;
        scope.setTouchActive(value);
      }

      if ($window.PointerEvent) {
        el.bind("pointerdown", function (ev) {
          var event = ev.originalEvent || ev;
          if (event.pointerType === 'touch') {
            activate();
          }
        });
        el.bind("pointerleave", function (ev) {
          var event = ev.originalEvent || ev;
          if (event.pointerType !== 'touch') {
            scope.setTouchActive(null);
          }
        });
        el.bind("pointerenter", function (ev) {
          var event = ev.originalEvent || ev;
          if (event.pointerType !== 'touch') {
            activate();
          }
        });
      } else {
        el.bind("mouseenter", function() {
          activate();
        });
        el.bind("mouseleave", function() {
          scope.setTouchActive(null);
        });
      }
      // prevent right click and visual square that appears on touchscreens when holding down
      el.bind("contextmenu", function(e) {
        e.preventDefault();
      });
      el.bind("MSHoldVisual", function(e) {
        e.preventDefault();
      });
    }
  };
}]);

(function() {
  app.directive("triToggle", triToggleController);

  triToggleController.$inject = ['$timeout', 'confirmationDialog'];

  function triToggleController ($timeout, confirmationDialog) {
    return {
      restrict: 'E',
      replace: true,
      transclude: true,
      scope: {
        guardFalseMessage: '=?',
        guardTruthMessage: '=?',
        ngModel: '=?',
        showLabels: '=?',
        toggleGuard: '=?',
        val: '=ngModel',
        guardMethod: '&?',
        onChange: '&onChange',
        setState: '&',
        disabled: '=?'
      },
      templateUrl: function (elem, attrs) {
        return attrs.templateUrl || 'partials/tri_toggle.html';
      },
      link: function(scope, elem, attrs) {
        scope.trueVal = 1;
        scope.falseVal = 0;
        scope.offVal = -1;
        scope.toggle = toggle;
        scope.toggleTrue = toggleTrue;
        scope.toggleFalse = toggleFalse;
        scope.setState = setState;

        if (angular.isDefined(scope.showLabels) && String(scope.showLabels).toLowerCase() === 'false') {
          scope.showLabels = false;
        }
        else {
          scope.showLabels = true;
        }
        if (!angular.isDefined(scope.onLabel)) {
          scope.onLabel = 'on';
        }
        if (!angular.isDefined(scope.offLabel)) {
          scope.offLabel = 'off';
        }

        function toggle () {
          if (scope.val === scope.trueVal) {
            toggleValue(scope.falseVal);
          } else if (scope.val === scope.falseVal) {
            toggleValue(scope.offVal);
          } else {
            toggleValue(scope.trueVal);
          }
        }

        function setState (state) {
          if (state > scope.falseVal) {
            updateVal(scope.trueVal);
          }
          else if (state === scope.falseVal) {
            updateVal(scope.falseVal);
          }
          else {
            updateVal(scope.offVal);
          }
        }

        function toggleTrue () {
          if (scope.val !== scope.trueVal) {
            toggleValue(scope.trueVal);
          }
        }

        function toggleFalse () {
          if (scope.val !== scope.falseVal) {
            toggleValue(scope.falseVal);
          }
        }

        function toggleValue (val) {
          if (
            angular.isDefined(scope.toggleGuard) &&
            angular.isDefined(scope.guardTruthMessage) &&
            angular.isDefined(scope.guardFalseMessage) &&
            angular.isDefined(scope.guardMethod) &&
            scope.toggleGuard === true
          ) {
            var message;
            if (val === scope.trueVal) {
              message = scope.guardTruthMessage;
            } else {
              message = scope.guardFalseMessage;
            }
            confirmationDialog({buttonText: 'OK'},
              message,
              function() {
                scope.guardMethod({value: val});
              }, null
            ).catch(angular.noop);
          } else {
            updateVal(val);
          }
        }

        function updateVal (val) {
          scope.val = val;
          if (angular.isDefined(scope.ngModel)) {
            scope.ngModel = scope.val;
          }
          if (typeof scope.onChange != 'undefined') {
            $timeout(function() {
              scope.onChange({value: scope.val});
            });
          }
        }

      }
    }
  }
})();

app.directive('trialConversion', function() {
  return {
    restrict: 'A',
    replace: false,
    templateUrl: 'views/trial_conversion.html',
    controller: ['$scope', 'api', 'signUpData', 'ENV', 'intercom', 'subscriptionInfo', 'couponService', 'confirmationDialog', function($scope, api, signUpData, ENV, intercom, subscriptionInfo, couponService, confirmationDialog) {
      var fullName, first_name, last_name, planInfo;

      // subscription button should initially be disabled to ensure all required fields are filled in
      $scope.enableSubscriptionButton = false;

      // setup defaults
      $scope.formStep = 1;
      $scope.timezones = window.timeZones;
      $scope.billFrequency = 'Monthly';
      $scope.reactivationFee = 2500;
      $scope.coupon_error = null;
      $scope.coupon = null;
      $scope.plan = {};
      $scope.loading = {
        payment: false,
        subscription: false
      };
      $scope.totalCharge = 0;

      init();

      function init() {
        if (!api.userObject.recurly || !api.userObject.recurly.state) {
          $scope.loading.subscription = true;
        }

        if (api.userObject.account.recurly) {
          $scope.loading.payment = true;
        }

        api.getSubscription()
          .then(function (subscription) {
            return subscriptionInfo.calculateAddonStreams(subscription);
          })
          .then(function (addonStreams) {
            $scope.subscription.addonStreams = addonStreams;

            if ($scope.convertingTrial || $scope.trialExpired || $scope.subscriptionExpired) {
              setPlanValues();
            }

            $scope.loading.subscription = false;
          })
          .then(function () {
            if (!api.userObject.account.recurly) {
              subscriptionInfo.setPaymentStatus(false);

              return;
            }

            return api.getPayment()
              .then(function (payment) {
                var hasPayment = payment.last_four || api.userObject.recurly.collection_method === 'manual';
                if (hasPayment) {
                  $scope.subscription.paymentInfo = payment;
                }

                subscriptionInfo.setPaymentStatus(hasPayment);

                if ($scope.subscription.state === 'expired' && payment !== 'No Billing Information Found') {
                  return api.getBalance(api.userObject.custid)
                    .then(function (balance) {
                      $scope.subscription.balance = balance;
                      $scope.updateTotalCharge();
                    });
                }
              });
          })
          .finally(function () {
            $scope.loading.payment = false;
            $scope.loading.subscription = false;

            // if customer payment information exists (perhaps from CloudBox order), then
            // skip billing fields by default.  Customer can choose to override.
            if ($scope.subscription.paymentInfo && $scope.subscription.paymentInfo.last_four) {
              $scope.skipBillingUpdate = true;
            }

            $scope.setButtonState();
          });
      }

      var setValues = function() {
        $scope.plan = subscriptionInfo.getPlanOfferings($scope.plans,$scope.annualBilling);
      };

      var clearMessages = function() {
        $scope.displayMessage = false;
        $scope.displayErrorMessage = false;
        $scope.message = '';
        $scope.errorMessage = '';
      };

      // tbrown 03-02-17  Can't have this in $scope, it overrides an existing function.
      // showMessage and showScreen are not in $scope, so they're ok to add here.  (For now.)
      var showError = function(message) {
        if (message === undefined)
          message = "There was an error activating this account, please contact Customer Support at (844) 422-6249 for assistance.";
        $scope.displayErrorMessage = true;
        $scope.errorMessage = message;
        $scope.formLoading = false;
        $scope.enableSubscriptionButton = false;
      };

      // determine if submit button should be enabled
      $scope.setButtonState = function() {
        clearMessages();
        if ($scope.convertingTrial || $scope.trialExpired) {
          if (
            (!$scope.formData.corporateAddress || $scope.formData.corporateAddress.length === 0) ||
            (!$scope.formData.corporateCity || $scope.formData.corporateCity.length === 0) ||
            (!$scope.formData.corporatePostal || $scope.formData.corporatePostal.length === 0) ||
            (!$scope.formData.timezone || $scope.formData.timezone.length === 0) ||
            ($scope.formData.corporateState == 'State/Province') ||
            ($scope.formData.corporateCountry == 'Country')
          ) {
            $scope.enableSubscriptionButton = false;
            return;
          }
        }

        if (!$scope.skipBillingUpdate) {
          var error = false;
          var errors = [];
          if (
            !$scope.formData ||
            (!$scope.formData.firstName || $scope.formData.firstName.length === 0) ||
            (!$scope.formData.lastName || $scope.formData.lastName.length === 0) ||
            (!$scope.formData.billingAddress || $scope.formData.billingAddress.length === 0) ||
            (!$scope.formData.billingCity || $scope.formData.billingCity.length === 0) ||
            (!$scope.formData.billingPostal || $scope.formData.billingPostal.length === 0) ||
            ($scope.formData.billingState == 'State/Province') ||
            ($scope.formData.billingCountry == 'Country')
          ) {
            $scope.enableSubscriptionButton = false;
            return;
          }
          if (error) {
            $scope.enableSubscriptionButton = false;
            showError(errors.join(', '));
            return;
          }
          // if all other fields ok, but Recurly form is invalid, disable button
          if (!validRecurlyForm) {
            $scope.enableSubscriptionButton = false;
            return;
          }
        }

        //only enable cc update button if actually making a change
        if ($scope.updatingCard && $scope.skipBillingUpdate) {
          $scope.enableSubscriptionButton = false;
          return;
        }
        $scope.enableSubscriptionButton = true;
        return;
      };

      $scope.openIntercom = function() {
        Intercom('show');
      };

      function mapFromVendorCode(vendorCode) {
        var result = {
          selectedPlan: '',
          planPeriod: '',
        };
        result.selectedPlan = $scope.plans[vendorCode].name;
        result.addon_stream_amount_in_cents = $scope.plans[vendorCode].addon_stream_amount_in_cents;
        if (vendorCode.match('annual')) result.planPeriod = 'yr';
        else if (vendorCode.match('6mos')) result.planPeriod = '6 mo';
        else result.planPeriod = 'mo';
        return result;
      }

      function setPlanValues() {
        // format monthly plan price, use userObject instead of since userObject is updated as soon as plan is updated
        if (!$scope.planCode) {
          $scope.planCode = $scope.subscription.vendor_code;
          $scope.planPrice = ($scope.subscription.unit_amount_in_cents / 100);
        }
        // format plan name
        $scope.planQuantity = $scope.subscription.quantity;
        $scope.planTotalCost = ($scope.planQuantity * $scope.planPrice);
        planInfo = mapFromVendorCode($scope.planCode);
        $scope.selectedPlan = planInfo.selectedPlan;
        $scope.planPeriod = planInfo.planPeriod;
        if ($scope.planPeriod === 'yr') {
          $scope.planPricePerMonth = ($scope.planPrice / 12);
          $scope.billFrequency = 'Annual';
          $scope.annualBilling = true;
        } else {
          $scope.planPricePerMonth = $scope.planPrice;
          $scope.billFrequency = 'Monthly';
          $scope.annualBilling = false;
        }
        if ($scope.subscription.addonStreams) {
          if (!$scope.addonStreams) {
            $scope.addonStreams = {};
          }

          $scope.addonStreams.price = planInfo.addon_stream_amount_in_cents / 100;
          $scope.addonStreams.quantity = $scope.subscription.addonStreams.quantity._;

          if (planInfo.addon_stream_amount_in_cents !== $scope.subscription.addon_stream_amount_in_cents) {
            if (
              planInfo.addon_stream_amount_in_cents !== 0 &&
              ((planInfo.planPeriod === 'yr' && $scope.subscription.vendor_code.match('annual')) || (planInfo.planPeriod === 'mo' && !$scope.subscription.vendor_code.match('annual')))
            ) {
              $scope.addonStreams.price = $scope.subscription.addon_stream_amount_in_cents / 100;
            }
          }
          $scope.planTotalCost += $scope.addonStreams.price * $scope.addonStreams.quantity;
        } else {
          $scope.addonStreams = null;
        }
        setValues();
        $scope.updateTotalCharge();
      }
      // reset plan values when changing plan while in trial from billing tab
      var resetPlanCode = function() {
        $scope.planCode = null;
        setPlanValues();
      };

      function resetForm() {
        resetPlanCode();
        $scope.formData.firstName = '';
        $scope.formData.lastName = '';
        $scope.formData.billingAddress = '';
        $scope.formData.billingCity = '';
        $scope.formData.billingState = 'State/Province';
        $scope.formData.billingPostal = '';
        $scope.formData.billingCountry = 'Country';
      }
      var openForm = function() {
        $scope.setButtonState();
        document.body.style.width = document.body.clientWidth+'px';
        document.body.style.height = document.body.clientHeight+'px';
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'fixed';
      };

      $scope.closeBillingForm = function() {
        $scope.resetFocus();
        document.body.style.width = '';
        document.body.style.height = '';
        document.body.style.position = 'relative';
        document.body.style.overflow = 'auto';
        resetForm();
        $scope.$emit('closeBillingForm');
      };

      if ($scope.convertingTrial || $scope.trialExpired || $scope.subscriptionExpired) {
        openForm();
      }

      // the billing form is not only used for trial conversion, but also for
      // Cloud Box orders and updating customers credit card info
      if ($scope.orderingBox || $scope.updatingCard) {
        openForm();
      }

      $scope.locationMonitoring = false;
      $scope.statesProvinces = window.statesProvinces;
      $scope.years = [];
      var d = new Date();
      for (var i=0;i<5;i++) {
        $scope.years[i] = d.getFullYear()+i;
      }

      $scope.businessTypes = signUpData.businessTypes;
      $scope.businessModel = signUpData.businessModel;
      $scope.previousService = signUpData.previousService;
      $scope.customerProfiles = signUpData.customerProfiles;

      $scope.showMusicInfo = false;
      $scope.showManageInfo = false;
      $scope.showProfessionalInfo = false;

      $scope.accountInfo = {
        info_type_account: 'Business Type',
        info_customer_profile: 'Customer Profile',
        info_previous_service: 'Previous Service',
        skipBilling: true  // not to be confused with $scope.skipBillingUpdate.
                          // This value is sent with account update.
      };

      $scope.updateCouponCode = function() {
        couponService.updateCouponCode({coupon_code: $scope.formData.coupon, redemption_type: 'subscription'}, function(coupon, coupon_error) {
          $scope.coupon = coupon;
          $scope.coupon_error = coupon_error;
        });
      };

      // total price is affected by reactivation status
      $scope.updateTotalCharge = function() {
        var total = ($scope.subscription.balance / 100) + ($scope.subscription.quantity * parseFloat($scope.planPrice));

        if ($scope.addonStreams) {
          total += parseInt($scope.addonStreams.quantity, 10) * $scope.addonStreams.price;
        }

        if ($scope.subscription.is_overdue) {
          total += $scope.reactivationFee / 100;
        }

        $scope.totalCharge = total;
      };

      $scope.showMessage = function(message) {
        $scope.displayMessage = true;
        $scope.message = message;
        $scope.formLoading = false;
      };

      $scope.showScreen = function(screen) {
        $scope.formStep = screen;
      };

      // recurly hosted form setup
      var validRecurlyForm = false;

      var recurlyConfig = {
        publicKey: ENV.recurlyPublicKey,
        required: ['cvv', 'country'],
        fields: {
          all: {
            style: {
              fontFamily: 'Source Sans Pro',
              fontSize: '16px',
              fontColor: '#33333',
              placeholder: {
                color: '#9b9ea5'
              }
            }
          }
        }
      };

      if (ENV.recurlyFraudDetectionEnabled) {
        recurlyConfig.fraud = {
          kount: {
            dataCollector: true,
            form: document.querySelector('.form.recurly-form form')
          }
        };
      }

      recurly.configure(recurlyConfig);

      // track status of recurly fields
      recurly.on('change', function(recurlyState) {
        var recurlyFields = recurlyState.fields;
        // to add hasValue class, need to check if Recurly hosted fields are empty by iterating over recurlyState nested object
        for (var key in recurlyFields) {
          if (!recurlyFields.hasOwnProperty(key)) return;

          var fieldObj = recurlyFields[key];

          for (var prop in fieldObj) {
            if (!fieldObj.hasOwnProperty(prop)) return;

            var el = "#recurly-" + key;
            if (fieldObj.length > 0) {
              if (!$(el).hasClass('hasValue')) {
                $(el).addClass('hasValue');
              }
            } else {
              if ($(el).hasClass('hasValue')) {
                $(el).removeClass('hasValue');
              }
            }
          }
        }

        if (recurlyFields.cvv.empty || recurlyFields.month.empty || recurlyFields.number.empty || recurlyFields.year.empty) {
          validRecurlyForm = false;
          $scope.setButtonState();
        } else {
          validRecurlyForm = true;
          $scope.setButtonState();
        }
      });

      $scope.resetSameAsBilling = function() {
        $scope.formData.useBillingAddressForCorporate = false;
      }

      $scope.resetFocus = function() {
        var recurlyFields = document.querySelectorAll('.trial-expiration .billing .recurly');
        for(var i=0;i<recurlyFields.length;i++) {
          recurlyFields[i].classList.remove('focused');
        }
      }

      // adjust UI for monthly vs. annual billing options
      $scope.setMonthlyBilling = function() {
        $scope.annualBilling = false;
        $scope.billFrequency = 'Monthy';
        setValues();
      };
      $scope.setAnnualBilling = function() {
        $scope.annualBilling = true;
        $scope.billFrequency = 'Annual';
        setValues();
      };

      // adjust UI for Account level
      $scope.toggleInfo = function(plan) {
        if (plan === 'music') {
          $scope.showMusicInfo = !$scope.showMusicInfo;
        } else if (plan === 'manage') {
          $scope.showManageInfo = !$scope.showManageInfo;
        } else if (plan === 'messaging') {
          $scope.showMessagingInfo = !$scope.showMessagingInfo;
        }
      };

      $scope.selectPlan = function(plan) {
        if (
          $scope.addonStreams &&
          (plan.vendor_code === 'standard' || plan.vendor_code === 'annual_standard_10disc') &&
          (!$scope.selectedPlan.match(/music/i))
        ) {
          confirmationDialog({planName: 'Music', templateUrl: 'partials/downgrade_modal.html'}, '', function(success) {
            return;
          }, function(reject) {});
        } else {
          $scope.planCode = plan.vendor_code;
          $scope.selectedPlan = plan.name;
          if ($scope.annualBilling) {
            $scope.planPeriod = 'yr';
            $scope.planPrice = plan.annualPrice;
          } else {
            $scope.planPeriod = 'mo';
            $scope.planPrice = plan.dollar+'.'+plan.change;
          }
          $scope.planBasePrice = $scope.planPrice;
          setPlanValues();
          $scope.showScreen(1);
        }
      };

      $scope.updateCCDetails = function() {
        $scope.skipBillingUpdate = false;
        $scope.showBillingCancelBtn = true;
        $scope.setButtonState();
      };

      $scope.cancelCCUpdate = function() {
        $scope.skipBillingUpdate = true;
        $scope.setButtonState();
      };

      var isUpdatingCorpAddr = function() {
        if ($scope.formData.corporateAddress !== $scope.ccmAccount.street_address ||
            $scope.formData.corporateCity !== $scope.ccmAccount.city ||
            $scope.formData.corporateState !== $scope.ccmAccount.state ||
            $scope.formData.corporatePostal !== $scope.ccmAccount.zipcode ||
            $scope.formData.corporateCountry !== $scope.ccmAccount.country ||
            $scope.formData.timezone.length)
        {
          return true;
        } else {
          return false;
        }
      };

      var hasLocAddress = function() {
        if ($scope.userAddress.street) {
          return true;
        } else {
          return false;
        }
      };

      $scope.subscribe = function() {
        // if the button is disabled, then do nothing.
        if (!$scope.enableSubscriptionButton) {
          clearMessages();
          $scope.showMessage("Please fill in all form fields before hitting Subscribe");
          return;
        }

        $scope.formLoading = true;

        // if we made it this far, then disable button to prevent double click
        $scope.enableSubscriptionButton = false;

        if ($scope.formData.corporateAddress.length > 0 &&
            (isUpdatingCorpAddr() || !hasLocAddress()))
        {
          var corporateData = {
            street_address: $scope.formData.corporateAddress,
            city: $scope.formData.corporateCity,
            state: $scope.formData.corporateState,
            zipcode: $scope.formData.corporatePostal,
            country: '',
            userid: hasLocAddress() ? null : api.userObject.user.userid,
            timezone: $scope.formData.timezone
          };
          if ($scope.formData.corporatePostal.match(/[a-z]/i)) {
            corporateData.country = 'CA';
          } else {
            corporateData.country = 'US';
          }
          api.updateCorporateAddress(api.userObject.account.custid, corporateData, function(result) {
            console.log("Successfully updated corporate address information.");
          });
        }

        // if either Payment Info was not on file, or customer chose to update Payment Info
        if (!$scope.skipBillingUpdate) {
          if ($scope.ccmAccount.contact_name) {
            fullName = $scope.ccmAccount.contact_name.split(' ');
            first_name = fullName.shift();
            last_name = fullName.join(' ');
          } else {
            first_name = $scope.formData.firstName;
            last_name = $scope.formData.lastName;
          }

          var billingAccount = {
            company_name: api.userObject.account.name,
            username: api.userObject.user.username,
            email: api.userObject.user.email,
            first_name: first_name,
            last_name: last_name,
            phone: $scope.ccmAccount.phone
          };

          // if customer already has a recurly account, then this API call simply returns existing
          // customer data.  Otherwise it creates a new recurly account and returns recurly ID
          api.createBillingAccount(billingAccount, function(result) {
            var form = $('.recurly-form form');
            recurly.token(form, function(err, token) {
              if (err) {
                var errFields = [];
                if (err.fields) {
                  for (var i=0;i<err.fields.length;i++) {
                    var numRegex = /^number/;
                    var monthRegex = /^month/;
                    var yearRegex = /^year/;
                    if (numRegex.test(err.fields[i])) {
                      errFields.push("Credit Card Number");
                    } else if (monthRegex.test(err.fields[i]) || yearRegex.test(err.fields[i])) {
                      if (errFields.indexOf('Expiration Date') === -1) {
                        errFields.push('Expiration Date');
                      }
                    } else {
                      errFields.push(err.fields[i]);
                    }
                  }
                  var errMessage = errFields.join(', ');
                  showError('The following fields appear to be invalid: ' + errMessage);
                } else {
                  showError('An unknown error has occurred processing your updates.  Please try again.');
                  intercom.sendEvent('Billing Update Failed', {
                    "account": result.account.custid,
                    "contact": result.account.contact_name,
                    "error_code": (err.code) ? err.code : "none supplied",
                    "error_message": (err.message) ? err.message : "none supplied",
                    "error_name": (err.name) ? err.name : "none supplied",
                  });
                }
              } else {
                var billingData = {
                  account_code: result.account.recurly,
                  token_id: token.id,
                  custid: $scope.ccmAccount.custid
                };
                api.updateBillingInfo(billingData, function(result) {
                  if ($scope.orderingBox || $scope.updatingCard) {
                    $scope.formLoading = false;
                    subscriptionInfo.setPaymentStatus(true);
                    $scope.$emit('refreshPaymentInfo');
                    $scope.closeBillingForm();
                    return;
                  } else {
                    // if not just ordering box, create subscription
                    api.subscribe($scope.planCode, $scope.formData.coupon, function() {
                      console.log("subscription successfully created");
                      $scope.showScreen(2);
                      $scope.formLoading = false;
                      intercom.sendEvent('Trial Converted To Subscription', {});
                    }, function(err) {
                      console.log("Failed to create subscription.",err);
                      intercom.sendEvent('Trial Conversion Failed', {});
                      showError();
                    });
                  }
                }, function(err) {
                  if (err.message) {
                    showError(err.message);
                  }
                });
              }
            });
          }, function(err) {
            console.log("Error creating billing account", err);
            $scope.formLoading = false;
          });
        } else {
          // create subscription
          api.subscribe($scope.planCode, $scope.formData.coupon, function() {
            console.log("subscription successfully created");
            $scope.showScreen(2);
            $scope.formLoading = false;
            intercom.sendEvent('Trial Converted To Subscription', {});
            resetForm();
          }, function(err) {
            console.log("Failed to create subscription.",err);
            intercom.sendEvent('Trial Conversion Failed', {});
            showError();
          });
        }
      };

      $scope.accountInfoChange = function() {
        if (
          ($scope.accountInfo.info_type_account != 'Business Type') &&
          ($scope.accountInfo.info_customer_profile != 'Customer Profile') &&
          ($scope.accountInfo.info_previous_service != 'Previous Service')
        ) {
          $scope.enableEnterTuneButton = true;
        }
      };
      $scope.enableEnterTuneButton = false;
      $scope.accountInfoChange();

      $scope.enterTune = function() {
        $scope.formLoading = true;

        api.editAccount(api.userObject.account.custid, $scope.accountInfo, function() {
          // success!!! update me and close the dialog
          api.getMe().then(function(result){
            $scope.me = result;
            $scope.formLoading = false;
            window.location.reload(true);
          });
        }, function(err) {
          showError();
          console.error(err);
        });
      }

    }]
  };
});

(function (angular, app) {

  app.directive('ccmAtLeastOneLetter', function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attrs, ngModelController) {
        ngModelController.$validators.ccmAtLeastOneLetter = function (modelValue, viewValue) {
          var isValid =
            ngModelController.$isEmpty(viewValue)
            || typeof viewValue === 'undefined'
            || (viewValue && viewValue.match(/.*[a-zA-Z].*/) != null);

          return isValid;
        };
      }
    };
  });

  app.directive('ccmAtLeastOneNumber', function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attrs, ngModelController) {
        ngModelController.$validators.ccmAtLeastOneNumber = function (modelValue, viewValue) {
          var isValid =
            ngModelController.$isEmpty(viewValue)
            || angular.isUndefined(viewValue)
            || (viewValue && viewValue.match(/.*[0-9].*/) != null);

          return isValid;
        };
      }
    };
  });

})(window.angular, app);

app.directive('volumeControl', [
  '$rootScope', '$window', '$document', 'awsService',
  function($rootScope, $window, $document, awsService) {
    return {
      restrict: 'A',
      replace: true,
      templateUrl: 'partials/volume_control.html',
      scope: {
      },
      link: function(scope, el, attr) {
        if ($window.PointerEvent) {
          el.bind("pointerleave", function(ev) {
            var event = ev.originalEvent || ev;
            if (event.pointerType === 'touch') {
              scope.updateVolume();
            }
          });
        }
      },
      controller: ['$scope','api','$rootScope','$window','$document','awsService', 'playerService', 'intercom', function($scope, api, $rootScope, $window, $document, awsService, playerService, intercom) {
        var elWidth = 203;
        var queueUrl = null;
        var custId = null;
        var deviceId = null;
        var localDeviceId = null;
        var localVolume = 0.5;
        var userId = null;
        var volume = 0.5;

        var closeHandler = function() {
          var phase = $scope.$root.$$phase;
          if(phase == '$apply' || phase == '$digest') {
            $scope.show = false;
            $scope.sliderLeft = 0;
            $scope.sliderTop = 0;
            $scope.volume = 0.5;
            volume = 0.5;
          } else {
            $scope.$apply(function(){
              $scope.show = false;
              $scope.sliderLeft = 0;
              $scope.sliderTop = 0;
              $scope.volume = 0.5;
              volume = 0.5;
            });
          }
          queueUrl = null;
        }

        $rootScope.$on('showVolumeControl', function(obj, options) {
          var evt = options.evt;
          localDeviceId = api.userObject.device_id;

          if (typeof options.volume !== "undefined") {
            volume = (parseInt(options.volume)) / 100;
          } else {
            console.error('No volume passed to showVolumeControl');
            return;
          }

          $scope.volume = volume;
          localVolume = volume;

          evt.stopPropagation();
          var left = evt.clientX - elWidth - evt.offsetX + evt.target.clientWidth;
          if (left < 5) {
            left = 5;
            $scope.hideArrow = true;
          } else $scope.hideArrow = false;
          $scope.sliderLeft = left + 'px';
          $scope.sliderTop = evt.clientY - evt.offsetY - evt.target.clientHeight + 'px';

          $document.on('click', closeHandler);
          $document.on('scroll', closeHandler);
          angular.element($window).on('resize', closeHandler);
          $scope.show = true;
          custId   = options.custid;
          deviceId = options.deviceid ? options.deviceid : 0;
          userId   = options.userid;

          awsService.getQueueInfo(userId, deviceId)
            .then(function (data) {
              queueUrl = data.QueueUrl;
            })
            .catch(angular.noop);
        });

        $rootScope.$on('hideVolumeControl', function(evt, opt) {
          $document.off('click', closeHandler);
          $document.off('scroll', closeHandler);
          angular.element($window).off('resize', closeHandler);
          closeHandler();
        });

        var setRemoteVolume = function () {
          var command = 'set volume = ' + $scope.volume;
          if (queueUrl) {
            awsService.sendCommand(queueUrl, command);
          }
          else {
            setTimeout(setRemoteVolume, 1000, $scope.volume);
          }
        };

        $scope.updateVolume = function() {
          if (deviceId === localDeviceId && playerService.isPlayingMode()) {
            $scope.$emit('setPlayerVolume', $scope.volume);
          } else {
            setRemoteVolume();
          }

          var intercomData = {
            source: 'player bar',
            custid: custId,
            localDeviceId: localDeviceId,
            localUserId: userId,
            streamingDeviceId: deviceId,
            target: localDeviceId === deviceId ? 'local' : 'remote',
            volume: ($scope.volume * 100) + '%'
          }
          intercom.sendEvent("Change volume (absolute)", intercomData);
        };

        $scope.volumeClick = function(evt) {
          // Swallow click events on the slider, so the page-level click handler doesn't hide it while in use.
          evt.stopImmediatePropagation();
          evt.preventDefault();
        };

        $rootScope.$on('setLocalVolume', function(obj, volume) {
          localVolume = volume / 100;
        });

      }]
    }
  }]
);

app.directive('weekSelector', [function() {
  return {
    scope: {
      selectedDays: '=',
      byName: '=',
    },
    restrict: 'E',
    template: '<div ng-repeat="day in dow" ng-click="selectDay(day.value)" ng-class="{selected: selectedDays.indexOf(day.value) != -1}">{{day.abrev}}</div>',
    link: function(scope) {
      if (!scope.selectedDays) scope.selectedDays = [];

      scope.dow = [
        {
          name: 'monday',
          value: 0,
          abrev: 'Mo'
        },
        {
          name: 'tuesday',
          value: 1,
          abrev: 'Tu'
        },
        {
          name: 'wednesday',
          value: 2,
          abrev: 'We'
        },
        {
          name: 'thursday',
          value: 3,
          abrev: 'Th'
        },
        {
          name: 'friday',
          value: 4,
          abrev: 'Fr'
        },
        {
          name: 'saturday',
          value: 5,
          abrev: 'Sa'
        },
        {
          name: 'sunday',
          value: 6,
          abrev: 'Su'
        }
      ];

      scope.selectDay = function(day) {
        var index = scope.selectedDays.indexOf(day);
        if (index == -1) {
          scope.selectedDays.push(day);
        } else {
          scope.selectedDays.splice(index,1);
        }
        scope.$emit('day selected',{count: scope.selectedDays.length,day: day});
      }
    }
  };
}]);


app.component('adminPermissionsHelp', {
  templateUrl: 'partials/admin_permissions_help.html',
  controller: AdminPermissionsHelpController,
  controllerAs: 'vm',
})

function AdminPermissionsHelpController() {
  var vm = this;
}

(function (app) {

  app.component('contentRatingIcon', {
    templateUrl: 'partials/content_rating_icon.html',
    controller: ContentRatingIconController,
    controllerAs: 'vm',
    bindings: {
      ratingId: '@',
      showDetails: '@',
      showTooltip: '<',
      tooltipAppendToBody: '@',
      tooltipPlacement: '@'
    }
  });

  ContentRatingIconController.$inject = ['contentRatingService'];

  function ContentRatingIconController(contentRatingService) {
    var vm = this;

    vm.$onInit = function () {
      vm.rating = contentRatingService.getContentRatingDetails(vm.ratingId);

      if (vm.showTooltip && vm.rating) {
        vm.tooltip = vm.rating.summary;

        if (vm.showDetails && vm.showDetails.toLowerCase() === 'true') {
          vm.tooltip = vm.rating.description;
        }
      }
    };
  }

})(app);

app.component('locationPermissionsHelp', {
  templateUrl: 'partials/location_permissions_help.html',
  controller: LocationPermissionsHelpController,
  controllerAs: 'vm',
})

function LocationPermissionsHelpController() {
  var vm = this;
}

//# sourceMappingURL=scripts.js.map